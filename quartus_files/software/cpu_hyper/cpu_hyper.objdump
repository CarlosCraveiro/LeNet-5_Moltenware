
cpu_hyper.elf:     file format elf32-littlenios2
cpu_hyper.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00200238

Program Header:
    LOAD off    0x00001000 vaddr 0x00200000 paddr 0x00200000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00200020 paddr 0x00200020 align 2**12
         filesz 0x00007e08 memsz 0x00007e08 flags r-x
    LOAD off    0x00008e28 vaddr 0x00207e28 paddr 0x00209658 align 2**12
         filesz 0x00001830 memsz 0x00001830 flags rw-
    LOAD off    0x00000e88 vaddr 0x0020ae88 paddr 0x0020ae88 align 2**12
         filesz 0x00000000 memsz 0x00000430 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00200000  00200000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000218  00200020  00200020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00007b9c  00200238  00200238  00001238  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000054  00207dd4  00207dd4  00008dd4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001830  00207e28  00209658  00008e28  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000430  0020ae88  0020ae88  0000ae88  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  0020b2b8  0020b2b8  0000a658  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  0000a658  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000ac8  00000000  00000000  0000a688  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   000143d5  00000000  00000000  0000b150  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 0000674d  00000000  00000000  0001f525  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   00004e64  00000000  00000000  00025c72  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  00001918  00000000  00000000  0002aad8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    00001e4d  00000000  00000000  0002c3f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000030  00000000  00000000  0002e240  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000070  00000000  00000000  0002e270  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line_str 0000185a  00000000  00000000  0002e2e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000003b6  00000000  00000000  0002fb3a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 0000037a  00000000  00000000  0002fef0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  00032ab1  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000a  00000000  00000000  00032ab4  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00032abe  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00032abf  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  00032ac0  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  00032ac9  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  00032ad2  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000a  00000000  00000000  00032adb  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000042  00000000  00000000  00032ae5  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     000b17ec  00000000  00000000  00032b27  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00200000 l    d  .entry	00000000 .entry
00200020 l    d  .exceptions	00000000 .exceptions
00200238 l    d  .text	00000000 .text
00207dd4 l    d  .rodata	00000000 .rodata
00207e28 l    d  .rwdata	00000000 .rwdata
0020ae88 l    d  .bss	00000000 .bss
0020b2b8 l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.o
00200280 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 findfp.c
002004fc l     F .text	000000f0 std
002005ec l     F .text	0000003c stdin_init
00200628 l     F .text	0000003c stdout_init
00200664 l     F .text	0000003c stderr_init
002006a0 l     F .text	000000a4 sfmoreglue
00200744 l     F .text	00000044 stdio_exit_handler
00200788 l     F .text	00000060 global_stdio_init
00200968 l     F .text	000000a4 cleanup_stdio
0020ae88 l     O .bss	00000004 __sfp_recursive_mutex
00200aa4 l     F .text	00000028 __fp_lock
00200acc l     F .text	00000028 __fp_unlock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 freer.c
00000000 l    df *ABS*	00000000 mallocr.c
00202780 l     F .text	000003c4 malloc_extend_top
00000000 l    df *ABS*	00000000 reallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0020aea0 l     O .bss	00000004 __atexit_recursive_mutex
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_close.c
00204ed0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00204fdc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00205044 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
00205130 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00205210 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
002052fc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
002054d0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00209648 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
00205718 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0020584c l     F .text	00000034 alt_dev_reg
00208500 l     O .rwdata	00001060 jtag_uart
00209560 l     O .rwdata	000000c4 uart_rs
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00205b48 l     F .text	00000214 altera_avalon_jtag_uart_irq
00205d5c l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00206564 l     F .text	0000009c altera_avalon_uart_irq
00206600 l     F .text	000000e0 altera_avalon_uart_rxirq
002066e0 l     F .text	00000144 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00206878 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00206a9c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00206e38 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
002072b0 l     F .text	000000b0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
002073dc l     F .text	0000003c alt_get_errno
00207418 l     F .text	000000b8 alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
0020aec4 g     O .bss	00000004 alt_instruction_exception_handler
00204ad0 g     F .text	00000060 _isatty_r
0020540c g     F .text	0000007c alt_main
002002b8 g     F .text	00000118 _puts_r
0020b028 g     O .bss	00000100 alt_irq
00201ee0 g     F .text	00000070 _lseek_r
00209658 g       *ABS*	00000000 __flash_rwdata_start
0020b2b8 g       *ABS*	00000000 __alt_heap_start
002013c8 g     F .text	000000a0 __sseek
00200a0c g     F .text	00000058 __sinit
002054ac g     F .text	00000024 __malloc_unlock
00201998 g     F .text	00000208 memmove
002077f4 g     F .text	00000024 altera_nios2_gen2_irq_init
00200000 g     F .entry	0000001c __reset
0020ae90 g     O .bss	00000004 __stdio_exit_handler
00200020 g       *ABS*	00000000 __flash_exceptions_start
00204a68 g     F .text	00000068 _fstat_r
0020ae8c g     O .bss	00000004 errno
002012e4 g     F .text	00000030 __seofread
0020aeac g     O .bss	00000004 alt_argv
00211624 g       *ABS*	00000000 _gp
00208380 g     O .rwdata	00000180 alt_fd_list
00207818 g     F .text	00000090 alt_find_dev
00201810 g     F .text	00000188 memcpy
00207360 g     F .text	0000007c alt_io_redirect
00207dd4 g       *ABS*	00000000 __DTOR_END__
002003d0 g     F .text	00000038 puts
00207ae0 g     F .text	00000074 alt_exception_cause_generated_bad_addr
00205f60 g     F .text	00000220 altera_avalon_jtag_uart_read
00204e10 g     F .text	00000064 .hidden __udivsi3
0020516c g     F .text	000000a4 isatty
00207a50 g     F .text	00000090 alt_icache_flush
0020ae94 g     O .bss	00000004 __malloc_top_pad
00200b7c g     F .text	000005d4 __sfvwrite_r
00204b30 g     F .text	00000060 _sbrk_r
00201f50 g     F .text	00000070 _read_r
00209640 g     O .rwdata	00000004 alt_max_fd
002042a4 g     F .text	0000012c _fclose_r
0020478c g     F .text	0000005c fflush
0020ae98 g     O .bss	00000004 __malloc_max_sbrked_mem
00205338 g     F .text	000000d4 lseek
002036b0 g     F .text	00000bf4 _realloc_r
0020b2b8 g       *ABS*	00000000 __bss_end
002071c8 g     F .text	000000e8 alt_iic_isr_register
002076c8 g     F .text	0000012c alt_tick
002064b8 g     F .text	000000ac altera_avalon_uart_init
00200af4 g     F .text	00000044 __fp_lock_all
0020717c g     F .text	0000004c alt_ic_irq_enabled
00207624 g     F .text	000000a4 alt_alarm_stop
0020aeb4 g     O .bss	00000004 alt_irq_active
002000fc g     F .exceptions	000000c8 alt_irq_handler
00208358 g     O .rwdata	00000028 alt_dev_null
00201dc4 g     F .text	0000011c _reclaim_reent
00206dec g     F .text	0000004c alt_dcache_flush_all
00209658 g       *ABS*	00000000 __ram_rwdata_end
0020aec8 g     O .bss	00000138 __sf
00209638 g     O .rwdata	00000008 alt_dev_list
00205754 g     F .text	000000f8 write
00207e28 g       *ABS*	00000000 __ram_rodata_end
00205080 g     F .text	000000b0 fstat
00204e74 g     F .text	0000005c .hidden __umodsi3
0020b2b8 g       *ABS*	00000000 end
00206ad8 g     F .text	000001b4 altera_avalon_uart_write
00205a88 g     F .text	000000c0 altera_avalon_jtag_uart_init
002001c4 g     F .exceptions	00000074 alt_instruction_exception_entry
00207dd4 g       *ABS*	00000000 __CTOR_LIST__
00232000 g       *ABS*	00000000 __alt_stack_pointer
00206408 g     F .text	00000060 altera_avalon_uart_write_fd
00206468 g     F .text	00000050 altera_avalon_uart_close_fd
00206180 g     F .text	00000228 altera_avalon_jtag_uart_write
00200a64 g     F .text	00000020 __sfp_lock_acquire
0020165c g     F .text	000001b4 memchr
00202068 g     F .text	00000558 _free_r
00204b90 g     F .text	0000018c __call_exitprocs
0020b128 g     O .bss	00000190 __atexit0
0020962c g     O .rwdata	00000004 __malloc_sbrk_base
00200238 g     F .text	0000004c _start
0020aeb8 g     O .bss	00000004 _alt_tick_rate
0020aebc g     O .bss	00000008 _alt_nticks
0020550c g     F .text	000000fc read
002058bc g     F .text	00000068 alt_sys_init
00207cc4 g     F .text	00000110 __register_exitproc
00205e04 g     F .text	00000068 altera_avalon_jtag_uart_close
00207e28 g       *ABS*	00000000 __ram_rwdata_start
00207dd4 g       *ABS*	00000000 __ram_rodata_start
0020b000 g     O .bss	00000028 __malloc_current_mallinfo
00205924 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
002079b0 g     F .text	000000a0 alt_get_fd
00201d64 g     F .text	00000060 _close_r
00207b90 g     F .text	00000134 memcmp
002059e4 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0020b2b8 g       *ABS*	00000000 __alt_stack_base
00205a34 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
002014bc g     F .text	000001a0 __swsetup_r
002007e8 g     F .text	00000180 __sfp
00207f50 g     O .rwdata	00000408 __malloc_av_
0020aea4 g     O .bss	00000004 __atexit
00201248 g     F .text	0000009c __sread
002078a8 g     F .text	00000108 alt_find_file
00206e74 g     F .text	000000a8 alt_dev_llist_insert
00205488 g     F .text	00000024 __malloc_lock
00205660 g     F .text	000000b8 sbrk
00204704 g     F .text	00000088 _fflush_r
0020ae88 g       *ABS*	00000000 __bss_start
00201ba0 g     F .text	000001c4 memset
00200284 g     F .text	00000034 main
00200000 g       *ABS*	00000000 __alt_mem_RAM
0020aeb0 g     O .bss	00000004 alt_envp
0020ae9c g     O .bss	00000004 __malloc_max_total_mem
00205984 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00201468 g     F .text	00000054 __sclose
00232000 g       *ABS*	00000000 __alt_heap_limit
002043d0 g     F .text	00000038 fclose
00202b44 g     F .text	00000b6c _malloc_r
00209644 g     O .rwdata	00000004 alt_errno
00204d1c g     F .text	00000080 .hidden __divsi3
002025c0 g     F .text	000001c0 _malloc_trim_r
00207dd4 g       *ABS*	00000000 __CTOR_END__
00207dd4 g       *ABS*	00000000 __flash_rodata_start
00207dd4 g       *ABS*	00000000 __DTOR_LIST__
00205880 g     F .text	0000003c alt_irq_init
00205608 g     F .text	00000058 alt_release_fd
00207b54 g     F .text	0000003c atexit
00201fc0 g     F .text	00000070 _write_r
00209624 g     O .rwdata	00000004 _impure_ptr
0020aea8 g     O .bss	00000004 alt_argc
00204408 g     F .text	000002fc __sflush_r
00206f80 g     F .text	00000064 _do_dtors
00201150 g     F .text	000000f8 _fwalk_sglue
00200020 g       .exceptions	00000000 alt_irq_entry
00200b38 g     F .text	00000044 __fp_unlock_all
00209630 g     O .rwdata	00000008 alt_fs_list
00200020 g       *ABS*	00000000 __ram_exceptions_start
00204980 g     F .text	000000e8 __swhatbuf_r
00207018 g     F .text	00000050 alt_ic_isr_register
00207f44 g     O .rwdata	0000000c __sglue
00209658 g       *ABS*	00000000 _edata
002063a8 g     F .text	00000060 altera_avalon_uart_read_fd
0020b2b8 g       *ABS*	00000000 _end
00200238 g       *ABS*	00000000 __ram_exceptions_end
00205e6c g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
002070f0 g     F .text	0000008c alt_ic_irq_disable
00201314 g     F .text	000000b4 __swrite
00209628 g     O .rwdata	00000004 __malloc_trim_threshold
00202030 g     F .text	00000038 exit
00204d9c g     F .text	00000074 .hidden __modsi3
00207e28 g     O .rwdata	0000011c _impure_data
00232000 g       *ABS*	00000000 __alt_data_end
00200020 g     F .exceptions	00000000 alt_exception
00200a84 g     F .text	00000020 __sfp_lock_release
00206824 g     F .text	00000054 altera_avalon_uart_close
00205008 g     F .text	0000003c _exit
00206c8c g     F .text	00000160 alt_alarm_start
002047e8 g     F .text	00000198 __smakebuf_r
00200408 g     F .text	000000f4 strlen
002074d0 g     F .text	00000154 open
00206fe4 g     F .text	00000034 alt_icache_flush_all
0020964c g     O .rwdata	00000004 alt_priority_mask
00207068 g     F .text	00000088 alt_ic_irq_enable
002068b4 g     F .text	000001e8 altera_avalon_uart_read
00209650 g     O .rwdata	00000008 alt_alarm_list
00206f1c g     F .text	00000064 _do_ctors
00204f0c g     F .text	000000d0 close
00205278 g     F .text	00000084 alt_load



Disassembly of section .entry:

00200000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  200000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  200004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  200008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  20000c:	00bffd16 	blt	zero,r2,200004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  200010:	00400834 	movhi	at,32
    ori r1, r1, %lo(_start)
  200014:	08408e14 	ori	at,at,568
    jmp r1
  200018:	0800683a 	jmp	at
  20001c:	00000000 	call	0 <__reset-0x200000>

Disassembly of section .exceptions:

00200020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  200020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  200024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  200028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  20002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  200030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  200034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  200038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  20003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  200040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  200044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  200048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  20004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  200050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  200054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  200058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  20005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  200060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  200064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  200068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  20006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  200070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  200074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  200078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  20007c:	10000326 	beq	r2,zero,20008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  200080:	20000226 	beq	r4,zero,20008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  200084:	02000fc0 	call	2000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  200088:	00000706 	br	2000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  20008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  200090:	e8bfff17 	ldw	r2,-4(ea)
  200094:	e93fff04 	addi	r4,ea,-4
  200098:	02001c40 	call	2001c4 <alt_instruction_exception_entry>
  20009c:	1000021e 	bne	r2,zero,2000a8 <alt_exception+0x88>
  2000a0:	ebffff04 	addi	r15,ea,-4
  2000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  2000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  2000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  2000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  2000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  2000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  2000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  2000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  2000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  2000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  2000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  2000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  2000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  2000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  2000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  2000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  2000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  2000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  2000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  2000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  2000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  2000f8:	ef80083a 	eret

002000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  2000fc:	defff904 	addi	sp,sp,-28
  200100:	dfc00615 	stw	ra,24(sp)
  200104:	df000515 	stw	fp,20(sp)
  200108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  20010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  200110:	0005313a 	rdctl	r2,ipending
  200114:	e0bffc15 	stw	r2,-16(fp)

  return active;
  200118:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  20011c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
  200120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  200124:	00800044 	movi	r2,1
  200128:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  20012c:	e0ffff17 	ldw	r3,-4(fp)
  200130:	e0bffe17 	ldw	r2,-8(fp)
  200134:	1884703a 	and	r2,r3,r2
  200138:	10001126 	beq	r2,zero,200180 <alt_irq_handler+0x84>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  20013c:	e0bffd17 	ldw	r2,-12(fp)
  200140:	100690fa 	slli	r3,r2,3
  200144:	00800874 	movhi	r2,33
  200148:	1885883a 	add	r2,r3,r2
  20014c:	10ec0a17 	ldw	r3,-20440(r2)
  200150:	e0bffd17 	ldw	r2,-12(fp)
  200154:	100890fa 	slli	r4,r2,3
  200158:	00800874 	movhi	r2,33
  20015c:	2085883a 	add	r2,r4,r2
  200160:	10ac0b17 	ldw	r2,-20436(r2)
  200164:	1009883a 	mov	r4,r2
  200168:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  20016c:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
  200170:	0005313a 	rdctl	r2,ipending
  200174:	e0bffb15 	stw	r2,-20(fp)
  return active;
  200178:	e0bffb17 	ldw	r2,-20(fp)
  20017c:	00000706 	br	20019c <alt_irq_handler+0xa0>
      }
      mask <<= 1;
  200180:	e0bffe17 	ldw	r2,-8(fp)
  200184:	1085883a 	add	r2,r2,r2
  200188:	e0bffe15 	stw	r2,-8(fp)
      i++;
  20018c:	e0bffd17 	ldw	r2,-12(fp)
  200190:	10800044 	addi	r2,r2,1
  200194:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
  200198:	003fe406 	br	20012c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
  20019c:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
  2001a0:	e0bfff17 	ldw	r2,-4(fp)
  2001a4:	103fde1e 	bne	r2,zero,200120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  2001a8:	0001883a 	nop
}
  2001ac:	0001883a 	nop
  2001b0:	e037883a 	mov	sp,fp
  2001b4:	dfc00117 	ldw	ra,4(sp)
  2001b8:	df000017 	ldw	fp,0(sp)
  2001bc:	dec00204 	addi	sp,sp,8
  2001c0:	f800283a 	ret

002001c4 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  2001c4:	defffb04 	addi	sp,sp,-20
  2001c8:	dfc00415 	stw	ra,16(sp)
  2001cc:	df000315 	stw	fp,12(sp)
  2001d0:	df000304 	addi	fp,sp,12
  2001d4:	e13ffd15 	stw	r4,-12(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  2001d8:	000531fa 	rdctl	r2,exception
  2001dc:	e0bfff15 	stw	r2,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
  2001e0:	e0bfff17 	ldw	r2,-4(fp)
  2001e4:	1004d0ba 	srli	r2,r2,2
  2001e8:	108007cc 	andi	r2,r2,31
  2001ec:	e0bfff15 	stw	r2,-4(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
  2001f0:	0005333a 	rdctl	r2,badaddr
  2001f4:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  2001f8:	d0a62817 	ldw	r2,-26464(gp)
  2001fc:	10000726 	beq	r2,zero,20021c <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  200200:	d0a62817 	ldw	r2,-26464(gp)
  200204:	e0ffff17 	ldw	r3,-4(fp)
  200208:	e1bffe17 	ldw	r6,-8(fp)
  20020c:	e17ffd17 	ldw	r5,-12(fp)
  200210:	1809883a 	mov	r4,r3
  200214:	103ee83a 	callr	r2
  200218:	00000206 	br	200224 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  20021c:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  200220:	0005883a 	mov	r2,zero
}
  200224:	e037883a 	mov	sp,fp
  200228:	dfc00117 	ldw	ra,4(sp)
  20022c:	df000017 	ldw	fp,0(sp)
  200230:	dec00204 	addi	sp,sp,8
  200234:	f800283a 	ret

Disassembly of section .text:

00200238 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  200238:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  20023c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  200240:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  200244:	00bffd16 	blt	zero,r2,20023c <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  200248:	06c008f4 	movhi	sp,35
    ori sp, sp, %lo(__alt_stack_pointer)
  20024c:	dec80014 	ori	sp,sp,8192
    movhi gp, %hi(_gp)
  200250:	06800874 	movhi	gp,33
    ori gp, gp, %lo(_gp)
  200254:	d6858914 	ori	gp,gp,5668
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  200258:	00800834 	movhi	r2,32
    ori r2, r2, %lo(__bss_start)
  20025c:	10aba214 	ori	r2,r2,44680

    movhi r3, %hi(__bss_end)
  200260:	00c00834 	movhi	r3,32
    ori r3, r3, %lo(__bss_end)
  200264:	18ecae14 	ori	r3,r3,45752

    beq r2, r3, 1f
  200268:	10c00326 	beq	r2,r3,200278 <_start+0x40>

0:
    stw zero, (r2)
  20026c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  200270:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  200274:	10fffd36 	bltu	r2,r3,20026c <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  200278:	02052780 	call	205278 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  20027c:	020540c0 	call	20540c <alt_main>

00200280 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  200280:	003fff06 	br	200280 <alt_after_alt_main>

00200284 <main>:
 */

#include <stdio.h>

int main()
{
  200284:	defffe04 	addi	sp,sp,-8
  200288:	dfc00115 	stw	ra,4(sp)
  20028c:	df000015 	stw	fp,0(sp)
  200290:	d839883a 	mov	fp,sp
  printf("Hello from Nios II!\n");
  200294:	01000834 	movhi	r4,32
  200298:	211f7504 	addi	r4,r4,32212
  20029c:	02003d00 	call	2003d0 <puts>

  return 0;
  2002a0:	0005883a 	mov	r2,zero
}
  2002a4:	e037883a 	mov	sp,fp
  2002a8:	dfc00117 	ldw	ra,4(sp)
  2002ac:	df000017 	ldw	fp,0(sp)
  2002b0:	dec00204 	addi	sp,sp,8
  2002b4:	f800283a 	ret

002002b8 <_puts_r>:
 */

int
_puts_r (struct _reent *ptr,
       const char * s)
{
  2002b8:	defff104 	addi	sp,sp,-60
  2002bc:	dfc00e15 	stw	ra,56(sp)
  2002c0:	df000d15 	stw	fp,52(sp)
  2002c4:	df000d04 	addi	fp,sp,52
  2002c8:	e13ff415 	stw	r4,-48(fp)
  2002cc:	e17ff315 	stw	r5,-52(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
  2002d0:	e13ff317 	ldw	r4,-52(fp)
  2002d4:	02004080 	call	200408 <strlen>
  2002d8:	e0bfff15 	stw	r2,-4(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  2002dc:	e0bff317 	ldw	r2,-52(fp)
  2002e0:	e0bff515 	stw	r2,-44(fp)
  iov[0].iov_len = c;
  2002e4:	e0bfff17 	ldw	r2,-4(fp)
  2002e8:	e0bff615 	stw	r2,-40(fp)
  iov[1].iov_base = "\n";
  2002ec:	00800834 	movhi	r2,32
  2002f0:	109f7a04 	addi	r2,r2,32232
  2002f4:	e0bff715 	stw	r2,-36(fp)
  iov[1].iov_len = 1;
  2002f8:	00800044 	movi	r2,1
  2002fc:	e0bff815 	stw	r2,-32(fp)
  uio.uio_resid = c + 1;
  200300:	e0bfff17 	ldw	r2,-4(fp)
  200304:	10800044 	addi	r2,r2,1
  200308:	e0bffb15 	stw	r2,-20(fp)
  uio.uio_iov = &iov[0];
  20030c:	e0bff504 	addi	r2,fp,-44
  200310:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iovcnt = 2;
  200314:	00800084 	movi	r2,2
  200318:	e0bffa15 	stw	r2,-24(fp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  20031c:	e0bff417 	ldw	r2,-48(fp)
  200320:	10800217 	ldw	r2,8(r2)
  200324:	e0bffe15 	stw	r2,-8(fp)
  CHECK_INIT (ptr, fp);
  200328:	e0bff417 	ldw	r2,-48(fp)
  20032c:	e0bffd15 	stw	r2,-12(fp)
  200330:	e0bffd17 	ldw	r2,-12(fp)
  200334:	10000526 	beq	r2,zero,20034c <_puts_r+0x94>
  200338:	e0bffd17 	ldw	r2,-12(fp)
  20033c:	10800d17 	ldw	r2,52(r2)
  200340:	1000021e 	bne	r2,zero,20034c <_puts_r+0x94>
  200344:	e13ffd17 	ldw	r4,-12(fp)
  200348:	0200a0c0 	call	200a0c <__sinit>
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
  20034c:	e0bffe17 	ldw	r2,-8(fp)
  200350:	1080030b 	ldhu	r2,12(r2)
  200354:	10bfffcc 	andi	r2,r2,65535
  200358:	1088000c 	andi	r2,r2,8192
  20035c:	10000c1e 	bne	r2,zero,200390 <_puts_r+0xd8>
  200360:	e0bffe17 	ldw	r2,-8(fp)
  200364:	1080030b 	ldhu	r2,12(r2)
  200368:	10880014 	ori	r2,r2,8192
  20036c:	1007883a 	mov	r3,r2
  200370:	e0bffe17 	ldw	r2,-8(fp)
  200374:	10c0030d 	sth	r3,12(r2)
  200378:	e0bffe17 	ldw	r2,-8(fp)
  20037c:	10c01917 	ldw	r3,100(r2)
  200380:	00b7ffc4 	movi	r2,-8193
  200384:	1886703a 	and	r3,r3,r2
  200388:	e0bffe17 	ldw	r2,-8(fp)
  20038c:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
  200390:	e0bff904 	addi	r2,fp,-28
  200394:	100d883a 	mov	r6,r2
  200398:	e17ffe17 	ldw	r5,-8(fp)
  20039c:	e13ff417 	ldw	r4,-48(fp)
  2003a0:	0200b7c0 	call	200b7c <__sfvwrite_r>
  2003a4:	10000226 	beq	r2,zero,2003b0 <_puts_r+0xf8>
  2003a8:	00bfffc4 	movi	r2,-1
  2003ac:	00000106 	br	2003b4 <_puts_r+0xfc>
  2003b0:	00800284 	movi	r2,10
  2003b4:	e0bffc15 	stw	r2,-16(fp)
  _newlib_flockfile_end (fp);
  return result;
  2003b8:	e0bffc17 	ldw	r2,-16(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
  2003bc:	e037883a 	mov	sp,fp
  2003c0:	dfc00117 	ldw	ra,4(sp)
  2003c4:	df000017 	ldw	fp,0(sp)
  2003c8:	dec00204 	addi	sp,sp,8
  2003cc:	f800283a 	ret

002003d0 <puts>:

#ifndef _REENT_ONLY

int
puts (char const * s)
{
  2003d0:	defffd04 	addi	sp,sp,-12
  2003d4:	dfc00215 	stw	ra,8(sp)
  2003d8:	df000115 	stw	fp,4(sp)
  2003dc:	df000104 	addi	fp,sp,4
  2003e0:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
  2003e4:	d0a00017 	ldw	r2,-32768(gp)
  2003e8:	e17fff17 	ldw	r5,-4(fp)
  2003ec:	1009883a 	mov	r4,r2
  2003f0:	02002b80 	call	2002b8 <_puts_r>
}
  2003f4:	e037883a 	mov	sp,fp
  2003f8:	dfc00117 	ldw	ra,4(sp)
  2003fc:	df000017 	ldw	fp,0(sp)
  200400:	dec00204 	addi	sp,sp,8
  200404:	f800283a 	ret

00200408 <strlen>:
#error long int is not a 32bit or 64bit byte
#endif

size_t
strlen (const char *str)
{
  200408:	defffc04 	addi	sp,sp,-16
  20040c:	df000315 	stw	fp,12(sp)
  200410:	df000304 	addi	fp,sp,12
  200414:	e13ffd15 	stw	r4,-12(fp)
  const char *start = str;
  200418:	e0bffd17 	ldw	r2,-12(fp)
  20041c:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
  200420:	00000d06 	br	200458 <strlen+0x50>
    {
      if (!*str)
  200424:	e0bffd17 	ldw	r2,-12(fp)
  200428:	10800003 	ldbu	r2,0(r2)
  20042c:	10803fcc 	andi	r2,r2,255
  200430:	1080201c 	xori	r2,r2,128
  200434:	10bfe004 	addi	r2,r2,-128
  200438:	1000041e 	bne	r2,zero,20044c <strlen+0x44>
	return str - start;
  20043c:	e0fffd17 	ldw	r3,-12(fp)
  200440:	e0bffe17 	ldw	r2,-8(fp)
  200444:	1885c83a 	sub	r2,r3,r2
  200448:	00002806 	br	2004ec <strlen+0xe4>
      str++;
  20044c:	e0bffd17 	ldw	r2,-12(fp)
  200450:	10800044 	addi	r2,r2,1
  200454:	e0bffd15 	stw	r2,-12(fp)
  while (UNALIGNED (str))
  200458:	e0bffd17 	ldw	r2,-12(fp)
  20045c:	108000cc 	andi	r2,r2,3
  200460:	103ff01e 	bne	r2,zero,200424 <strlen+0x1c>
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
  200464:	e0bffd17 	ldw	r2,-12(fp)
  200468:	e0bfff15 	stw	r2,-4(fp)
  while (!DETECTNULL (*aligned_addr))
  20046c:	00000306 	br	20047c <strlen+0x74>
    aligned_addr++;
  200470:	e0bfff17 	ldw	r2,-4(fp)
  200474:	10800104 	addi	r2,r2,4
  200478:	e0bfff15 	stw	r2,-4(fp)
  while (!DETECTNULL (*aligned_addr))
  20047c:	e0bfff17 	ldw	r2,-4(fp)
  200480:	10c00017 	ldw	r3,0(r2)
  200484:	00bfbff4 	movhi	r2,65279
  200488:	10bfbfc4 	addi	r2,r2,-257
  20048c:	1887883a 	add	r3,r3,r2
  200490:	e0bfff17 	ldw	r2,-4(fp)
  200494:	10800017 	ldw	r2,0(r2)
  200498:	0084303a 	nor	r2,zero,r2
  20049c:	1886703a 	and	r3,r3,r2
  2004a0:	00a02074 	movhi	r2,32897
  2004a4:	10a02004 	addi	r2,r2,-32640
  2004a8:	1884703a 	and	r2,r3,r2
  2004ac:	103ff026 	beq	r2,zero,200470 <strlen+0x68>

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
  2004b0:	e0bfff17 	ldw	r2,-4(fp)
  2004b4:	e0bffd15 	stw	r2,-12(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
  2004b8:	00000306 	br	2004c8 <strlen+0xc0>
    str++;
  2004bc:	e0bffd17 	ldw	r2,-12(fp)
  2004c0:	10800044 	addi	r2,r2,1
  2004c4:	e0bffd15 	stw	r2,-12(fp)
  while (*str)
  2004c8:	e0bffd17 	ldw	r2,-12(fp)
  2004cc:	10800003 	ldbu	r2,0(r2)
  2004d0:	10803fcc 	andi	r2,r2,255
  2004d4:	1080201c 	xori	r2,r2,128
  2004d8:	10bfe004 	addi	r2,r2,-128
  2004dc:	103ff71e 	bne	r2,zero,2004bc <strlen+0xb4>
  return str - start;
  2004e0:	e0fffd17 	ldw	r3,-12(fp)
  2004e4:	e0bffe17 	ldw	r2,-8(fp)
  2004e8:	1885c83a 	sub	r2,r3,r2
}
  2004ec:	e037883a 	mov	sp,fp
  2004f0:	df000017 	ldw	fp,0(sp)
  2004f4:	dec00104 	addi	sp,sp,4
  2004f8:	f800283a 	ret

002004fc <std>:
static void
#endif
std (FILE *ptr,
            int flags,
            int file)
{
  2004fc:	defffb04 	addi	sp,sp,-20
  200500:	dfc00415 	stw	ra,16(sp)
  200504:	df000315 	stw	fp,12(sp)
  200508:	df000304 	addi	fp,sp,12
  20050c:	e13fff15 	stw	r4,-4(fp)
  200510:	e17ffe15 	stw	r5,-8(fp)
  200514:	e1bffd15 	stw	r6,-12(fp)
  ptr->_p = 0;
  200518:	e0bfff17 	ldw	r2,-4(fp)
  20051c:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
  200520:	e0bfff17 	ldw	r2,-4(fp)
  200524:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
  200528:	e0bfff17 	ldw	r2,-4(fp)
  20052c:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
  200530:	e0bffe17 	ldw	r2,-8(fp)
  200534:	1007883a 	mov	r3,r2
  200538:	e0bfff17 	ldw	r2,-4(fp)
  20053c:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
  200540:	e0bfff17 	ldw	r2,-4(fp)
  200544:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
  200548:	e0bffd17 	ldw	r2,-12(fp)
  20054c:	1007883a 	mov	r3,r2
  200550:	e0bfff17 	ldw	r2,-4(fp)
  200554:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
  200558:	e0bfff17 	ldw	r2,-4(fp)
  20055c:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
  200560:	e0bfff17 	ldw	r2,-4(fp)
  200564:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
  200568:	e0bfff17 	ldw	r2,-4(fp)
  20056c:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  200570:	e0bfff17 	ldw	r2,-4(fp)
  200574:	10801704 	addi	r2,r2,92
  200578:	01800204 	movi	r6,8
  20057c:	000b883a 	mov	r5,zero
  200580:	1009883a 	mov	r4,r2
  200584:	0201ba00 	call	201ba0 <memset>
  ptr->_cookie = ptr;
  200588:	e0bfff17 	ldw	r2,-4(fp)
  20058c:	e0ffff17 	ldw	r3,-4(fp)
  200590:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
  200594:	e0ffff17 	ldw	r3,-4(fp)
  200598:	00800834 	movhi	r2,32
  20059c:	10849204 	addi	r2,r2,4680
  2005a0:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
  2005a4:	e0ffff17 	ldw	r3,-4(fp)
  2005a8:	00800834 	movhi	r2,32
  2005ac:	1084c504 	addi	r2,r2,4884
  2005b0:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
  2005b4:	e0ffff17 	ldw	r3,-4(fp)
  2005b8:	00800834 	movhi	r2,32
  2005bc:	1084f204 	addi	r2,r2,5064
  2005c0:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
  2005c4:	e0ffff17 	ldw	r3,-4(fp)
  2005c8:	00800834 	movhi	r2,32
  2005cc:	10851a04 	addi	r2,r2,5224
  2005d0:	18800b15 	stw	r2,44(r3)
#endif
#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
  2005d4:	0001883a 	nop
  2005d8:	e037883a 	mov	sp,fp
  2005dc:	dfc00117 	ldw	ra,4(sp)
  2005e0:	df000017 	ldw	fp,0(sp)
  2005e4:	dec00204 	addi	sp,sp,8
  2005e8:	f800283a 	ret

002005ec <stdin_init>:

static inline void
stdin_init(FILE *ptr)
{
  2005ec:	defffd04 	addi	sp,sp,-12
  2005f0:	dfc00215 	stw	ra,8(sp)
  2005f4:	df000115 	stw	fp,4(sp)
  2005f8:	df000104 	addi	fp,sp,4
  2005fc:	e13fff15 	stw	r4,-4(fp)
  std (ptr,  __SRD, 0);
  200600:	000d883a 	mov	r6,zero
  200604:	01400104 	movi	r5,4
  200608:	e13fff17 	ldw	r4,-4(fp)
  20060c:	02004fc0 	call	2004fc <std>
}
  200610:	0001883a 	nop
  200614:	e037883a 	mov	sp,fp
  200618:	dfc00117 	ldw	ra,4(sp)
  20061c:	df000017 	ldw	fp,0(sp)
  200620:	dec00204 	addi	sp,sp,8
  200624:	f800283a 	ret

00200628 <stdout_init>:

static inline void
stdout_init(FILE *ptr)
{
  200628:	defffd04 	addi	sp,sp,-12
  20062c:	dfc00215 	stw	ra,8(sp)
  200630:	df000115 	stw	fp,4(sp)
  200634:	df000104 	addi	fp,sp,4
  200638:	e13fff15 	stw	r4,-4(fp)
#ifdef HAVE_FCNTL
/*std (ptr, __SWR, 1); */
  std (ptr, __SWR | __SNBF, 1);	/* IntelSpecific: Change to have no buffering on stdout. */
#else
/*std (ptr, __SWR | __SLBF, 1); */
  std (ptr, __SWR | __SNBF, 1);	/* IntelSpecific: Change to have no buffering on stdout. */
  20063c:	01800044 	movi	r6,1
  200640:	01400284 	movi	r5,10
  200644:	e13fff17 	ldw	r4,-4(fp)
  200648:	02004fc0 	call	2004fc <std>
#endif
}
  20064c:	0001883a 	nop
  200650:	e037883a 	mov	sp,fp
  200654:	dfc00117 	ldw	ra,4(sp)
  200658:	df000017 	ldw	fp,0(sp)
  20065c:	dec00204 	addi	sp,sp,8
  200660:	f800283a 	ret

00200664 <stderr_init>:

static inline void
stderr_init(FILE *ptr)
{
  200664:	defffd04 	addi	sp,sp,-12
  200668:	dfc00215 	stw	ra,8(sp)
  20066c:	df000115 	stw	fp,4(sp)
  200670:	df000104 	addi	fp,sp,4
  200674:	e13fff15 	stw	r4,-4(fp)
  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (ptr, __SRW | __SNBF, 2);
  200678:	01800084 	movi	r6,2
  20067c:	01400484 	movi	r5,18
  200680:	e13fff17 	ldw	r4,-4(fp)
  200684:	02004fc0 	call	2004fc <std>
}
  200688:	0001883a 	nop
  20068c:	e037883a 	mov	sp,fp
  200690:	dfc00117 	ldw	ra,4(sp)
  200694:	df000017 	ldw	fp,0(sp)
  200698:	dec00204 	addi	sp,sp,8
  20069c:	f800283a 	ret

002006a0 <sfmoreglue>:
  FILE file;
};

static struct _glue *
sfmoreglue (struct _reent *d, int n)
{
  2006a0:	defffb04 	addi	sp,sp,-20
  2006a4:	dfc00415 	stw	ra,16(sp)
  2006a8:	df000315 	stw	fp,12(sp)
  2006ac:	df000304 	addi	fp,sp,12
  2006b0:	e13ffe15 	stw	r4,-8(fp)
  2006b4:	e17ffd15 	stw	r5,-12(fp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  2006b8:	e0bffd17 	ldw	r2,-12(fp)
  2006bc:	10bfffc4 	addi	r2,r2,-1
  2006c0:	10801a24 	muli	r2,r2,104
  2006c4:	10801d04 	addi	r2,r2,116
  2006c8:	100b883a 	mov	r5,r2
  2006cc:	e13ffe17 	ldw	r4,-8(fp)
  2006d0:	0202b440 	call	202b44 <_malloc_r>
  2006d4:	e0bfff15 	stw	r2,-4(fp)
  if (g == NULL)
  2006d8:	e0bfff17 	ldw	r2,-4(fp)
  2006dc:	1000021e 	bne	r2,zero,2006e8 <sfmoreglue+0x48>
    return NULL;
  2006e0:	0005883a 	mov	r2,zero
  2006e4:	00001206 	br	200730 <sfmoreglue+0x90>
  g->glue._next = NULL;
  2006e8:	e0bfff17 	ldw	r2,-4(fp)
  2006ec:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
  2006f0:	e0bfff17 	ldw	r2,-4(fp)
  2006f4:	e0fffd17 	ldw	r3,-12(fp)
  2006f8:	10c00115 	stw	r3,4(r2)
  g->glue._iobs = &g->file;
  2006fc:	e0bfff17 	ldw	r2,-4(fp)
  200700:	10c00304 	addi	r3,r2,12
  200704:	e0bfff17 	ldw	r2,-4(fp)
  200708:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
  20070c:	e0bfff17 	ldw	r2,-4(fp)
  200710:	10c00304 	addi	r3,r2,12
  200714:	e0bffd17 	ldw	r2,-12(fp)
  200718:	10801a24 	muli	r2,r2,104
  20071c:	100d883a 	mov	r6,r2
  200720:	000b883a 	mov	r5,zero
  200724:	1809883a 	mov	r4,r3
  200728:	0201ba00 	call	201ba0 <memset>
  return &g->glue;
  20072c:	e0bfff17 	ldw	r2,-4(fp)
}
  200730:	e037883a 	mov	sp,fp
  200734:	dfc00117 	ldw	ra,4(sp)
  200738:	df000017 	ldw	fp,0(sp)
  20073c:	dec00204 	addi	sp,sp,8
  200740:	f800283a 	ret

00200744 <stdio_exit_handler>:

static void
stdio_exit_handler (void)
{
  200744:	defffe04 	addi	sp,sp,-8
  200748:	dfc00115 	stw	ra,4(sp)
  20074c:	df000015 	stw	fp,0(sp)
  200750:	d839883a 	mov	fp,sp
  (void) _fwalk_sglue (_GLOBAL_REENT, CLEANUP_FILE, &__sglue);
  200754:	01800834 	movhi	r6,32
  200758:	319fd104 	addi	r6,r6,32580
  20075c:	01400834 	movhi	r5,32
  200760:	2950a904 	addi	r5,r5,17060
  200764:	01000834 	movhi	r4,32
  200768:	211f8a04 	addi	r4,r4,32296
  20076c:	02011500 	call	201150 <_fwalk_sglue>
}
  200770:	0001883a 	nop
  200774:	e037883a 	mov	sp,fp
  200778:	dfc00117 	ldw	ra,4(sp)
  20077c:	df000017 	ldw	fp,0(sp)
  200780:	dec00204 	addi	sp,sp,8
  200784:	f800283a 	ret

00200788 <global_stdio_init>:

static void
global_stdio_init (void)
{
  200788:	defffe04 	addi	sp,sp,-8
  20078c:	dfc00115 	stw	ra,4(sp)
  200790:	df000015 	stw	fp,0(sp)
  200794:	d839883a 	mov	fp,sp
  if (__stdio_exit_handler == NULL) {
  200798:	d0a61b17 	ldw	r2,-26516(gp)
  20079c:	10000c1e 	bne	r2,zero,2007d0 <global_stdio_init+0x48>
    __stdio_exit_handler = stdio_exit_handler;
  2007a0:	00800834 	movhi	r2,32
  2007a4:	1081d104 	addi	r2,r2,1860
  2007a8:	d0a61b15 	stw	r2,-26516(gp)
    stdin_init (&__sf[0]);
  2007ac:	01000874 	movhi	r4,33
  2007b0:	212bb204 	addi	r4,r4,-20792
  2007b4:	02005ec0 	call	2005ec <stdin_init>
    stdout_init (&__sf[1]);
  2007b8:	01000874 	movhi	r4,33
  2007bc:	212bcc04 	addi	r4,r4,-20688
  2007c0:	02006280 	call	200628 <stdout_init>
    stderr_init (&__sf[2]);
  2007c4:	01000874 	movhi	r4,33
  2007c8:	212be604 	addi	r4,r4,-20584
  2007cc:	02006640 	call	200664 <stderr_init>
  }
}
  2007d0:	0001883a 	nop
  2007d4:	e037883a 	mov	sp,fp
  2007d8:	dfc00117 	ldw	ra,4(sp)
  2007dc:	df000017 	ldw	fp,0(sp)
  2007e0:	dec00204 	addi	sp,sp,8
  2007e4:	f800283a 	ret

002007e8 <__sfp>:
 * Find a free FILE for fopen et al.
 */

FILE *
__sfp (struct _reent *d)
{
  2007e8:	defffa04 	addi	sp,sp,-24
  2007ec:	dfc00515 	stw	ra,20(sp)
  2007f0:	df000415 	stw	fp,16(sp)
  2007f4:	df000404 	addi	fp,sp,16
  2007f8:	e13ffc15 	stw	r4,-16(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
  2007fc:	0200a640 	call	200a64 <__sfp_lock_acquire>
  global_stdio_init ();
  200800:	02007880 	call	200788 <global_stdio_init>

  for (g = &__sglue;; g = g->_next)
  200804:	00800834 	movhi	r2,32
  200808:	109fd104 	addi	r2,r2,32580
  20080c:	e0bffd15 	stw	r2,-12(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  200810:	e0bffd17 	ldw	r2,-12(fp)
  200814:	10800217 	ldw	r2,8(r2)
  200818:	e0bfff15 	stw	r2,-4(fp)
  20081c:	e0bffd17 	ldw	r2,-12(fp)
  200820:	10800117 	ldw	r2,4(r2)
  200824:	e0bffe15 	stw	r2,-8(fp)
  200828:	00000906 	br	200850 <__sfp+0x68>
	if (fp->_flags == 0)
  20082c:	e0bfff17 	ldw	r2,-4(fp)
  200830:	1080030b 	ldhu	r2,12(r2)
  200834:	10bfffcc 	andi	r2,r2,65535
  200838:	10a0001c 	xori	r2,r2,32768
  20083c:	10a00004 	addi	r2,r2,-32768
  200840:	10001f26 	beq	r2,zero,2008c0 <__sfp+0xd8>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  200844:	e0bfff17 	ldw	r2,-4(fp)
  200848:	10801a04 	addi	r2,r2,104
  20084c:	e0bfff15 	stw	r2,-4(fp)
  200850:	e0bffe17 	ldw	r2,-8(fp)
  200854:	10bfffc4 	addi	r2,r2,-1
  200858:	e0bffe15 	stw	r2,-8(fp)
  20085c:	e0bffe17 	ldw	r2,-8(fp)
  200860:	103ff20e 	bge	r2,zero,20082c <__sfp+0x44>
	  goto found;
      if (g->_next == NULL &&
  200864:	e0bffd17 	ldw	r2,-12(fp)
  200868:	10800017 	ldw	r2,0(r2)
  20086c:	1000091e 	bne	r2,zero,200894 <__sfp+0xac>
	  (g->_next = sfmoreglue (d, NDYNAMIC)) == NULL)
  200870:	01400104 	movi	r5,4
  200874:	e13ffc17 	ldw	r4,-16(fp)
  200878:	02006a00 	call	2006a0 <sfmoreglue>
  20087c:	1007883a 	mov	r3,r2
  200880:	e0bffd17 	ldw	r2,-12(fp)
  200884:	10c00015 	stw	r3,0(r2)
  200888:	e0bffd17 	ldw	r2,-12(fp)
  20088c:	10800017 	ldw	r2,0(r2)
      if (g->_next == NULL &&
  200890:	10000426 	beq	r2,zero,2008a4 <__sfp+0xbc>
  for (g = &__sglue;; g = g->_next)
  200894:	e0bffd17 	ldw	r2,-12(fp)
  200898:	10800017 	ldw	r2,0(r2)
  20089c:	e0bffd15 	stw	r2,-12(fp)
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  2008a0:	003fdb06 	br	200810 <__sfp+0x28>
	break;
  2008a4:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
  2008a8:	0200a840 	call	200a84 <__sfp_lock_release>
  _REENT_ERRNO(d) = ENOMEM;
  2008ac:	e0bffc17 	ldw	r2,-16(fp)
  2008b0:	00c00304 	movi	r3,12
  2008b4:	10c00015 	stw	r3,0(r2)
  return NULL;
  2008b8:	0005883a 	mov	r2,zero
  2008bc:	00002506 	br	200954 <__sfp+0x16c>
	  goto found;
  2008c0:	0001883a 	nop

found:
  fp->_file = -1;		/* no file */
  2008c4:	e0bfff17 	ldw	r2,-4(fp)
  2008c8:	00ffffc4 	movi	r3,-1
  2008cc:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
  2008d0:	e0bfff17 	ldw	r2,-4(fp)
  2008d4:	00c00044 	movi	r3,1
  2008d8:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
  2008dc:	e0bfff17 	ldw	r2,-4(fp)
  2008e0:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
  2008e4:	0200a840 	call	200a84 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
  2008e8:	e0bfff17 	ldw	r2,-4(fp)
  2008ec:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
  2008f0:	e0bfff17 	ldw	r2,-4(fp)
  2008f4:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
  2008f8:	e0bfff17 	ldw	r2,-4(fp)
  2008fc:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
  200900:	e0bfff17 	ldw	r2,-4(fp)
  200904:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
  200908:	e0bfff17 	ldw	r2,-4(fp)
  20090c:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
  200910:	e0bfff17 	ldw	r2,-4(fp)
  200914:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
  200918:	e0bfff17 	ldw	r2,-4(fp)
  20091c:	10801704 	addi	r2,r2,92
  200920:	01800204 	movi	r6,8
  200924:	000b883a 	mov	r5,zero
  200928:	1009883a 	mov	r4,r2
  20092c:	0201ba00 	call	201ba0 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
  200930:	e0bfff17 	ldw	r2,-4(fp)
  200934:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
  200938:	e0bfff17 	ldw	r2,-4(fp)
  20093c:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
  200940:	e0bfff17 	ldw	r2,-4(fp)
  200944:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
  200948:	e0bfff17 	ldw	r2,-4(fp)
  20094c:	10001215 	stw	zero,72(r2)

  return fp;
  200950:	e0bfff17 	ldw	r2,-4(fp)
}
  200954:	e037883a 	mov	sp,fp
  200958:	dfc00117 	ldw	ra,4(sp)
  20095c:	df000017 	ldw	fp,0(sp)
  200960:	dec00204 	addi	sp,sp,8
  200964:	f800283a 	ret

00200968 <cleanup_stdio>:
 * The name `_cleanup' is, alas, fairly well known outside stdio.
 */

static void
cleanup_stdio (struct _reent *ptr)
{
  200968:	defffd04 	addi	sp,sp,-12
  20096c:	dfc00215 	stw	ra,8(sp)
  200970:	df000115 	stw	fp,4(sp)
  200974:	df000104 	addi	fp,sp,4
  200978:	e13fff15 	stw	r4,-4(fp)
  if (_REENT_STDIN(ptr) != &__sf[0])
  20097c:	e0bfff17 	ldw	r2,-4(fp)
  200980:	10c00117 	ldw	r3,4(r2)
  200984:	00800874 	movhi	r2,33
  200988:	10abb204 	addi	r2,r2,-20792
  20098c:	18800526 	beq	r3,r2,2009a4 <cleanup_stdio+0x3c>
    CLEANUP_FILE (ptr, _REENT_STDIN(ptr));
  200990:	e0bfff17 	ldw	r2,-4(fp)
  200994:	10800117 	ldw	r2,4(r2)
  200998:	100b883a 	mov	r5,r2
  20099c:	e13fff17 	ldw	r4,-4(fp)
  2009a0:	02042a40 	call	2042a4 <_fclose_r>
  if (_REENT_STDOUT(ptr) != &__sf[1])
  2009a4:	e0bfff17 	ldw	r2,-4(fp)
  2009a8:	10c00217 	ldw	r3,8(r2)
  2009ac:	00800874 	movhi	r2,33
  2009b0:	10abcc04 	addi	r2,r2,-20688
  2009b4:	18800526 	beq	r3,r2,2009cc <cleanup_stdio+0x64>
    CLEANUP_FILE (ptr, _REENT_STDOUT(ptr));
  2009b8:	e0bfff17 	ldw	r2,-4(fp)
  2009bc:	10800217 	ldw	r2,8(r2)
  2009c0:	100b883a 	mov	r5,r2
  2009c4:	e13fff17 	ldw	r4,-4(fp)
  2009c8:	02042a40 	call	2042a4 <_fclose_r>
  if (_REENT_STDERR(ptr) != &__sf[2])
  2009cc:	e0bfff17 	ldw	r2,-4(fp)
  2009d0:	10c00317 	ldw	r3,12(r2)
  2009d4:	00800874 	movhi	r2,33
  2009d8:	10abe604 	addi	r2,r2,-20584
  2009dc:	18800526 	beq	r3,r2,2009f4 <cleanup_stdio+0x8c>
    CLEANUP_FILE (ptr, _REENT_STDERR(ptr));
  2009e0:	e0bfff17 	ldw	r2,-4(fp)
  2009e4:	10800317 	ldw	r2,12(r2)
  2009e8:	100b883a 	mov	r5,r2
  2009ec:	e13fff17 	ldw	r4,-4(fp)
  2009f0:	02042a40 	call	2042a4 <_fclose_r>
}
  2009f4:	0001883a 	nop
  2009f8:	e037883a 	mov	sp,fp
  2009fc:	dfc00117 	ldw	ra,4(sp)
  200a00:	df000017 	ldw	fp,0(sp)
  200a04:	dec00204 	addi	sp,sp,8
  200a08:	f800283a 	ret

00200a0c <__sinit>:
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

void
__sinit (struct _reent *s)
{
  200a0c:	defffd04 	addi	sp,sp,-12
  200a10:	dfc00215 	stw	ra,8(sp)
  200a14:	df000115 	stw	fp,4(sp)
  200a18:	df000104 	addi	fp,sp,4
  200a1c:	e13fff15 	stw	r4,-4(fp)
  __sfp_lock_acquire ();
  200a20:	0200a640 	call	200a64 <__sfp_lock_acquire>

  if (_REENT_CLEANUP(s))
  200a24:	e0bfff17 	ldw	r2,-4(fp)
  200a28:	10800d17 	ldw	r2,52(r2)
  200a2c:	10000226 	beq	r2,zero,200a38 <__sinit+0x2c>
    {
      __sfp_lock_release ();
  200a30:	0200a840 	call	200a84 <__sfp_lock_release>
      return;
  200a34:	00000606 	br	200a50 <__sinit+0x44>
    }

  /* make sure we clean up on exit */
  _REENT_CLEANUP(s) = cleanup_stdio;	/* conservative */
  200a38:	e0ffff17 	ldw	r3,-4(fp)
  200a3c:	00800834 	movhi	r2,32
  200a40:	10825a04 	addi	r2,r2,2408
  200a44:	18800d15 	stw	r2,52(r3)

  global_stdio_init ();
  200a48:	02007880 	call	200788 <global_stdio_init>
  __sfp_lock_release ();
  200a4c:	0200a840 	call	200a84 <__sfp_lock_release>
}
  200a50:	e037883a 	mov	sp,fp
  200a54:	dfc00117 	ldw	ra,4(sp)
  200a58:	df000017 	ldw	fp,0(sp)
  200a5c:	dec00204 	addi	sp,sp,8
  200a60:	f800283a 	ret

00200a64 <__sfp_lock_acquire>:

__LOCK_INIT_RECURSIVE(static, __sfp_recursive_mutex);

void
__sfp_lock_acquire (void)
{
  200a64:	deffff04 	addi	sp,sp,-4
  200a68:	df000015 	stw	fp,0(sp)
  200a6c:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_recursive_mutex);
}
  200a70:	0001883a 	nop
  200a74:	e037883a 	mov	sp,fp
  200a78:	df000017 	ldw	fp,0(sp)
  200a7c:	dec00104 	addi	sp,sp,4
  200a80:	f800283a 	ret

00200a84 <__sfp_lock_release>:

void
__sfp_lock_release (void)
{
  200a84:	deffff04 	addi	sp,sp,-4
  200a88:	df000015 	stw	fp,0(sp)
  200a8c:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_recursive_mutex);
}
  200a90:	0001883a 	nop
  200a94:	e037883a 	mov	sp,fp
  200a98:	df000017 	ldw	fp,0(sp)
  200a9c:	dec00104 	addi	sp,sp,4
  200aa0:	f800283a 	ret

00200aa4 <__fp_lock>:

/* Walkable file locking routine.  */
static int
__fp_lock (struct _reent * ptr __unused, FILE * fp)
{
  200aa4:	defffd04 	addi	sp,sp,-12
  200aa8:	df000215 	stw	fp,8(sp)
  200aac:	df000204 	addi	fp,sp,8
  200ab0:	e13fff15 	stw	r4,-4(fp)
  200ab4:	e17ffe15 	stw	r5,-8(fp)
  if (!(fp->_flags2 & __SNLK))
    _flockfile (fp);

  return 0;
  200ab8:	0005883a 	mov	r2,zero
}
  200abc:	e037883a 	mov	sp,fp
  200ac0:	df000017 	ldw	fp,0(sp)
  200ac4:	dec00104 	addi	sp,sp,4
  200ac8:	f800283a 	ret

00200acc <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
__fp_unlock (struct _reent * ptr __unused, FILE * fp)
{
  200acc:	defffd04 	addi	sp,sp,-12
  200ad0:	df000215 	stw	fp,8(sp)
  200ad4:	df000204 	addi	fp,sp,8
  200ad8:	e13fff15 	stw	r4,-4(fp)
  200adc:	e17ffe15 	stw	r5,-8(fp)
  if (!(fp->_flags2 & __SNLK))
    _funlockfile (fp);

  return 0;
  200ae0:	0005883a 	mov	r2,zero
}
  200ae4:	e037883a 	mov	sp,fp
  200ae8:	df000017 	ldw	fp,0(sp)
  200aec:	dec00104 	addi	sp,sp,4
  200af0:	f800283a 	ret

00200af4 <__fp_lock_all>:

void
__fp_lock_all (void)
{
  200af4:	defffe04 	addi	sp,sp,-8
  200af8:	dfc00115 	stw	ra,4(sp)
  200afc:	df000015 	stw	fp,0(sp)
  200b00:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
  200b04:	0200a640 	call	200a64 <__sfp_lock_acquire>
  (void) _fwalk_sglue (NULL, __fp_lock, &__sglue);
  200b08:	01800834 	movhi	r6,32
  200b0c:	319fd104 	addi	r6,r6,32580
  200b10:	01400834 	movhi	r5,32
  200b14:	2942a904 	addi	r5,r5,2724
  200b18:	0009883a 	mov	r4,zero
  200b1c:	02011500 	call	201150 <_fwalk_sglue>
}
  200b20:	0001883a 	nop
  200b24:	e037883a 	mov	sp,fp
  200b28:	dfc00117 	ldw	ra,4(sp)
  200b2c:	df000017 	ldw	fp,0(sp)
  200b30:	dec00204 	addi	sp,sp,8
  200b34:	f800283a 	ret

00200b38 <__fp_unlock_all>:

void
__fp_unlock_all (void)
{
  200b38:	defffe04 	addi	sp,sp,-8
  200b3c:	dfc00115 	stw	ra,4(sp)
  200b40:	df000015 	stw	fp,0(sp)
  200b44:	d839883a 	mov	fp,sp
  (void) _fwalk_sglue (NULL, __fp_unlock, &__sglue);
  200b48:	01800834 	movhi	r6,32
  200b4c:	319fd104 	addi	r6,r6,32580
  200b50:	01400834 	movhi	r5,32
  200b54:	2942b304 	addi	r5,r5,2764
  200b58:	0009883a 	mov	r4,zero
  200b5c:	02011500 	call	201150 <_fwalk_sglue>
  __sfp_lock_release ();
  200b60:	0200a840 	call	200a84 <__sfp_lock_release>
}
  200b64:	0001883a 	nop
  200b68:	e037883a 	mov	sp,fp
  200b6c:	dfc00117 	ldw	ra,4(sp)
  200b70:	df000017 	ldw	fp,0(sp)
  200b74:	dec00204 	addi	sp,sp,8
  200b78:	f800283a 	ret

00200b7c <__sfvwrite_r>:

int
__sfvwrite_r (struct _reent *ptr,
       register FILE *fp,
       register struct __suio *uio)
{
  200b7c:	defff004 	addi	sp,sp,-64
  200b80:	dfc00f15 	stw	ra,60(sp)
  200b84:	df000e15 	stw	fp,56(sp)
  200b88:	dd800d15 	stw	r22,52(sp)
  200b8c:	dd400c15 	stw	r21,48(sp)
  200b90:	dd000b15 	stw	r20,44(sp)
  200b94:	dcc00a15 	stw	r19,40(sp)
  200b98:	dc800915 	stw	r18,36(sp)
  200b9c:	dc400815 	stw	r17,32(sp)
  200ba0:	dc000715 	stw	r16,28(sp)
  200ba4:	df000e04 	addi	fp,sp,56
  200ba8:	e13ff215 	stw	r4,-56(fp)
  200bac:	2821883a 	mov	r16,r5
  200bb0:	302b883a 	mov	r21,r6
  register size_t len;
  register const char *p = NULL;
  200bb4:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
  200bb8:	ac800217 	ldw	r18,8(r21)
  200bbc:	9000021e 	bne	r18,zero,200bc8 <__sfvwrite_r+0x4c>
    return 0;
  200bc0:	0005883a 	mov	r2,zero
  200bc4:	00015606 	br	201120 <__sfvwrite_r+0x5a4>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
  200bc8:	8080030b 	ldhu	r2,12(r16)
  200bcc:	10bfffcc 	andi	r2,r2,65535
  200bd0:	1080020c 	andi	r2,r2,8
  200bd4:	10000226 	beq	r2,zero,200be0 <__sfvwrite_r+0x64>
  200bd8:	80800417 	ldw	r2,16(r16)
  200bdc:	1000061e 	bne	r2,zero,200bf8 <__sfvwrite_r+0x7c>
  200be0:	800b883a 	mov	r5,r16
  200be4:	e13ff217 	ldw	r4,-56(fp)
  200be8:	02014bc0 	call	2014bc <__swsetup_r>
  200bec:	10000226 	beq	r2,zero,200bf8 <__sfvwrite_r+0x7c>
    return EOF;
  200bf0:	00bfffc4 	movi	r2,-1
  200bf4:	00014a06 	br	201120 <__sfvwrite_r+0x5a4>

  iov = uio->uio_iov;
  200bf8:	ad000017 	ldw	r20,0(r21)
  len = 0;
  200bfc:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
  200c00:	8080030b 	ldhu	r2,12(r16)
  200c04:	10bfffcc 	andi	r2,r2,65535
  200c08:	1080008c 	andi	r2,r2,2
  200c0c:	10001f26 	beq	r2,zero,200c8c <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
  200c10:	00000306 	br	200c20 <__sfvwrite_r+0xa4>
  200c14:	a4c00017 	ldw	r19,0(r20)
  200c18:	a4800117 	ldw	r18,4(r20)
  200c1c:	a5000204 	addi	r20,r20,8
  200c20:	903ffc26 	beq	r18,zero,200c14 <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
  200c24:	82000917 	ldw	r8,36(r16)
  200c28:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
  200c2c:	9005883a 	mov	r2,r18
  200c30:	00e00034 	movhi	r3,32768
  200c34:	18ff0004 	addi	r3,r3,-1024
  200c38:	1880022e 	bgeu	r3,r2,200c44 <__sfvwrite_r+0xc8>
  200c3c:	00a00034 	movhi	r2,32768
  200c40:	10bf0004 	addi	r2,r2,-1024
	  w = fp->_write (ptr, fp->_cookie, p,
  200c44:	100f883a 	mov	r7,r2
  200c48:	980d883a 	mov	r6,r19
  200c4c:	200b883a 	mov	r5,r4
  200c50:	e13ff217 	ldw	r4,-56(fp)
  200c54:	403ee83a 	callr	r8
  200c58:	1023883a 	mov	r17,r2
	  if (w <= 0)
  200c5c:	0441270e 	bge	zero,r17,2010fc <__sfvwrite_r+0x580>
	    goto err;
	  p += w;
  200c60:	8805883a 	mov	r2,r17
  200c64:	98a7883a 	add	r19,r19,r2
	  len -= w;
  200c68:	8805883a 	mov	r2,r17
  200c6c:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
  200c70:	a8800217 	ldw	r2,8(r21)
  200c74:	8807883a 	mov	r3,r17
  200c78:	10c5c83a 	sub	r2,r2,r3
  200c7c:	a8800215 	stw	r2,8(r21)
  200c80:	a8800217 	ldw	r2,8(r21)
  200c84:	103fe61e 	bne	r2,zero,200c20 <__sfvwrite_r+0xa4>
  200c88:	00011a06 	br	2010f4 <__sfvwrite_r+0x578>
    }
  else if ((fp->_flags & __SLBF) == 0)
  200c8c:	8080030b 	ldhu	r2,12(r16)
  200c90:	10bfffcc 	andi	r2,r2,65535
  200c94:	1080004c 	andi	r2,r2,1
  200c98:	1000b41e 	bne	r2,zero,200f6c <__sfvwrite_r+0x3f0>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
  200c9c:	00000306 	br	200cac <__sfvwrite_r+0x130>
  200ca0:	a4c00017 	ldw	r19,0(r20)
  200ca4:	a4800117 	ldw	r18,4(r20)
  200ca8:	a5000204 	addi	r20,r20,8
  200cac:	903ffc26 	beq	r18,zero,200ca0 <__sfvwrite_r+0x124>
	  w = fp->_w;
  200cb0:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
  200cb4:	8080030b 	ldhu	r2,12(r16)
  200cb8:	10bfffcc 	andi	r2,r2,65535
  200cbc:	1080800c 	andi	r2,r2,512
  200cc0:	10006826 	beq	r2,zero,200e64 <__sfvwrite_r+0x2e8>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
  200cc4:	8805883a 	mov	r2,r17
  200cc8:	90805436 	bltu	r18,r2,200e1c <__sfvwrite_r+0x2a0>
  200ccc:	8080030b 	ldhu	r2,12(r16)
  200cd0:	10bfffcc 	andi	r2,r2,65535
  200cd4:	1081200c 	andi	r2,r2,1152
  200cd8:	10005026 	beq	r2,zero,200e1c <__sfvwrite_r+0x2a0>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
  200cdc:	80c00017 	ldw	r3,0(r16)
  200ce0:	80800417 	ldw	r2,16(r16)
  200ce4:	1885c83a 	sub	r2,r3,r2
  200ce8:	e0bff315 	stw	r2,-52(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
  200cec:	80800517 	ldw	r2,20(r16)
  200cf0:	108000e4 	muli	r2,r2,3
  200cf4:	1006d7fa 	srli	r3,r2,31
  200cf8:	1885883a 	add	r2,r3,r2
  200cfc:	1005d07a 	srai	r2,r2,1
  200d00:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
  200d04:	e0bff317 	ldw	r2,-52(fp)
  200d08:	9085883a 	add	r2,r18,r2
  200d0c:	10800044 	addi	r2,r2,1
  200d10:	e0fff517 	ldw	r3,-44(fp)
  200d14:	1880042e 	bgeu	r3,r2,200d28 <__sfvwrite_r+0x1ac>
		    newsize = curpos + len + 1;
  200d18:	e0bff317 	ldw	r2,-52(fp)
  200d1c:	9085883a 	add	r2,r18,r2
  200d20:	10800044 	addi	r2,r2,1
  200d24:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
  200d28:	8080030b 	ldhu	r2,12(r16)
  200d2c:	10bfffcc 	andi	r2,r2,65535
  200d30:	1081000c 	andi	r2,r2,1024
  200d34:	10001726 	beq	r2,zero,200d94 <__sfvwrite_r+0x218>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
  200d38:	e0bff517 	ldw	r2,-44(fp)
  200d3c:	100b883a 	mov	r5,r2
  200d40:	e13ff217 	ldw	r4,-56(fp)
  200d44:	0202b440 	call	202b44 <_malloc_r>
  200d48:	e0bff615 	stw	r2,-40(fp)
		      if (!str)
  200d4c:	e0bff617 	ldw	r2,-40(fp)
  200d50:	1000041e 	bne	r2,zero,200d64 <__sfvwrite_r+0x1e8>
			{
			  _REENT_ERRNO(ptr) = ENOMEM;
  200d54:	e0bff217 	ldw	r2,-56(fp)
  200d58:	00c00304 	movi	r3,12
  200d5c:	10c00015 	stw	r3,0(r2)
			  goto err;
  200d60:	0000eb06 	br	201110 <__sfvwrite_r+0x594>
			}
		      memcpy (str, fp->_bf._base, curpos);
  200d64:	80800417 	ldw	r2,16(r16)
  200d68:	e0fff317 	ldw	r3,-52(fp)
  200d6c:	180d883a 	mov	r6,r3
  200d70:	100b883a 	mov	r5,r2
  200d74:	e13ff617 	ldw	r4,-40(fp)
  200d78:	02018100 	call	201810 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
  200d7c:	80c0030b 	ldhu	r3,12(r16)
  200d80:	00bedfc4 	movi	r2,-1153
  200d84:	1884703a 	and	r2,r3,r2
  200d88:	10802014 	ori	r2,r2,128
  200d8c:	8080030d 	sth	r2,12(r16)
  200d90:	00001506 	br	200de8 <__sfvwrite_r+0x26c>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
  200d94:	80800417 	ldw	r2,16(r16)
  200d98:	e0fff517 	ldw	r3,-44(fp)
  200d9c:	180d883a 	mov	r6,r3
  200da0:	100b883a 	mov	r5,r2
  200da4:	e13ff217 	ldw	r4,-56(fp)
  200da8:	02036b00 	call	2036b0 <_realloc_r>
  200dac:	e0bff615 	stw	r2,-40(fp)
							 newsize);
		      if (!str)
  200db0:	e0bff617 	ldw	r2,-40(fp)
  200db4:	10000c1e 	bne	r2,zero,200de8 <__sfvwrite_r+0x26c>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
  200db8:	80800417 	ldw	r2,16(r16)
  200dbc:	100b883a 	mov	r5,r2
  200dc0:	e13ff217 	ldw	r4,-56(fp)
  200dc4:	02020680 	call	202068 <_free_r>
			  fp->_flags &=  ~__SMBF;
  200dc8:	80c0030b 	ldhu	r3,12(r16)
  200dcc:	00bfdfc4 	movi	r2,-129
  200dd0:	1884703a 	and	r2,r3,r2
  200dd4:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  _REENT_ERRNO(ptr) = ENOMEM;
  200dd8:	e0bff217 	ldw	r2,-56(fp)
  200ddc:	00c00304 	movi	r3,12
  200de0:	10c00015 	stw	r3,0(r2)
			  goto err;
  200de4:	0000ca06 	br	201110 <__sfvwrite_r+0x594>
			}
		    }
		  fp->_bf._base = str;
  200de8:	e0bff617 	ldw	r2,-40(fp)
  200dec:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
  200df0:	e0bff317 	ldw	r2,-52(fp)
  200df4:	e0fff617 	ldw	r3,-40(fp)
  200df8:	1885883a 	add	r2,r3,r2
  200dfc:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
  200e00:	e0bff517 	ldw	r2,-44(fp)
  200e04:	80800515 	stw	r2,20(r16)
		  w = len;
  200e08:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
  200e0c:	e0fff517 	ldw	r3,-44(fp)
  200e10:	e0bff317 	ldw	r2,-52(fp)
  200e14:	1885c83a 	sub	r2,r3,r2
  200e18:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
  200e1c:	8805883a 	mov	r2,r17
  200e20:	9080012e 	bgeu	r18,r2,200e28 <__sfvwrite_r+0x2ac>
		w = len;
  200e24:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
  200e28:	80800017 	ldw	r2,0(r16)
  200e2c:	8807883a 	mov	r3,r17
  200e30:	180d883a 	mov	r6,r3
  200e34:	980b883a 	mov	r5,r19
  200e38:	1009883a 	mov	r4,r2
  200e3c:	02019980 	call	201998 <memmove>
	      fp->_w -= w;
  200e40:	80800217 	ldw	r2,8(r16)
  200e44:	1445c83a 	sub	r2,r2,r17
  200e48:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
  200e4c:	80800017 	ldw	r2,0(r16)
  200e50:	8807883a 	mov	r3,r17
  200e54:	10c5883a 	add	r2,r2,r3
  200e58:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
  200e5c:	9023883a 	mov	r17,r18
  200e60:	00003706 	br	200f40 <__sfvwrite_r+0x3c4>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
  200e64:	80800017 	ldw	r2,0(r16)
  200e68:	80c00417 	ldw	r3,16(r16)
  200e6c:	18800236 	bltu	r3,r2,200e78 <__sfvwrite_r+0x2fc>
  200e70:	80800517 	ldw	r2,20(r16)
  200e74:	9080192e 	bgeu	r18,r2,200edc <__sfvwrite_r+0x360>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
  200e78:	8807883a 	mov	r3,r17
  200e7c:	9005883a 	mov	r2,r18
  200e80:	1880012e 	bgeu	r3,r2,200e88 <__sfvwrite_r+0x30c>
  200e84:	1805883a 	mov	r2,r3
  200e88:	1023883a 	mov	r17,r2
	      COPY (w);
  200e8c:	80800017 	ldw	r2,0(r16)
  200e90:	8807883a 	mov	r3,r17
  200e94:	180d883a 	mov	r6,r3
  200e98:	980b883a 	mov	r5,r19
  200e9c:	1009883a 	mov	r4,r2
  200ea0:	02019980 	call	201998 <memmove>
	      fp->_w -= w;
  200ea4:	80800217 	ldw	r2,8(r16)
  200ea8:	1445c83a 	sub	r2,r2,r17
  200eac:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
  200eb0:	80800017 	ldw	r2,0(r16)
  200eb4:	8807883a 	mov	r3,r17
  200eb8:	10c5883a 	add	r2,r2,r3
  200ebc:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
  200ec0:	80800217 	ldw	r2,8(r16)
  200ec4:	10001d1e 	bne	r2,zero,200f3c <__sfvwrite_r+0x3c0>
  200ec8:	800b883a 	mov	r5,r16
  200ecc:	e13ff217 	ldw	r4,-56(fp)
  200ed0:	02047040 	call	204704 <_fflush_r>
  200ed4:	10001926 	beq	r2,zero,200f3c <__sfvwrite_r+0x3c0>
		goto err;
  200ed8:	00008d06 	br	201110 <__sfvwrite_r+0x594>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
  200edc:	00a00034 	movhi	r2,32768
  200ee0:	10bfff84 	addi	r2,r2,-2
  200ee4:	14800236 	bltu	r2,r18,200ef0 <__sfvwrite_r+0x374>
  200ee8:	9005883a 	mov	r2,r18
  200eec:	00000206 	br	200ef8 <__sfvwrite_r+0x37c>
  200ef0:	00a00034 	movhi	r2,32768
  200ef4:	10bfffc4 	addi	r2,r2,-1
  200ef8:	80c00517 	ldw	r3,20(r16)
  200efc:	180b883a 	mov	r5,r3
  200f00:	1009883a 	mov	r4,r2
  200f04:	0204d1c0 	call	204d1c <__divsi3>
  200f08:	1007883a 	mov	r3,r2
  200f0c:	80800517 	ldw	r2,20(r16)
  200f10:	18a3383a 	mul	r17,r3,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
  200f14:	80800917 	ldw	r2,36(r16)
  200f18:	80c00717 	ldw	r3,28(r16)
  200f1c:	880f883a 	mov	r7,r17
  200f20:	980d883a 	mov	r6,r19
  200f24:	180b883a 	mov	r5,r3
  200f28:	e13ff217 	ldw	r4,-56(fp)
  200f2c:	103ee83a 	callr	r2
  200f30:	1023883a 	mov	r17,r2
	      if (w <= 0)
  200f34:	0440730e 	bge	zero,r17,201104 <__sfvwrite_r+0x588>
  200f38:	00000106 	br	200f40 <__sfvwrite_r+0x3c4>
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
  200f3c:	0001883a 	nop
		goto err;
	    }
	  p += w;
  200f40:	8805883a 	mov	r2,r17
  200f44:	98a7883a 	add	r19,r19,r2
	  len -= w;
  200f48:	8805883a 	mov	r2,r17
  200f4c:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
  200f50:	a8800217 	ldw	r2,8(r21)
  200f54:	8807883a 	mov	r3,r17
  200f58:	10c5c83a 	sub	r2,r2,r3
  200f5c:	a8800215 	stw	r2,8(r21)
  200f60:	a8800217 	ldw	r2,8(r21)
  200f64:	103f511e 	bne	r2,zero,200cac <__sfvwrite_r+0x130>
  200f68:	00006206 	br	2010f4 <__sfvwrite_r+0x578>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
  200f6c:	e03ff815 	stw	zero,-32(fp)
      nldist = 0;
  200f70:	e03ff715 	stw	zero,-36(fp)
      do
	{
	  GETIOV (nlknown = 0);
  200f74:	00000406 	br	200f88 <__sfvwrite_r+0x40c>
  200f78:	e03ff815 	stw	zero,-32(fp)
  200f7c:	a4c00017 	ldw	r19,0(r20)
  200f80:	a4800117 	ldw	r18,4(r20)
  200f84:	a5000204 	addi	r20,r20,8
  200f88:	903ffb26 	beq	r18,zero,200f78 <__sfvwrite_r+0x3fc>
	  if (!nlknown)
  200f8c:	e0bff817 	ldw	r2,-32(fp)
  200f90:	10000f1e 	bne	r2,zero,200fd0 <__sfvwrite_r+0x454>
	    {
	      nl = memchr ((void *) p, '\n', len);
  200f94:	900d883a 	mov	r6,r18
  200f98:	01400284 	movi	r5,10
  200f9c:	9809883a 	mov	r4,r19
  200fa0:	020165c0 	call	20165c <memchr>
  200fa4:	e0bff415 	stw	r2,-48(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
  200fa8:	e0bff417 	ldw	r2,-48(fp)
  200fac:	10000426 	beq	r2,zero,200fc0 <__sfvwrite_r+0x444>
  200fb0:	e0bff417 	ldw	r2,-48(fp)
  200fb4:	10800044 	addi	r2,r2,1
  200fb8:	14c5c83a 	sub	r2,r2,r19
  200fbc:	00000106 	br	200fc4 <__sfvwrite_r+0x448>
  200fc0:	90800044 	addi	r2,r18,1
  200fc4:	e0bff715 	stw	r2,-36(fp)
	      nlknown = 1;
  200fc8:	00800044 	movi	r2,1
  200fcc:	e0bff815 	stw	r2,-32(fp)
	    }
	  s = MIN (len, nldist);
  200fd0:	e0fff717 	ldw	r3,-36(fp)
  200fd4:	9005883a 	mov	r2,r18
  200fd8:	1880012e 	bgeu	r3,r2,200fe0 <__sfvwrite_r+0x464>
  200fdc:	1805883a 	mov	r2,r3
  200fe0:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
  200fe4:	80c00217 	ldw	r3,8(r16)
  200fe8:	80800517 	ldw	r2,20(r16)
  200fec:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
  200ff0:	80800017 	ldw	r2,0(r16)
  200ff4:	80c00417 	ldw	r3,16(r16)
  200ff8:	1880102e 	bgeu	r3,r2,20103c <__sfvwrite_r+0x4c0>
  200ffc:	8d800f0e 	bge	r17,r22,20103c <__sfvwrite_r+0x4c0>
	    {
	      COPY (w);
  201000:	80800017 	ldw	r2,0(r16)
  201004:	8807883a 	mov	r3,r17
  201008:	180d883a 	mov	r6,r3
  20100c:	980b883a 	mov	r5,r19
  201010:	1009883a 	mov	r4,r2
  201014:	02019980 	call	201998 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
  201018:	80800017 	ldw	r2,0(r16)
  20101c:	8807883a 	mov	r3,r17
  201020:	10c5883a 	add	r2,r2,r3
  201024:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
  201028:	800b883a 	mov	r5,r16
  20102c:	e13ff217 	ldw	r4,-56(fp)
  201030:	02047040 	call	204704 <_fflush_r>
  201034:	10001b26 	beq	r2,zero,2010a4 <__sfvwrite_r+0x528>
		goto err;
  201038:	00003506 	br	201110 <__sfvwrite_r+0x594>
	    }
	  else if (s >= (w = fp->_bf._size))
  20103c:	84400517 	ldw	r17,20(r16)
  201040:	b4400a16 	blt	r22,r17,20106c <__sfvwrite_r+0x4f0>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
  201044:	80800917 	ldw	r2,36(r16)
  201048:	80c00717 	ldw	r3,28(r16)
  20104c:	880f883a 	mov	r7,r17
  201050:	980d883a 	mov	r6,r19
  201054:	180b883a 	mov	r5,r3
  201058:	e13ff217 	ldw	r4,-56(fp)
  20105c:	103ee83a 	callr	r2
  201060:	1023883a 	mov	r17,r2
	      if (w <= 0)
  201064:	04400f16 	blt	zero,r17,2010a4 <__sfvwrite_r+0x528>
		goto err;
  201068:	00002906 	br	201110 <__sfvwrite_r+0x594>
	    }
	  else
	    {
	      w = s;
  20106c:	b023883a 	mov	r17,r22
	      COPY (w);
  201070:	80800017 	ldw	r2,0(r16)
  201074:	8807883a 	mov	r3,r17
  201078:	180d883a 	mov	r6,r3
  20107c:	980b883a 	mov	r5,r19
  201080:	1009883a 	mov	r4,r2
  201084:	02019980 	call	201998 <memmove>
	      fp->_w -= w;
  201088:	80800217 	ldw	r2,8(r16)
  20108c:	1445c83a 	sub	r2,r2,r17
  201090:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
  201094:	80800017 	ldw	r2,0(r16)
  201098:	8807883a 	mov	r3,r17
  20109c:	10c5883a 	add	r2,r2,r3
  2010a0:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
  2010a4:	e0bff717 	ldw	r2,-36(fp)
  2010a8:	1445c83a 	sub	r2,r2,r17
  2010ac:	e0bff715 	stw	r2,-36(fp)
  2010b0:	e0bff717 	ldw	r2,-36(fp)
  2010b4:	1000051e 	bne	r2,zero,2010cc <__sfvwrite_r+0x550>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
  2010b8:	800b883a 	mov	r5,r16
  2010bc:	e13ff217 	ldw	r4,-56(fp)
  2010c0:	02047040 	call	204704 <_fflush_r>
  2010c4:	1000111e 	bne	r2,zero,20110c <__sfvwrite_r+0x590>
		goto err;
	      nlknown = 0;
  2010c8:	e03ff815 	stw	zero,-32(fp)
	    }
	  p += w;
  2010cc:	8805883a 	mov	r2,r17
  2010d0:	98a7883a 	add	r19,r19,r2
	  len -= w;
  2010d4:	8805883a 	mov	r2,r17
  2010d8:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
  2010dc:	a8800217 	ldw	r2,8(r21)
  2010e0:	8807883a 	mov	r3,r17
  2010e4:	10c5c83a 	sub	r2,r2,r3
  2010e8:	a8800215 	stw	r2,8(r21)
  2010ec:	a8800217 	ldw	r2,8(r21)
  2010f0:	103fa51e 	bne	r2,zero,200f88 <__sfvwrite_r+0x40c>
    }
  return 0;
  2010f4:	0005883a 	mov	r2,zero
  2010f8:	00000906 	br	201120 <__sfvwrite_r+0x5a4>
	    goto err;
  2010fc:	0001883a 	nop
  201100:	00000306 	br	201110 <__sfvwrite_r+0x594>
		goto err;
  201104:	0001883a 	nop
  201108:	00000106 	br	201110 <__sfvwrite_r+0x594>
		goto err;
  20110c:	0001883a 	nop

err:
  fp->_flags |= __SERR;
  201110:	8080030b 	ldhu	r2,12(r16)
  201114:	10801014 	ori	r2,r2,64
  201118:	8080030d 	sth	r2,12(r16)
  return EOF;
  20111c:	00bfffc4 	movi	r2,-1
}
  201120:	e6fff904 	addi	sp,fp,-28
  201124:	dfc00817 	ldw	ra,32(sp)
  201128:	df000717 	ldw	fp,28(sp)
  20112c:	dd800617 	ldw	r22,24(sp)
  201130:	dd400517 	ldw	r21,20(sp)
  201134:	dd000417 	ldw	r20,16(sp)
  201138:	dcc00317 	ldw	r19,12(sp)
  20113c:	dc800217 	ldw	r18,8(sp)
  201140:	dc400117 	ldw	r17,4(sp)
  201144:	dc000017 	ldw	r16,0(sp)
  201148:	dec00904 	addi	sp,sp,36
  20114c:	f800283a 	ret

00201150 <_fwalk_sglue>:
#include <errno.h>

int
_fwalk_sglue (struct _reent *ptr, int (*func) (struct _reent *, FILE *),
    struct _glue *g)
{
  201150:	defff804 	addi	sp,sp,-32
  201154:	dfc00715 	stw	ra,28(sp)
  201158:	df000615 	stw	fp,24(sp)
  20115c:	df000604 	addi	fp,sp,24
  201160:	e13ffc15 	stw	r4,-16(fp)
  201164:	e17ffb15 	stw	r5,-20(fp)
  201168:	e1bffa15 	stw	r6,-24(fp)
  FILE *fp;
  int n, ret = 0;
  20116c:	e03ffd15 	stw	zero,-12(fp)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  do {
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  201170:	e0bffa17 	ldw	r2,-24(fp)
  201174:	10800217 	ldw	r2,8(r2)
  201178:	e0bfff15 	stw	r2,-4(fp)
  20117c:	e0bffa17 	ldw	r2,-24(fp)
  201180:	10800117 	ldw	r2,4(r2)
  201184:	e0bffe15 	stw	r2,-8(fp)
  201188:	00001f06 	br	201208 <_fwalk_sglue+0xb8>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
  20118c:	e0bfff17 	ldw	r2,-4(fp)
  201190:	1080030b 	ldhu	r2,12(r2)
  201194:	10bfffcc 	andi	r2,r2,65535
  201198:	10a0001c 	xori	r2,r2,32768
  20119c:	10a00004 	addi	r2,r2,-32768
  2011a0:	10001626 	beq	r2,zero,2011fc <_fwalk_sglue+0xac>
  2011a4:	e0bfff17 	ldw	r2,-4(fp)
  2011a8:	1080030b 	ldhu	r2,12(r2)
  2011ac:	10bfffcc 	andi	r2,r2,65535
  2011b0:	10a0001c 	xori	r2,r2,32768
  2011b4:	10a00004 	addi	r2,r2,-32768
  2011b8:	10800060 	cmpeqi	r2,r2,1
  2011bc:	10000f1e 	bne	r2,zero,2011fc <_fwalk_sglue+0xac>
  2011c0:	e0bfff17 	ldw	r2,-4(fp)
  2011c4:	1080038b 	ldhu	r2,14(r2)
  2011c8:	10bfffcc 	andi	r2,r2,65535
  2011cc:	10a0001c 	xori	r2,r2,32768
  2011d0:	10a00004 	addi	r2,r2,-32768
  2011d4:	10bfffe0 	cmpeqi	r2,r2,-1
  2011d8:	1000081e 	bne	r2,zero,2011fc <_fwalk_sglue+0xac>
	ret |= (*func) (ptr, fp);
  2011dc:	e0bffb17 	ldw	r2,-20(fp)
  2011e0:	e17fff17 	ldw	r5,-4(fp)
  2011e4:	e13ffc17 	ldw	r4,-16(fp)
  2011e8:	103ee83a 	callr	r2
  2011ec:	1007883a 	mov	r3,r2
  2011f0:	e0bffd17 	ldw	r2,-12(fp)
  2011f4:	10c4b03a 	or	r2,r2,r3
  2011f8:	e0bffd15 	stw	r2,-12(fp)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  2011fc:	e0bfff17 	ldw	r2,-4(fp)
  201200:	10801a04 	addi	r2,r2,104
  201204:	e0bfff15 	stw	r2,-4(fp)
  201208:	e0bffe17 	ldw	r2,-8(fp)
  20120c:	10bfffc4 	addi	r2,r2,-1
  201210:	e0bffe15 	stw	r2,-8(fp)
  201214:	e0bffe17 	ldw	r2,-8(fp)
  201218:	103fdc0e 	bge	r2,zero,20118c <_fwalk_sglue+0x3c>
    g = g->_next;
  20121c:	e0bffa17 	ldw	r2,-24(fp)
  201220:	10800017 	ldw	r2,0(r2)
  201224:	e0bffa15 	stw	r2,-24(fp)
  } while (g != NULL);
  201228:	e0bffa17 	ldw	r2,-24(fp)
  20122c:	103fd01e 	bne	r2,zero,201170 <_fwalk_sglue+0x20>

  return ret;
  201230:	e0bffd17 	ldw	r2,-12(fp)
}
  201234:	e037883a 	mov	sp,fp
  201238:	dfc00117 	ldw	ra,4(sp)
  20123c:	df000017 	ldw	fp,0(sp)
  201240:	dec00204 	addi	sp,sp,8
  201244:	f800283a 	ret

00201248 <__sread>:
_READ_WRITE_RETURN_TYPE
__sread (struct _reent *ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
  201248:	defff804 	addi	sp,sp,-32
  20124c:	dfc00715 	stw	ra,28(sp)
  201250:	df000615 	stw	fp,24(sp)
  201254:	dc400515 	stw	r17,20(sp)
  201258:	dc000415 	stw	r16,16(sp)
  20125c:	df000604 	addi	fp,sp,24
  201260:	e13ffd15 	stw	r4,-12(fp)
  201264:	e17ffc15 	stw	r5,-16(fp)
  201268:	e1bffb15 	stw	r6,-20(fp)
  20126c:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
  201270:	e43ffc17 	ldw	r16,-16(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
  201274:	8080038b 	ldhu	r2,14(r16)
  201278:	10bfffcc 	andi	r2,r2,65535
  20127c:	10a0001c 	xori	r2,r2,32768
  201280:	10a00004 	addi	r2,r2,-32768
  201284:	e0fffa17 	ldw	r3,-24(fp)
  201288:	180f883a 	mov	r7,r3
  20128c:	e1bffb17 	ldw	r6,-20(fp)
  201290:	100b883a 	mov	r5,r2
  201294:	e13ffd17 	ldw	r4,-12(fp)
  201298:	0201f500 	call	201f50 <_read_r>
  20129c:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
  2012a0:	88000416 	blt	r17,zero,2012b4 <__sread+0x6c>
    fp->_offset += ret;
  2012a4:	80801417 	ldw	r2,80(r16)
  2012a8:	8885883a 	add	r2,r17,r2
  2012ac:	80801415 	stw	r2,80(r16)
  2012b0:	00000406 	br	2012c4 <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  2012b4:	80c0030b 	ldhu	r3,12(r16)
  2012b8:	00bbffc4 	movi	r2,-4097
  2012bc:	1884703a 	and	r2,r3,r2
  2012c0:	8080030d 	sth	r2,12(r16)
  return ret;
  2012c4:	8805883a 	mov	r2,r17
}
  2012c8:	e6fffe04 	addi	sp,fp,-8
  2012cc:	dfc00317 	ldw	ra,12(sp)
  2012d0:	df000217 	ldw	fp,8(sp)
  2012d4:	dc400117 	ldw	r17,4(sp)
  2012d8:	dc000017 	ldw	r16,0(sp)
  2012dc:	dec00404 	addi	sp,sp,16
  2012e0:	f800283a 	ret

002012e4 <__seofread>:
_READ_WRITE_RETURN_TYPE
__seofread (struct _reent *_ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE len)
{
  2012e4:	defffb04 	addi	sp,sp,-20
  2012e8:	df000415 	stw	fp,16(sp)
  2012ec:	df000404 	addi	fp,sp,16
  2012f0:	e13fff15 	stw	r4,-4(fp)
  2012f4:	e17ffe15 	stw	r5,-8(fp)
  2012f8:	e1bffd15 	stw	r6,-12(fp)
  2012fc:	e1fffc15 	stw	r7,-16(fp)
  return 0;
  201300:	0005883a 	mov	r2,zero
}
  201304:	e037883a 	mov	sp,fp
  201308:	df000017 	ldw	fp,0(sp)
  20130c:	dec00104 	addi	sp,sp,4
  201310:	f800283a 	ret

00201314 <__swrite>:
_READ_WRITE_RETURN_TYPE
__swrite (struct _reent *ptr,
       void *cookie,
       char const *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
  201314:	defff804 	addi	sp,sp,-32
  201318:	dfc00715 	stw	ra,28(sp)
  20131c:	df000615 	stw	fp,24(sp)
  201320:	dc000515 	stw	r16,20(sp)
  201324:	df000604 	addi	fp,sp,24
  201328:	e13ffd15 	stw	r4,-12(fp)
  20132c:	e17ffc15 	stw	r5,-16(fp)
  201330:	e1bffb15 	stw	r6,-20(fp)
  201334:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
  201338:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
  20133c:	8080030b 	ldhu	r2,12(r16)
  201340:	10bfffcc 	andi	r2,r2,65535
  201344:	1080400c 	andi	r2,r2,256
  201348:	10000926 	beq	r2,zero,201370 <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  20134c:	8080038b 	ldhu	r2,14(r16)
  201350:	10bfffcc 	andi	r2,r2,65535
  201354:	10a0001c 	xori	r2,r2,32768
  201358:	10a00004 	addi	r2,r2,-32768
  20135c:	01c00084 	movi	r7,2
  201360:	000d883a 	mov	r6,zero
  201364:	100b883a 	mov	r5,r2
  201368:	e13ffd17 	ldw	r4,-12(fp)
  20136c:	0201ee00 	call	201ee0 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
  201370:	80c0030b 	ldhu	r3,12(r16)
  201374:	00bbffc4 	movi	r2,-4097
  201378:	1884703a 	and	r2,r3,r2
  20137c:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
  201380:	8080038b 	ldhu	r2,14(r16)
  201384:	10bfffcc 	andi	r2,r2,65535
  201388:	10a0001c 	xori	r2,r2,32768
  20138c:	10a00004 	addi	r2,r2,-32768
  201390:	e0fffa17 	ldw	r3,-24(fp)
  201394:	180f883a 	mov	r7,r3
  201398:	e1bffb17 	ldw	r6,-20(fp)
  20139c:	100b883a 	mov	r5,r2
  2013a0:	e13ffd17 	ldw	r4,-12(fp)
  2013a4:	0201fc00 	call	201fc0 <_write_r>
  2013a8:	e0bffe15 	stw	r2,-8(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
  2013ac:	e0bffe17 	ldw	r2,-8(fp)
}
  2013b0:	e6ffff04 	addi	sp,fp,-4
  2013b4:	dfc00217 	ldw	ra,8(sp)
  2013b8:	df000117 	ldw	fp,4(sp)
  2013bc:	dc000017 	ldw	r16,0(sp)
  2013c0:	dec00304 	addi	sp,sp,12
  2013c4:	f800283a 	ret

002013c8 <__sseek>:
_fpos_t
__sseek (struct _reent *ptr,
       void *cookie,
       _fpos_t offset,
       int whence)
{
  2013c8:	defff804 	addi	sp,sp,-32
  2013cc:	dfc00715 	stw	ra,28(sp)
  2013d0:	df000615 	stw	fp,24(sp)
  2013d4:	dc400515 	stw	r17,20(sp)
  2013d8:	dc000415 	stw	r16,16(sp)
  2013dc:	df000604 	addi	fp,sp,24
  2013e0:	e13ffd15 	stw	r4,-12(fp)
  2013e4:	e17ffc15 	stw	r5,-16(fp)
  2013e8:	e1bffb15 	stw	r6,-20(fp)
  2013ec:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
  2013f0:	e43ffc17 	ldw	r16,-16(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  2013f4:	8080038b 	ldhu	r2,14(r16)
  2013f8:	10bfffcc 	andi	r2,r2,65535
  2013fc:	10a0001c 	xori	r2,r2,32768
  201400:	10a00004 	addi	r2,r2,-32768
  201404:	e1fffa17 	ldw	r7,-24(fp)
  201408:	e1bffb17 	ldw	r6,-20(fp)
  20140c:	100b883a 	mov	r5,r2
  201410:	e13ffd17 	ldw	r4,-12(fp)
  201414:	0201ee00 	call	201ee0 <_lseek_r>
  201418:	1023883a 	mov	r17,r2
  if (ret == -1L)
  20141c:	88bfffd8 	cmpnei	r2,r17,-1
  201420:	1000051e 	bne	r2,zero,201438 <__sseek+0x70>
    fp->_flags &= ~__SOFF;
  201424:	80c0030b 	ldhu	r3,12(r16)
  201428:	00bbffc4 	movi	r2,-4097
  20142c:	1884703a 	and	r2,r3,r2
  201430:	8080030d 	sth	r2,12(r16)
  201434:	00000406 	br	201448 <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
  201438:	8080030b 	ldhu	r2,12(r16)
  20143c:	10840014 	ori	r2,r2,4096
  201440:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
  201444:	84401415 	stw	r17,80(r16)
    }
  return ret;
  201448:	8805883a 	mov	r2,r17
}
  20144c:	e6fffe04 	addi	sp,fp,-8
  201450:	dfc00317 	ldw	ra,12(sp)
  201454:	df000217 	ldw	fp,8(sp)
  201458:	dc400117 	ldw	r17,4(sp)
  20145c:	dc000017 	ldw	r16,0(sp)
  201460:	dec00404 	addi	sp,sp,16
  201464:	f800283a 	ret

00201468 <__sclose>:

int
__sclose (struct _reent *ptr,
       void *cookie)
{
  201468:	defffb04 	addi	sp,sp,-20
  20146c:	dfc00415 	stw	ra,16(sp)
  201470:	df000315 	stw	fp,12(sp)
  201474:	df000304 	addi	fp,sp,12
  201478:	e13ffe15 	stw	r4,-8(fp)
  20147c:	e17ffd15 	stw	r5,-12(fp)
  FILE *fp = (FILE *) cookie;
  201480:	e0bffd17 	ldw	r2,-12(fp)
  201484:	e0bfff15 	stw	r2,-4(fp)

  return _close_r (ptr, fp->_file);
  201488:	e0bfff17 	ldw	r2,-4(fp)
  20148c:	1080038b 	ldhu	r2,14(r2)
  201490:	10bfffcc 	andi	r2,r2,65535
  201494:	10a0001c 	xori	r2,r2,32768
  201498:	10a00004 	addi	r2,r2,-32768
  20149c:	100b883a 	mov	r5,r2
  2014a0:	e13ffe17 	ldw	r4,-8(fp)
  2014a4:	0201d640 	call	201d64 <_close_r>
}
  2014a8:	e037883a 	mov	sp,fp
  2014ac:	dfc00117 	ldw	ra,4(sp)
  2014b0:	df000017 	ldw	fp,0(sp)
  2014b4:	dec00204 	addi	sp,sp,8
  2014b8:	f800283a 	ret

002014bc <__swsetup_r>:
 */

int
__swsetup_r (struct _reent *ptr,
       register FILE * fp)
{
  2014bc:	defffb04 	addi	sp,sp,-20
  2014c0:	dfc00415 	stw	ra,16(sp)
  2014c4:	df000315 	stw	fp,12(sp)
  2014c8:	dc000215 	stw	r16,8(sp)
  2014cc:	df000304 	addi	fp,sp,12
  2014d0:	e13ffd15 	stw	r4,-12(fp)
  2014d4:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
  2014d8:	d0a00017 	ldw	r2,-32768(gp)
  2014dc:	e0bffe15 	stw	r2,-8(fp)
  2014e0:	e0bffe17 	ldw	r2,-8(fp)
  2014e4:	10000526 	beq	r2,zero,2014fc <__swsetup_r+0x40>
  2014e8:	e0bffe17 	ldw	r2,-8(fp)
  2014ec:	10800d17 	ldw	r2,52(r2)
  2014f0:	1000021e 	bne	r2,zero,2014fc <__swsetup_r+0x40>
  2014f4:	e13ffe17 	ldw	r4,-8(fp)
  2014f8:	0200a0c0 	call	200a0c <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
  2014fc:	8080030b 	ldhu	r2,12(r16)
  201500:	10bfffcc 	andi	r2,r2,65535
  201504:	1080020c 	andi	r2,r2,8
  201508:	1000241e 	bne	r2,zero,20159c <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
  20150c:	8080030b 	ldhu	r2,12(r16)
  201510:	10bfffcc 	andi	r2,r2,65535
  201514:	1080040c 	andi	r2,r2,16
  201518:	1000081e 	bne	r2,zero,20153c <__swsetup_r+0x80>
        {
	  _REENT_ERRNO(ptr) = EBADF;
  20151c:	e0bffd17 	ldw	r2,-12(fp)
  201520:	00c00244 	movi	r3,9
  201524:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
  201528:	8080030b 	ldhu	r2,12(r16)
  20152c:	10801014 	ori	r2,r2,64
  201530:	8080030d 	sth	r2,12(r16)
	  return EOF;
  201534:	00bfffc4 	movi	r2,-1
  201538:	00004206 	br	201644 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
  20153c:	8080030b 	ldhu	r2,12(r16)
  201540:	10bfffcc 	andi	r2,r2,65535
  201544:	1080010c 	andi	r2,r2,4
  201548:	10001126 	beq	r2,zero,201590 <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
  20154c:	80800c17 	ldw	r2,48(r16)
  201550:	10000826 	beq	r2,zero,201574 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
  201554:	80c00c17 	ldw	r3,48(r16)
  201558:	80801004 	addi	r2,r16,64
  20155c:	18800426 	beq	r3,r2,201570 <__swsetup_r+0xb4>
  201560:	80800c17 	ldw	r2,48(r16)
  201564:	100b883a 	mov	r5,r2
  201568:	e13ffd17 	ldw	r4,-12(fp)
  20156c:	02020680 	call	202068 <_free_r>
  201570:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
  201574:	80c0030b 	ldhu	r3,12(r16)
  201578:	00bff6c4 	movi	r2,-37
  20157c:	1884703a 	and	r2,r3,r2
  201580:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
  201584:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
  201588:	80800417 	ldw	r2,16(r16)
  20158c:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
  201590:	8080030b 	ldhu	r2,12(r16)
  201594:	10800214 	ori	r2,r2,8
  201598:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
  20159c:	80800417 	ldw	r2,16(r16)
  2015a0:	10000b1e 	bne	r2,zero,2015d0 <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
  2015a4:	8080030b 	ldhu	r2,12(r16)
  2015a8:	10bfffcc 	andi	r2,r2,65535
  2015ac:	1080800c 	andi	r2,r2,512
  2015b0:	10000426 	beq	r2,zero,2015c4 <__swsetup_r+0x108>
  2015b4:	8080030b 	ldhu	r2,12(r16)
  2015b8:	10bfffcc 	andi	r2,r2,65535
  2015bc:	1080200c 	andi	r2,r2,128
  2015c0:	10000326 	beq	r2,zero,2015d0 <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
  2015c4:	800b883a 	mov	r5,r16
  2015c8:	e13ffd17 	ldw	r4,-12(fp)
  2015cc:	02047e80 	call	2047e8 <__smakebuf_r>

  if (fp->_flags & __SLBF)
  2015d0:	8080030b 	ldhu	r2,12(r16)
  2015d4:	10bfffcc 	andi	r2,r2,65535
  2015d8:	1080004c 	andi	r2,r2,1
  2015dc:	10000526 	beq	r2,zero,2015f4 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
  2015e0:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
  2015e4:	80800517 	ldw	r2,20(r16)
  2015e8:	0085c83a 	sub	r2,zero,r2
  2015ec:	80800615 	stw	r2,24(r16)
  2015f0:	00000806 	br	201614 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
  2015f4:	8080030b 	ldhu	r2,12(r16)
  2015f8:	10bfffcc 	andi	r2,r2,65535
  2015fc:	1080008c 	andi	r2,r2,2
  201600:	1000021e 	bne	r2,zero,20160c <__swsetup_r+0x150>
  201604:	80800517 	ldw	r2,20(r16)
  201608:	00000106 	br	201610 <__swsetup_r+0x154>
  20160c:	0005883a 	mov	r2,zero
  201610:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
  201614:	80800417 	ldw	r2,16(r16)
  201618:	1000091e 	bne	r2,zero,201640 <__swsetup_r+0x184>
  20161c:	8080030b 	ldhu	r2,12(r16)
  201620:	10bfffcc 	andi	r2,r2,65535
  201624:	1080200c 	andi	r2,r2,128
  201628:	10000526 	beq	r2,zero,201640 <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
  20162c:	8080030b 	ldhu	r2,12(r16)
  201630:	10801014 	ori	r2,r2,64
  201634:	8080030d 	sth	r2,12(r16)
      return EOF;
  201638:	00bfffc4 	movi	r2,-1
  20163c:	00000106 	br	201644 <__swsetup_r+0x188>
    }
  return 0;
  201640:	0005883a 	mov	r2,zero
}
  201644:	e6ffff04 	addi	sp,fp,-4
  201648:	dfc00217 	ldw	ra,8(sp)
  20164c:	df000117 	ldw	fp,4(sp)
  201650:	dc000017 	ldw	r16,0(sp)
  201654:	dec00304 	addi	sp,sp,12
  201658:	f800283a 	ret

0020165c <memchr>:

void *
memchr (const void *src_void,
	int c,
	size_t length)
{
  20165c:	defff704 	addi	sp,sp,-36
  201660:	df000815 	stw	fp,32(sp)
  201664:	df000804 	addi	fp,sp,32
  201668:	e13ffa15 	stw	r4,-24(fp)
  20166c:	e17ff915 	stw	r5,-28(fp)
  201670:	e1bff815 	stw	r6,-32(fp)
  const unsigned char *src = (const unsigned char *) src_void;
  201674:	e0bffa17 	ldw	r2,-24(fp)
  201678:	e0bfff15 	stw	r2,-4(fp)
  unsigned char d = c;
  20167c:	e0bff917 	ldw	r2,-28(fp)
  201680:	e0bffbc5 	stb	r2,-17(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
  201684:	00001006 	br	2016c8 <memchr+0x6c>
    {
      if (!length--)
  201688:	e0bff817 	ldw	r2,-32(fp)
  20168c:	10ffffc4 	addi	r3,r2,-1
  201690:	e0fff815 	stw	r3,-32(fp)
  201694:	1000021e 	bne	r2,zero,2016a0 <memchr+0x44>
        return NULL;
  201698:	0005883a 	mov	r2,zero
  20169c:	00005806 	br	201800 <memchr+0x1a4>
      if (*src == d)
  2016a0:	e0bfff17 	ldw	r2,-4(fp)
  2016a4:	10800003 	ldbu	r2,0(r2)
  2016a8:	e0fffbc3 	ldbu	r3,-17(fp)
  2016ac:	10803fcc 	andi	r2,r2,255
  2016b0:	1880021e 	bne	r3,r2,2016bc <memchr+0x60>
        return (void *) src;
  2016b4:	e0bfff17 	ldw	r2,-4(fp)
  2016b8:	00005106 	br	201800 <memchr+0x1a4>
      src++;
  2016bc:	e0bfff17 	ldw	r2,-4(fp)
  2016c0:	10800044 	addi	r2,r2,1
  2016c4:	e0bfff15 	stw	r2,-4(fp)
  while (UNALIGNED (src))
  2016c8:	e0bfff17 	ldw	r2,-4(fp)
  2016cc:	108000cc 	andi	r2,r2,3
  2016d0:	103fed1e 	bne	r2,zero,201688 <memchr+0x2c>
    }

  if (!TOO_SMALL (length))
  2016d4:	e0bff817 	ldw	r2,-32(fp)
  2016d8:	10800130 	cmpltui	r2,r2,4
  2016dc:	1000431e 	bne	r2,zero,2017ec <memchr+0x190>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
  2016e0:	e0bfff17 	ldw	r2,-4(fp)
  2016e4:	e0bffe15 	stw	r2,-8(fp)
      mask = d << 8 | d;
  2016e8:	e0bffbc3 	ldbu	r2,-17(fp)
  2016ec:	10804064 	muli	r2,r2,257
  2016f0:	e0bffd15 	stw	r2,-12(fp)
      mask = mask << 16 | mask;
  2016f4:	e0bffd17 	ldw	r2,-12(fp)
  2016f8:	1004943a 	slli	r2,r2,16
  2016fc:	e0fffd17 	ldw	r3,-12(fp)
  201700:	1884b03a 	or	r2,r3,r2
  201704:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
  201708:	00800804 	movi	r2,32
  20170c:	e0bffc15 	stw	r2,-16(fp)
  201710:	00000906 	br	201738 <memchr+0xdc>
        mask = (mask << i) | mask;
  201714:	e0fffd17 	ldw	r3,-12(fp)
  201718:	e0bffc17 	ldw	r2,-16(fp)
  20171c:	1884983a 	sll	r2,r3,r2
  201720:	e0fffd17 	ldw	r3,-12(fp)
  201724:	1884b03a 	or	r2,r3,r2
  201728:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
  20172c:	e0bffc17 	ldw	r2,-16(fp)
  201730:	1085883a 	add	r2,r2,r2
  201734:	e0bffc15 	stw	r2,-16(fp)
  201738:	e0bffc17 	ldw	r2,-16(fp)
  20173c:	10800830 	cmpltui	r2,r2,32
  201740:	103ff41e 	bne	r2,zero,201714 <memchr+0xb8>

      while (length >= LBLOCKSIZE)
  201744:	00001706 	br	2017a4 <memchr+0x148>
        {
          if (DETECTCHAR (*asrc, mask))
  201748:	e0bffe17 	ldw	r2,-8(fp)
  20174c:	10c00017 	ldw	r3,0(r2)
  201750:	e0bffd17 	ldw	r2,-12(fp)
  201754:	1886f03a 	xor	r3,r3,r2
  201758:	00bfbff4 	movhi	r2,65279
  20175c:	10bfbfc4 	addi	r2,r2,-257
  201760:	1887883a 	add	r3,r3,r2
  201764:	e0bffe17 	ldw	r2,-8(fp)
  201768:	11000017 	ldw	r4,0(r2)
  20176c:	e0bffd17 	ldw	r2,-12(fp)
  201770:	2084f03a 	xor	r2,r4,r2
  201774:	0084303a 	nor	r2,zero,r2
  201778:	1886703a 	and	r3,r3,r2
  20177c:	00a02074 	movhi	r2,32897
  201780:	10a02004 	addi	r2,r2,-32640
  201784:	1884703a 	and	r2,r3,r2
  201788:	10000a1e 	bne	r2,zero,2017b4 <memchr+0x158>
            break;
          length -= LBLOCKSIZE;
  20178c:	e0bff817 	ldw	r2,-32(fp)
  201790:	10bfff04 	addi	r2,r2,-4
  201794:	e0bff815 	stw	r2,-32(fp)
          asrc++;
  201798:	e0bffe17 	ldw	r2,-8(fp)
  20179c:	10800104 	addi	r2,r2,4
  2017a0:	e0bffe15 	stw	r2,-8(fp)
      while (length >= LBLOCKSIZE)
  2017a4:	e0bff817 	ldw	r2,-32(fp)
  2017a8:	10800128 	cmpgeui	r2,r2,4
  2017ac:	103fe61e 	bne	r2,zero,201748 <memchr+0xec>
  2017b0:	00000106 	br	2017b8 <memchr+0x15c>
            break;
  2017b4:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
  2017b8:	e0bffe17 	ldw	r2,-8(fp)
  2017bc:	e0bfff15 	stw	r2,-4(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
  2017c0:	00000a06 	br	2017ec <memchr+0x190>
    {
      if (*src == d)
  2017c4:	e0bfff17 	ldw	r2,-4(fp)
  2017c8:	10800003 	ldbu	r2,0(r2)
  2017cc:	e0fffbc3 	ldbu	r3,-17(fp)
  2017d0:	10803fcc 	andi	r2,r2,255
  2017d4:	1880021e 	bne	r3,r2,2017e0 <memchr+0x184>
        return (void *) src;
  2017d8:	e0bfff17 	ldw	r2,-4(fp)
  2017dc:	00000806 	br	201800 <memchr+0x1a4>
      src++;
  2017e0:	e0bfff17 	ldw	r2,-4(fp)
  2017e4:	10800044 	addi	r2,r2,1
  2017e8:	e0bfff15 	stw	r2,-4(fp)
  while (length--)
  2017ec:	e0bff817 	ldw	r2,-32(fp)
  2017f0:	10ffffc4 	addi	r3,r2,-1
  2017f4:	e0fff815 	stw	r3,-32(fp)
  2017f8:	103ff21e 	bne	r2,zero,2017c4 <memchr+0x168>
    }

  return NULL;
  2017fc:	0005883a 	mov	r2,zero
}
  201800:	e037883a 	mov	sp,fp
  201804:	df000017 	ldw	fp,0(sp)
  201808:	dec00104 	addi	sp,sp,4
  20180c:	f800283a 	ret

00201810 <memcpy>:
void *
__inhibit_loop_to_libcall
memcpy (void *__restrict dst0,
	const void *__restrict src0,
	size_t len0)
{
  201810:	defff804 	addi	sp,sp,-32
  201814:	df000715 	stw	fp,28(sp)
  201818:	df000704 	addi	fp,sp,28
  20181c:	e13ffb15 	stw	r4,-20(fp)
  201820:	e17ffa15 	stw	r5,-24(fp)
  201824:	e1bff915 	stw	r6,-28(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
  201828:	e0bffb17 	ldw	r2,-20(fp)
  20182c:	e0bfff15 	stw	r2,-4(fp)
  const char *src = src0;
  201830:	e0bffa17 	ldw	r2,-24(fp)
  201834:	e0bffe15 	stw	r2,-8(fp)
  long *aligned_dst;
  const long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
  201838:	e0bff917 	ldw	r2,-28(fp)
  20183c:	10800430 	cmpltui	r2,r2,16
  201840:	10004c1e 	bne	r2,zero,201974 <memcpy+0x164>
  201844:	e0fffe17 	ldw	r3,-8(fp)
  201848:	e0bfff17 	ldw	r2,-4(fp)
  20184c:	1884b03a 	or	r2,r3,r2
  201850:	108000cc 	andi	r2,r2,3
  201854:	1000471e 	bne	r2,zero,201974 <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
  201858:	e0bfff17 	ldw	r2,-4(fp)
  20185c:	e0bffd15 	stw	r2,-12(fp)
      aligned_src = (long*)src;
  201860:	e0bffe17 	ldw	r2,-8(fp)
  201864:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
  201868:	00002306 	br	2018f8 <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
  20186c:	e0fffc17 	ldw	r3,-16(fp)
  201870:	18800104 	addi	r2,r3,4
  201874:	e0bffc15 	stw	r2,-16(fp)
  201878:	e0bffd17 	ldw	r2,-12(fp)
  20187c:	11000104 	addi	r4,r2,4
  201880:	e13ffd15 	stw	r4,-12(fp)
  201884:	18c00017 	ldw	r3,0(r3)
  201888:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
  20188c:	e0fffc17 	ldw	r3,-16(fp)
  201890:	18800104 	addi	r2,r3,4
  201894:	e0bffc15 	stw	r2,-16(fp)
  201898:	e0bffd17 	ldw	r2,-12(fp)
  20189c:	11000104 	addi	r4,r2,4
  2018a0:	e13ffd15 	stw	r4,-12(fp)
  2018a4:	18c00017 	ldw	r3,0(r3)
  2018a8:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
  2018ac:	e0fffc17 	ldw	r3,-16(fp)
  2018b0:	18800104 	addi	r2,r3,4
  2018b4:	e0bffc15 	stw	r2,-16(fp)
  2018b8:	e0bffd17 	ldw	r2,-12(fp)
  2018bc:	11000104 	addi	r4,r2,4
  2018c0:	e13ffd15 	stw	r4,-12(fp)
  2018c4:	18c00017 	ldw	r3,0(r3)
  2018c8:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
  2018cc:	e0fffc17 	ldw	r3,-16(fp)
  2018d0:	18800104 	addi	r2,r3,4
  2018d4:	e0bffc15 	stw	r2,-16(fp)
  2018d8:	e0bffd17 	ldw	r2,-12(fp)
  2018dc:	11000104 	addi	r4,r2,4
  2018e0:	e13ffd15 	stw	r4,-12(fp)
  2018e4:	18c00017 	ldw	r3,0(r3)
  2018e8:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
  2018ec:	e0bff917 	ldw	r2,-28(fp)
  2018f0:	10bffc04 	addi	r2,r2,-16
  2018f4:	e0bff915 	stw	r2,-28(fp)
      while (len0 >= BIGBLOCKSIZE)
  2018f8:	e0bff917 	ldw	r2,-28(fp)
  2018fc:	10800428 	cmpgeui	r2,r2,16
  201900:	103fda1e 	bne	r2,zero,20186c <memcpy+0x5c>
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
  201904:	00000b06 	br	201934 <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
  201908:	e0fffc17 	ldw	r3,-16(fp)
  20190c:	18800104 	addi	r2,r3,4
  201910:	e0bffc15 	stw	r2,-16(fp)
  201914:	e0bffd17 	ldw	r2,-12(fp)
  201918:	11000104 	addi	r4,r2,4
  20191c:	e13ffd15 	stw	r4,-12(fp)
  201920:	18c00017 	ldw	r3,0(r3)
  201924:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
  201928:	e0bff917 	ldw	r2,-28(fp)
  20192c:	10bfff04 	addi	r2,r2,-4
  201930:	e0bff915 	stw	r2,-28(fp)
      while (len0 >= LITTLEBLOCKSIZE)
  201934:	e0bff917 	ldw	r2,-28(fp)
  201938:	10800128 	cmpgeui	r2,r2,4
  20193c:	103ff21e 	bne	r2,zero,201908 <memcpy+0xf8>
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
  201940:	e0bffd17 	ldw	r2,-12(fp)
  201944:	e0bfff15 	stw	r2,-4(fp)
      src = (char*)aligned_src;
  201948:	e0bffc17 	ldw	r2,-16(fp)
  20194c:	e0bffe15 	stw	r2,-8(fp)
    }

  while (len0--)
  201950:	00000806 	br	201974 <memcpy+0x164>
    *dst++ = *src++;
  201954:	e0fffe17 	ldw	r3,-8(fp)
  201958:	18800044 	addi	r2,r3,1
  20195c:	e0bffe15 	stw	r2,-8(fp)
  201960:	e0bfff17 	ldw	r2,-4(fp)
  201964:	11000044 	addi	r4,r2,1
  201968:	e13fff15 	stw	r4,-4(fp)
  20196c:	18c00003 	ldbu	r3,0(r3)
  201970:	10c00005 	stb	r3,0(r2)
  while (len0--)
  201974:	e0bff917 	ldw	r2,-28(fp)
  201978:	10ffffc4 	addi	r3,r2,-1
  20197c:	e0fff915 	stw	r3,-28(fp)
  201980:	103ff41e 	bne	r2,zero,201954 <memcpy+0x144>

  return dst0;
  201984:	e0bffb17 	ldw	r2,-20(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
  201988:	e037883a 	mov	sp,fp
  20198c:	df000017 	ldw	fp,0(sp)
  201990:	dec00104 	addi	sp,sp,4
  201994:	f800283a 	ret

00201998 <memmove>:
void *
__inhibit_loop_to_libcall
memmove (void *dst_void,
	const void *src_void,
	size_t length)
{
  201998:	defff804 	addi	sp,sp,-32
  20199c:	df000715 	stw	fp,28(sp)
  2019a0:	df000704 	addi	fp,sp,28
  2019a4:	e13ffb15 	stw	r4,-20(fp)
  2019a8:	e17ffa15 	stw	r5,-24(fp)
  2019ac:	e1bff915 	stw	r6,-28(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
  2019b0:	e0bffb17 	ldw	r2,-20(fp)
  2019b4:	e0bfff15 	stw	r2,-4(fp)
  const char *src = src_void;
  2019b8:	e0bffa17 	ldw	r2,-24(fp)
  2019bc:	e0bffe15 	stw	r2,-8(fp)
  long *aligned_dst;
  const long *aligned_src;

  if (src < dst && dst < src + length)
  2019c0:	e0fffe17 	ldw	r3,-8(fp)
  2019c4:	e0bfff17 	ldw	r2,-4(fp)
  2019c8:	18801d2e 	bgeu	r3,r2,201a40 <memmove+0xa8>
  2019cc:	e0fffe17 	ldw	r3,-8(fp)
  2019d0:	e0bff917 	ldw	r2,-28(fp)
  2019d4:	1885883a 	add	r2,r3,r2
  2019d8:	e0ffff17 	ldw	r3,-4(fp)
  2019dc:	1880182e 	bgeu	r3,r2,201a40 <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
  2019e0:	e0fffe17 	ldw	r3,-8(fp)
  2019e4:	e0bff917 	ldw	r2,-28(fp)
  2019e8:	1885883a 	add	r2,r3,r2
  2019ec:	e0bffe15 	stw	r2,-8(fp)
      dst += length;
  2019f0:	e0ffff17 	ldw	r3,-4(fp)
  2019f4:	e0bff917 	ldw	r2,-28(fp)
  2019f8:	1885883a 	add	r2,r3,r2
  2019fc:	e0bfff15 	stw	r2,-4(fp)
      while (length--)
  201a00:	00000a06 	br	201a2c <memmove+0x94>
	{
	  *--dst = *--src;
  201a04:	e0bffe17 	ldw	r2,-8(fp)
  201a08:	10bfffc4 	addi	r2,r2,-1
  201a0c:	e0bffe15 	stw	r2,-8(fp)
  201a10:	e0bfff17 	ldw	r2,-4(fp)
  201a14:	10bfffc4 	addi	r2,r2,-1
  201a18:	e0bfff15 	stw	r2,-4(fp)
  201a1c:	e0bffe17 	ldw	r2,-8(fp)
  201a20:	10c00003 	ldbu	r3,0(r2)
  201a24:	e0bfff17 	ldw	r2,-4(fp)
  201a28:	10c00005 	stb	r3,0(r2)
      while (length--)
  201a2c:	e0bff917 	ldw	r2,-28(fp)
  201a30:	10ffffc4 	addi	r3,r2,-1
  201a34:	e0fff915 	stw	r3,-28(fp)
  201a38:	103ff21e 	bne	r2,zero,201a04 <memmove+0x6c>
  if (src < dst && dst < src + length)
  201a3c:	00005306 	br	201b8c <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
  201a40:	e0bff917 	ldw	r2,-28(fp)
  201a44:	10800430 	cmpltui	r2,r2,16
  201a48:	10004c1e 	bne	r2,zero,201b7c <memmove+0x1e4>
  201a4c:	e0fffe17 	ldw	r3,-8(fp)
  201a50:	e0bfff17 	ldw	r2,-4(fp)
  201a54:	1884b03a 	or	r2,r3,r2
  201a58:	108000cc 	andi	r2,r2,3
  201a5c:	1000471e 	bne	r2,zero,201b7c <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
  201a60:	e0bfff17 	ldw	r2,-4(fp)
  201a64:	e0bffd15 	stw	r2,-12(fp)
          aligned_src = (long*)src;
  201a68:	e0bffe17 	ldw	r2,-8(fp)
  201a6c:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
  201a70:	00002306 	br	201b00 <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
  201a74:	e0fffc17 	ldw	r3,-16(fp)
  201a78:	18800104 	addi	r2,r3,4
  201a7c:	e0bffc15 	stw	r2,-16(fp)
  201a80:	e0bffd17 	ldw	r2,-12(fp)
  201a84:	11000104 	addi	r4,r2,4
  201a88:	e13ffd15 	stw	r4,-12(fp)
  201a8c:	18c00017 	ldw	r3,0(r3)
  201a90:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
  201a94:	e0fffc17 	ldw	r3,-16(fp)
  201a98:	18800104 	addi	r2,r3,4
  201a9c:	e0bffc15 	stw	r2,-16(fp)
  201aa0:	e0bffd17 	ldw	r2,-12(fp)
  201aa4:	11000104 	addi	r4,r2,4
  201aa8:	e13ffd15 	stw	r4,-12(fp)
  201aac:	18c00017 	ldw	r3,0(r3)
  201ab0:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
  201ab4:	e0fffc17 	ldw	r3,-16(fp)
  201ab8:	18800104 	addi	r2,r3,4
  201abc:	e0bffc15 	stw	r2,-16(fp)
  201ac0:	e0bffd17 	ldw	r2,-12(fp)
  201ac4:	11000104 	addi	r4,r2,4
  201ac8:	e13ffd15 	stw	r4,-12(fp)
  201acc:	18c00017 	ldw	r3,0(r3)
  201ad0:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
  201ad4:	e0fffc17 	ldw	r3,-16(fp)
  201ad8:	18800104 	addi	r2,r3,4
  201adc:	e0bffc15 	stw	r2,-16(fp)
  201ae0:	e0bffd17 	ldw	r2,-12(fp)
  201ae4:	11000104 	addi	r4,r2,4
  201ae8:	e13ffd15 	stw	r4,-12(fp)
  201aec:	18c00017 	ldw	r3,0(r3)
  201af0:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
  201af4:	e0bff917 	ldw	r2,-28(fp)
  201af8:	10bffc04 	addi	r2,r2,-16
  201afc:	e0bff915 	stw	r2,-28(fp)
          while (length >= BIGBLOCKSIZE)
  201b00:	e0bff917 	ldw	r2,-28(fp)
  201b04:	10800428 	cmpgeui	r2,r2,16
  201b08:	103fda1e 	bne	r2,zero,201a74 <memmove+0xdc>
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
  201b0c:	00000b06 	br	201b3c <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
  201b10:	e0fffc17 	ldw	r3,-16(fp)
  201b14:	18800104 	addi	r2,r3,4
  201b18:	e0bffc15 	stw	r2,-16(fp)
  201b1c:	e0bffd17 	ldw	r2,-12(fp)
  201b20:	11000104 	addi	r4,r2,4
  201b24:	e13ffd15 	stw	r4,-12(fp)
  201b28:	18c00017 	ldw	r3,0(r3)
  201b2c:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
  201b30:	e0bff917 	ldw	r2,-28(fp)
  201b34:	10bfff04 	addi	r2,r2,-4
  201b38:	e0bff915 	stw	r2,-28(fp)
          while (length >= LITTLEBLOCKSIZE)
  201b3c:	e0bff917 	ldw	r2,-28(fp)
  201b40:	10800128 	cmpgeui	r2,r2,4
  201b44:	103ff21e 	bne	r2,zero,201b10 <memmove+0x178>
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
  201b48:	e0bffd17 	ldw	r2,-12(fp)
  201b4c:	e0bfff15 	stw	r2,-4(fp)
          src = (char*)aligned_src;
  201b50:	e0bffc17 	ldw	r2,-16(fp)
  201b54:	e0bffe15 	stw	r2,-8(fp)
        }

      while (length--)
  201b58:	00000806 	br	201b7c <memmove+0x1e4>
        {
          *dst++ = *src++;
  201b5c:	e0fffe17 	ldw	r3,-8(fp)
  201b60:	18800044 	addi	r2,r3,1
  201b64:	e0bffe15 	stw	r2,-8(fp)
  201b68:	e0bfff17 	ldw	r2,-4(fp)
  201b6c:	11000044 	addi	r4,r2,1
  201b70:	e13fff15 	stw	r4,-4(fp)
  201b74:	18c00003 	ldbu	r3,0(r3)
  201b78:	10c00005 	stb	r3,0(r2)
      while (length--)
  201b7c:	e0bff917 	ldw	r2,-28(fp)
  201b80:	10ffffc4 	addi	r3,r2,-1
  201b84:	e0fff915 	stw	r3,-28(fp)
  201b88:	103ff41e 	bne	r2,zero,201b5c <memmove+0x1c4>
        }
    }

  return dst_void;
  201b8c:	e0bffb17 	ldw	r2,-20(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
  201b90:	e037883a 	mov	sp,fp
  201b94:	df000017 	ldw	fp,0(sp)
  201b98:	dec00104 	addi	sp,sp,4
  201b9c:	f800283a 	ret

00201ba0 <memset>:
void *
__inhibit_loop_to_libcall
memset (void *m,
	int c,
	size_t n)
{
  201ba0:	defff704 	addi	sp,sp,-36
  201ba4:	df000815 	stw	fp,32(sp)
  201ba8:	df000804 	addi	fp,sp,32
  201bac:	e13ffa15 	stw	r4,-24(fp)
  201bb0:	e17ff915 	stw	r5,-28(fp)
  201bb4:	e1bff815 	stw	r6,-32(fp)
  char *s = (char *) m;
  201bb8:	e0bffa17 	ldw	r2,-24(fp)
  201bbc:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
  201bc0:	e0bff917 	ldw	r2,-28(fp)
  201bc4:	10803fcc 	andi	r2,r2,255
  201bc8:	e0bffb15 	stw	r2,-20(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
  201bcc:	00000c06 	br	201c00 <memset+0x60>
    {
      if (n--)
  201bd0:	e0bff817 	ldw	r2,-32(fp)
  201bd4:	10ffffc4 	addi	r3,r2,-1
  201bd8:	e0fff815 	stw	r3,-32(fp)
  201bdc:	10000626 	beq	r2,zero,201bf8 <memset+0x58>
        *s++ = (char) c;
  201be0:	e0bfff17 	ldw	r2,-4(fp)
  201be4:	10c00044 	addi	r3,r2,1
  201be8:	e0ffff15 	stw	r3,-4(fp)
  201bec:	e0fff917 	ldw	r3,-28(fp)
  201bf0:	10c00005 	stb	r3,0(r2)
  201bf4:	00000206 	br	201c00 <memset+0x60>
      else
        return m;
  201bf8:	e0bffa17 	ldw	r2,-24(fp)
  201bfc:	00005506 	br	201d54 <memset+0x1b4>
  while (UNALIGNED (s))
  201c00:	e0bfff17 	ldw	r2,-4(fp)
  201c04:	108000cc 	andi	r2,r2,3
  201c08:	103ff11e 	bne	r2,zero,201bd0 <memset+0x30>
    }

  if (!TOO_SMALL (n))
  201c0c:	e0bff817 	ldw	r2,-32(fp)
  201c10:	10800130 	cmpltui	r2,r2,4
  201c14:	10004a1e 	bne	r2,zero,201d40 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
  201c18:	e0bfff17 	ldw	r2,-4(fp)
  201c1c:	e0bffc15 	stw	r2,-16(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
  201c20:	e0bffb17 	ldw	r2,-20(fp)
  201c24:	1004923a 	slli	r2,r2,8
  201c28:	e0fffb17 	ldw	r3,-20(fp)
  201c2c:	1884b03a 	or	r2,r3,r2
  201c30:	e0bffd15 	stw	r2,-12(fp)
      buffer |= (buffer << 16);
  201c34:	e0bffd17 	ldw	r2,-12(fp)
  201c38:	1004943a 	slli	r2,r2,16
  201c3c:	e0fffd17 	ldw	r3,-12(fp)
  201c40:	1884b03a 	or	r2,r3,r2
  201c44:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
  201c48:	00800804 	movi	r2,32
  201c4c:	e0bffe15 	stw	r2,-8(fp)
  201c50:	00000906 	br	201c78 <memset+0xd8>
        buffer = (buffer << i) | buffer;
  201c54:	e0fffd17 	ldw	r3,-12(fp)
  201c58:	e0bffe17 	ldw	r2,-8(fp)
  201c5c:	1884983a 	sll	r2,r3,r2
  201c60:	e0fffd17 	ldw	r3,-12(fp)
  201c64:	1884b03a 	or	r2,r3,r2
  201c68:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
  201c6c:	e0bffe17 	ldw	r2,-8(fp)
  201c70:	1085883a 	add	r2,r2,r2
  201c74:	e0bffe15 	stw	r2,-8(fp)
  201c78:	e0bffe17 	ldw	r2,-8(fp)
  201c7c:	10800830 	cmpltui	r2,r2,32
  201c80:	103ff41e 	bne	r2,zero,201c54 <memset+0xb4>

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
  201c84:	00001706 	br	201ce4 <memset+0x144>
        {
          *aligned_addr++ = buffer;
  201c88:	e0bffc17 	ldw	r2,-16(fp)
  201c8c:	10c00104 	addi	r3,r2,4
  201c90:	e0fffc15 	stw	r3,-16(fp)
  201c94:	e0fffd17 	ldw	r3,-12(fp)
  201c98:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
  201c9c:	e0bffc17 	ldw	r2,-16(fp)
  201ca0:	10c00104 	addi	r3,r2,4
  201ca4:	e0fffc15 	stw	r3,-16(fp)
  201ca8:	e0fffd17 	ldw	r3,-12(fp)
  201cac:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
  201cb0:	e0bffc17 	ldw	r2,-16(fp)
  201cb4:	10c00104 	addi	r3,r2,4
  201cb8:	e0fffc15 	stw	r3,-16(fp)
  201cbc:	e0fffd17 	ldw	r3,-12(fp)
  201cc0:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
  201cc4:	e0bffc17 	ldw	r2,-16(fp)
  201cc8:	10c00104 	addi	r3,r2,4
  201ccc:	e0fffc15 	stw	r3,-16(fp)
  201cd0:	e0fffd17 	ldw	r3,-12(fp)
  201cd4:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
  201cd8:	e0bff817 	ldw	r2,-32(fp)
  201cdc:	10bffc04 	addi	r2,r2,-16
  201ce0:	e0bff815 	stw	r2,-32(fp)
      while (n >= LBLOCKSIZE*4)
  201ce4:	e0bff817 	ldw	r2,-32(fp)
  201ce8:	10800428 	cmpgeui	r2,r2,16
  201cec:	103fe61e 	bne	r2,zero,201c88 <memset+0xe8>
        }

      while (n >= LBLOCKSIZE)
  201cf0:	00000806 	br	201d14 <memset+0x174>
        {
          *aligned_addr++ = buffer;
  201cf4:	e0bffc17 	ldw	r2,-16(fp)
  201cf8:	10c00104 	addi	r3,r2,4
  201cfc:	e0fffc15 	stw	r3,-16(fp)
  201d00:	e0fffd17 	ldw	r3,-12(fp)
  201d04:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
  201d08:	e0bff817 	ldw	r2,-32(fp)
  201d0c:	10bfff04 	addi	r2,r2,-4
  201d10:	e0bff815 	stw	r2,-32(fp)
      while (n >= LBLOCKSIZE)
  201d14:	e0bff817 	ldw	r2,-32(fp)
  201d18:	10800128 	cmpgeui	r2,r2,4
  201d1c:	103ff51e 	bne	r2,zero,201cf4 <memset+0x154>
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
  201d20:	e0bffc17 	ldw	r2,-16(fp)
  201d24:	e0bfff15 	stw	r2,-4(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
  201d28:	00000506 	br	201d40 <memset+0x1a0>
    *s++ = (char) c;
  201d2c:	e0bfff17 	ldw	r2,-4(fp)
  201d30:	10c00044 	addi	r3,r2,1
  201d34:	e0ffff15 	stw	r3,-4(fp)
  201d38:	e0fff917 	ldw	r3,-28(fp)
  201d3c:	10c00005 	stb	r3,0(r2)
  while (n--)
  201d40:	e0bff817 	ldw	r2,-32(fp)
  201d44:	10ffffc4 	addi	r3,r2,-1
  201d48:	e0fff815 	stw	r3,-32(fp)
  201d4c:	103ff71e 	bne	r2,zero,201d2c <memset+0x18c>

  return m;
  201d50:	e0bffa17 	ldw	r2,-24(fp)
}
  201d54:	e037883a 	mov	sp,fp
  201d58:	df000017 	ldw	fp,0(sp)
  201d5c:	dec00104 	addi	sp,sp,4
  201d60:	f800283a 	ret

00201d64 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
  201d64:	defffb04 	addi	sp,sp,-20
  201d68:	dfc00415 	stw	ra,16(sp)
  201d6c:	df000315 	stw	fp,12(sp)
  201d70:	df000304 	addi	fp,sp,12
  201d74:	e13ffe15 	stw	r4,-8(fp)
  201d78:	e17ffd15 	stw	r5,-12(fp)
  int ret;

  errno = 0;
  201d7c:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
  201d80:	e13ffd17 	ldw	r4,-12(fp)
  201d84:	0204f0c0 	call	204f0c <close>
  201d88:	e0bfff15 	stw	r2,-4(fp)
  201d8c:	e0bfff17 	ldw	r2,-4(fp)
  201d90:	10bfffd8 	cmpnei	r2,r2,-1
  201d94:	1000051e 	bne	r2,zero,201dac <_close_r+0x48>
  201d98:	d0a61a17 	ldw	r2,-26520(gp)
  201d9c:	10000326 	beq	r2,zero,201dac <_close_r+0x48>
    _REENT_ERRNO(ptr) = errno;
  201da0:	d0e61a17 	ldw	r3,-26520(gp)
  201da4:	e0bffe17 	ldw	r2,-8(fp)
  201da8:	10c00015 	stw	r3,0(r2)
  return ret;
  201dac:	e0bfff17 	ldw	r2,-4(fp)
}
  201db0:	e037883a 	mov	sp,fp
  201db4:	dfc00117 	ldw	ra,4(sp)
  201db8:	df000017 	ldw	fp,0(sp)
  201dbc:	dec00204 	addi	sp,sp,8
  201dc0:	f800283a 	ret

00201dc4 <_reclaim_reent>:

#endif

void
_reclaim_reent (struct _reent *ptr)
{
  201dc4:	defffa04 	addi	sp,sp,-24
  201dc8:	dfc00515 	stw	ra,20(sp)
  201dcc:	df000415 	stw	fp,16(sp)
  201dd0:	df000404 	addi	fp,sp,16
  201dd4:	e13ffc15 	stw	r4,-16(fp)
#ifndef _REENT_THREAD_LOCAL
  if (ptr != _impure_ptr)
  201dd8:	d0a00017 	ldw	r2,-32768(gp)
  201ddc:	e0fffc17 	ldw	r3,-16(fp)
  201de0:	18803926 	beq	r3,r2,201ec8 <_reclaim_reent+0x104>
      /* used by mprec routines. */
#ifdef _REENT_SMALL
      if (ptr->_mp)	/* don't bother allocating it! */
      {
#endif
      if (_REENT_MP_FREELIST(ptr))
  201de4:	e0bffc17 	ldw	r2,-16(fp)
  201de8:	10801117 	ldw	r2,68(r2)
  201dec:	10001f26 	beq	r2,zero,201e6c <_reclaim_reent+0xa8>
	{
	  int i;
	  for (i = 0; i < _Kmax; i++) 
  201df0:	e03fff15 	stw	zero,-4(fp)
  201df4:	00001506 	br	201e4c <_reclaim_reent+0x88>
	    {
	      struct _Bigint *thisone, *nextone;
	
	      nextone = _REENT_MP_FREELIST(ptr)[i];
  201df8:	e0bffc17 	ldw	r2,-16(fp)
  201dfc:	10c01117 	ldw	r3,68(r2)
  201e00:	e0bfff17 	ldw	r2,-4(fp)
  201e04:	100490ba 	slli	r2,r2,2
  201e08:	1885883a 	add	r2,r3,r2
  201e0c:	10800017 	ldw	r2,0(r2)
  201e10:	e0bffe15 	stw	r2,-8(fp)
	      while (nextone)
  201e14:	00000806 	br	201e38 <_reclaim_reent+0x74>
		{
		  thisone = nextone;
  201e18:	e0bffe17 	ldw	r2,-8(fp)
  201e1c:	e0bffd15 	stw	r2,-12(fp)
		  nextone = nextone->_next;
  201e20:	e0bffe17 	ldw	r2,-8(fp)
  201e24:	10800017 	ldw	r2,0(r2)
  201e28:	e0bffe15 	stw	r2,-8(fp)
		  _free_r (ptr, thisone);
  201e2c:	e17ffd17 	ldw	r5,-12(fp)
  201e30:	e13ffc17 	ldw	r4,-16(fp)
  201e34:	02020680 	call	202068 <_free_r>
	      while (nextone)
  201e38:	e0bffe17 	ldw	r2,-8(fp)
  201e3c:	103ff61e 	bne	r2,zero,201e18 <_reclaim_reent+0x54>
	  for (i = 0; i < _Kmax; i++) 
  201e40:	e0bfff17 	ldw	r2,-4(fp)
  201e44:	10800044 	addi	r2,r2,1
  201e48:	e0bfff15 	stw	r2,-4(fp)
  201e4c:	e0bfff17 	ldw	r2,-4(fp)
  201e50:	10800830 	cmpltui	r2,r2,32
  201e54:	103fe81e 	bne	r2,zero,201df8 <_reclaim_reent+0x34>
		}
	    }    

	  _free_r (ptr, _REENT_MP_FREELIST(ptr));
  201e58:	e0bffc17 	ldw	r2,-16(fp)
  201e5c:	10801117 	ldw	r2,68(r2)
  201e60:	100b883a 	mov	r5,r2
  201e64:	e13ffc17 	ldw	r4,-16(fp)
  201e68:	02020680 	call	202068 <_free_r>
	}
      if (_REENT_MP_RESULT(ptr))
  201e6c:	e0bffc17 	ldw	r2,-16(fp)
  201e70:	10800e17 	ldw	r2,56(r2)
  201e74:	10000526 	beq	r2,zero,201e8c <_reclaim_reent+0xc8>
	_free_r (ptr, _REENT_MP_RESULT(ptr));
  201e78:	e0bffc17 	ldw	r2,-16(fp)
  201e7c:	10800e17 	ldw	r2,56(r2)
  201e80:	100b883a 	mov	r5,r2
  201e84:	e13ffc17 	ldw	r4,-16(fp)
  201e88:	02020680 	call	202068 <_free_r>
	_free_r (ptr, ptr->_signal_buf);
	  if (ptr->_misc)
	_free_r (ptr, ptr->_misc);
#endif

      if (_REENT_CVTBUF(ptr))
  201e8c:	e0bffc17 	ldw	r2,-16(fp)
  201e90:	10801317 	ldw	r2,76(r2)
  201e94:	10000526 	beq	r2,zero,201eac <_reclaim_reent+0xe8>
	_free_r (ptr, _REENT_CVTBUF(ptr));
  201e98:	e0bffc17 	ldw	r2,-16(fp)
  201e9c:	10801317 	ldw	r2,76(r2)
  201ea0:	100b883a 	mov	r5,r2
  201ea4:	e13ffc17 	ldw	r4,-16(fp)
  201ea8:	02020680 	call	202068 <_free_r>
	   after the free?
	  if (_REENT_SIG_FUNC(ptr))
	_free_r (ptr, _REENT_SIG_FUNC(ptr));*/

#ifndef WANT_SMALL_STDIO             /* IntelSpecific */
      if (_REENT_CLEANUP(ptr))
  201eac:	e0bffc17 	ldw	r2,-16(fp)
  201eb0:	10800d17 	ldw	r2,52(r2)
  201eb4:	10000426 	beq	r2,zero,201ec8 <_reclaim_reent+0x104>
	{
	  /* cleanup won't reclaim memory 'coz usually it's run
	     before the program exits, and who wants to wait for that? */
	  _REENT_CLEANUP(ptr) (ptr);
  201eb8:	e0bffc17 	ldw	r2,-16(fp)
  201ebc:	10800d17 	ldw	r2,52(r2)
  201ec0:	e13ffc17 	ldw	r4,-16(fp)
  201ec4:	103ee83a 	callr	r2
#endif                               /* IntelSpecific */

      /* Malloc memory not reclaimed; no good way to return memory anyway. */

    }
}
  201ec8:	0001883a 	nop
  201ecc:	e037883a 	mov	sp,fp
  201ed0:	dfc00117 	ldw	ra,4(sp)
  201ed4:	df000017 	ldw	fp,0(sp)
  201ed8:	dec00204 	addi	sp,sp,8
  201edc:	f800283a 	ret

00201ee0 <_lseek_r>:
_off_t
_lseek_r (struct _reent *ptr,
     int fd,
     _off_t pos,
     int whence)
{
  201ee0:	defff904 	addi	sp,sp,-28
  201ee4:	dfc00615 	stw	ra,24(sp)
  201ee8:	df000515 	stw	fp,20(sp)
  201eec:	df000504 	addi	fp,sp,20
  201ef0:	e13ffe15 	stw	r4,-8(fp)
  201ef4:	e17ffd15 	stw	r5,-12(fp)
  201ef8:	e1bffc15 	stw	r6,-16(fp)
  201efc:	e1fffb15 	stw	r7,-20(fp)
  _off_t ret;

  errno = 0;
  201f00:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
  201f04:	e1bffb17 	ldw	r6,-20(fp)
  201f08:	e17ffc17 	ldw	r5,-16(fp)
  201f0c:	e13ffd17 	ldw	r4,-12(fp)
  201f10:	02053380 	call	205338 <lseek>
  201f14:	e0bfff15 	stw	r2,-4(fp)
  201f18:	e0bfff17 	ldw	r2,-4(fp)
  201f1c:	10bfffd8 	cmpnei	r2,r2,-1
  201f20:	1000051e 	bne	r2,zero,201f38 <_lseek_r+0x58>
  201f24:	d0a61a17 	ldw	r2,-26520(gp)
  201f28:	10000326 	beq	r2,zero,201f38 <_lseek_r+0x58>
    _REENT_ERRNO(ptr) = errno;
  201f2c:	d0e61a17 	ldw	r3,-26520(gp)
  201f30:	e0bffe17 	ldw	r2,-8(fp)
  201f34:	10c00015 	stw	r3,0(r2)
  return ret;
  201f38:	e0bfff17 	ldw	r2,-4(fp)
}
  201f3c:	e037883a 	mov	sp,fp
  201f40:	dfc00117 	ldw	ra,4(sp)
  201f44:	df000017 	ldw	fp,0(sp)
  201f48:	dec00204 	addi	sp,sp,8
  201f4c:	f800283a 	ret

00201f50 <_read_r>:
_ssize_t
_read_r (struct _reent *ptr,
     int fd,
     void *buf,
     size_t cnt)
{
  201f50:	defff904 	addi	sp,sp,-28
  201f54:	dfc00615 	stw	ra,24(sp)
  201f58:	df000515 	stw	fp,20(sp)
  201f5c:	df000504 	addi	fp,sp,20
  201f60:	e13ffe15 	stw	r4,-8(fp)
  201f64:	e17ffd15 	stw	r5,-12(fp)
  201f68:	e1bffc15 	stw	r6,-16(fp)
  201f6c:	e1fffb15 	stw	r7,-20(fp)
  _ssize_t ret;

  errno = 0;
  201f70:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
  201f74:	e1bffb17 	ldw	r6,-20(fp)
  201f78:	e17ffc17 	ldw	r5,-16(fp)
  201f7c:	e13ffd17 	ldw	r4,-12(fp)
  201f80:	020550c0 	call	20550c <read>
  201f84:	e0bfff15 	stw	r2,-4(fp)
  201f88:	e0bfff17 	ldw	r2,-4(fp)
  201f8c:	10bfffd8 	cmpnei	r2,r2,-1
  201f90:	1000051e 	bne	r2,zero,201fa8 <_read_r+0x58>
  201f94:	d0a61a17 	ldw	r2,-26520(gp)
  201f98:	10000326 	beq	r2,zero,201fa8 <_read_r+0x58>
    _REENT_ERRNO(ptr) = errno;
  201f9c:	d0e61a17 	ldw	r3,-26520(gp)
  201fa0:	e0bffe17 	ldw	r2,-8(fp)
  201fa4:	10c00015 	stw	r3,0(r2)
  return ret;
  201fa8:	e0bfff17 	ldw	r2,-4(fp)
}
  201fac:	e037883a 	mov	sp,fp
  201fb0:	dfc00117 	ldw	ra,4(sp)
  201fb4:	df000017 	ldw	fp,0(sp)
  201fb8:	dec00204 	addi	sp,sp,8
  201fbc:	f800283a 	ret

00201fc0 <_write_r>:
_ssize_t
_write_r (struct _reent *ptr,
     int fd,
     const void *buf,
     size_t cnt)
{
  201fc0:	defff904 	addi	sp,sp,-28
  201fc4:	dfc00615 	stw	ra,24(sp)
  201fc8:	df000515 	stw	fp,20(sp)
  201fcc:	df000504 	addi	fp,sp,20
  201fd0:	e13ffe15 	stw	r4,-8(fp)
  201fd4:	e17ffd15 	stw	r5,-12(fp)
  201fd8:	e1bffc15 	stw	r6,-16(fp)
  201fdc:	e1fffb15 	stw	r7,-20(fp)
  _ssize_t ret;

  errno = 0;
  201fe0:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
  201fe4:	e1bffb17 	ldw	r6,-20(fp)
  201fe8:	e17ffc17 	ldw	r5,-16(fp)
  201fec:	e13ffd17 	ldw	r4,-12(fp)
  201ff0:	02057540 	call	205754 <write>
  201ff4:	e0bfff15 	stw	r2,-4(fp)
  201ff8:	e0bfff17 	ldw	r2,-4(fp)
  201ffc:	10bfffd8 	cmpnei	r2,r2,-1
  202000:	1000051e 	bne	r2,zero,202018 <_write_r+0x58>
  202004:	d0a61a17 	ldw	r2,-26520(gp)
  202008:	10000326 	beq	r2,zero,202018 <_write_r+0x58>
    _REENT_ERRNO(ptr) = errno;
  20200c:	d0e61a17 	ldw	r3,-26520(gp)
  202010:	e0bffe17 	ldw	r2,-8(fp)
  202014:	10c00015 	stw	r3,0(r2)
  return ret;
  202018:	e0bfff17 	ldw	r2,-4(fp)
}
  20201c:	e037883a 	mov	sp,fp
  202020:	dfc00117 	ldw	ra,4(sp)
  202024:	df000017 	ldw	fp,0(sp)
  202028:	dec00204 	addi	sp,sp,8
  20202c:	f800283a 	ret

00202030 <exit>:
 * Exit, flushing stdio buffers if necessary.
 */

void
exit (int code)
{
  202030:	defffd04 	addi	sp,sp,-12
  202034:	dfc00215 	stw	ra,8(sp)
  202038:	df000115 	stw	fp,4(sp)
  20203c:	df000104 	addi	fp,sp,4
  202040:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs (int, void *) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
  202044:	000b883a 	mov	r5,zero
  202048:	e13fff17 	ldw	r4,-4(fp)
  20204c:	0204b900 	call	204b90 <__call_exitprocs>
#ifndef WANT_SMALL_STDIO        /* IntelSpecific */
  if (__stdio_exit_handler != NULL)
  202050:	d0a61b17 	ldw	r2,-26516(gp)
  202054:	10000226 	beq	r2,zero,202060 <exit+0x30>
    (*__stdio_exit_handler) ();
  202058:	d0a61b17 	ldw	r2,-26516(gp)
  20205c:	103ee83a 	callr	r2
#endif                          /* IntelSpecific */
  _exit (code);
  202060:	e13fff17 	ldw	r4,-4(fp)
  202064:	02050080 	call	205008 <_exit>

00202068 <_free_r>:
  202068:	defff204 	addi	sp,sp,-56
  20206c:	dfc00d15 	stw	ra,52(sp)
  202070:	df000c15 	stw	fp,48(sp)
  202074:	df000c04 	addi	fp,sp,48
  202078:	e13ff515 	stw	r4,-44(fp)
  20207c:	e17ff415 	stw	r5,-48(fp)
  202080:	e0bff417 	ldw	r2,-48(fp)
  202084:	10014826 	beq	r2,zero,2025a8 <_free_r+0x540>
  202088:	e13ff517 	ldw	r4,-44(fp)
  20208c:	02054880 	call	205488 <__malloc_lock>
  202090:	e0bff417 	ldw	r2,-48(fp)
  202094:	10bffe04 	addi	r2,r2,-8
  202098:	e0bfff15 	stw	r2,-4(fp)
  20209c:	e0bfff17 	ldw	r2,-4(fp)
  2020a0:	10800117 	ldw	r2,4(r2)
  2020a4:	e0bffa15 	stw	r2,-24(fp)
  2020a8:	e0fffa17 	ldw	r3,-24(fp)
  2020ac:	00bfff84 	movi	r2,-2
  2020b0:	1884703a 	and	r2,r3,r2
  2020b4:	e0bffe15 	stw	r2,-8(fp)
  2020b8:	e0ffff17 	ldw	r3,-4(fp)
  2020bc:	e0bffe17 	ldw	r2,-8(fp)
  2020c0:	1885883a 	add	r2,r3,r2
  2020c4:	e0bff915 	stw	r2,-28(fp)
  2020c8:	e0bff917 	ldw	r2,-28(fp)
  2020cc:	10c00117 	ldw	r3,4(r2)
  2020d0:	00bfff04 	movi	r2,-4
  2020d4:	1884703a 	and	r2,r3,r2
  2020d8:	e0bff815 	stw	r2,-32(fp)
  2020dc:	00800834 	movhi	r2,32
  2020e0:	109fd404 	addi	r2,r2,32592
  2020e4:	10800217 	ldw	r2,8(r2)
  2020e8:	e0fff917 	ldw	r3,-28(fp)
  2020ec:	1880311e 	bne	r3,r2,2021b4 <_free_r+0x14c>
  2020f0:	e0fffe17 	ldw	r3,-8(fp)
  2020f4:	e0bff817 	ldw	r2,-32(fp)
  2020f8:	1885883a 	add	r2,r3,r2
  2020fc:	e0bffe15 	stw	r2,-8(fp)
  202100:	e0bffa17 	ldw	r2,-24(fp)
  202104:	1080004c 	andi	r2,r2,1
  202108:	1000181e 	bne	r2,zero,20216c <_free_r+0x104>
  20210c:	e0bfff17 	ldw	r2,-4(fp)
  202110:	10800017 	ldw	r2,0(r2)
  202114:	e0bff715 	stw	r2,-36(fp)
  202118:	e0bff717 	ldw	r2,-36(fp)
  20211c:	0085c83a 	sub	r2,zero,r2
  202120:	e0ffff17 	ldw	r3,-4(fp)
  202124:	1885883a 	add	r2,r3,r2
  202128:	e0bfff15 	stw	r2,-4(fp)
  20212c:	e0fffe17 	ldw	r3,-8(fp)
  202130:	e0bff717 	ldw	r2,-36(fp)
  202134:	1885883a 	add	r2,r3,r2
  202138:	e0bffe15 	stw	r2,-8(fp)
  20213c:	e0bfff17 	ldw	r2,-4(fp)
  202140:	10800317 	ldw	r2,12(r2)
  202144:	e0bffd15 	stw	r2,-12(fp)
  202148:	e0bfff17 	ldw	r2,-4(fp)
  20214c:	10800217 	ldw	r2,8(r2)
  202150:	e0bffc15 	stw	r2,-16(fp)
  202154:	e0bffc17 	ldw	r2,-16(fp)
  202158:	e0fffd17 	ldw	r3,-12(fp)
  20215c:	10c00315 	stw	r3,12(r2)
  202160:	e0bffd17 	ldw	r2,-12(fp)
  202164:	e0fffc17 	ldw	r3,-16(fp)
  202168:	10c00215 	stw	r3,8(r2)
  20216c:	e0bffe17 	ldw	r2,-8(fp)
  202170:	10c00054 	ori	r3,r2,1
  202174:	e0bfff17 	ldw	r2,-4(fp)
  202178:	10c00115 	stw	r3,4(r2)
  20217c:	00800834 	movhi	r2,32
  202180:	109fd404 	addi	r2,r2,32592
  202184:	e0ffff17 	ldw	r3,-4(fp)
  202188:	10c00215 	stw	r3,8(r2)
  20218c:	d0a00117 	ldw	r2,-32764(gp)
  202190:	e0fffe17 	ldw	r3,-8(fp)
  202194:	18800436 	bltu	r3,r2,2021a8 <_free_r+0x140>
  202198:	d0a61c17 	ldw	r2,-26512(gp)
  20219c:	100b883a 	mov	r5,r2
  2021a0:	e13ff517 	ldw	r4,-44(fp)
  2021a4:	02025c00 	call	2025c0 <_malloc_trim_r>
  2021a8:	e13ff517 	ldw	r4,-44(fp)
  2021ac:	02054ac0 	call	2054ac <__malloc_unlock>
  2021b0:	0000fe06 	br	2025ac <_free_r+0x544>
  2021b4:	e0bff917 	ldw	r2,-28(fp)
  2021b8:	e0fff817 	ldw	r3,-32(fp)
  2021bc:	10c00115 	stw	r3,4(r2)
  2021c0:	e03ffb15 	stw	zero,-20(fp)
  2021c4:	e0bffa17 	ldw	r2,-24(fp)
  2021c8:	1080004c 	andi	r2,r2,1
  2021cc:	1000201e 	bne	r2,zero,202250 <_free_r+0x1e8>
  2021d0:	e0bfff17 	ldw	r2,-4(fp)
  2021d4:	10800017 	ldw	r2,0(r2)
  2021d8:	e0bff715 	stw	r2,-36(fp)
  2021dc:	e0bff717 	ldw	r2,-36(fp)
  2021e0:	0085c83a 	sub	r2,zero,r2
  2021e4:	e0ffff17 	ldw	r3,-4(fp)
  2021e8:	1885883a 	add	r2,r3,r2
  2021ec:	e0bfff15 	stw	r2,-4(fp)
  2021f0:	e0fffe17 	ldw	r3,-8(fp)
  2021f4:	e0bff717 	ldw	r2,-36(fp)
  2021f8:	1885883a 	add	r2,r3,r2
  2021fc:	e0bffe15 	stw	r2,-8(fp)
  202200:	e0bfff17 	ldw	r2,-4(fp)
  202204:	10c00217 	ldw	r3,8(r2)
  202208:	00800834 	movhi	r2,32
  20220c:	109fd604 	addi	r2,r2,32600
  202210:	1880031e 	bne	r3,r2,202220 <_free_r+0x1b8>
  202214:	00800044 	movi	r2,1
  202218:	e0bffb15 	stw	r2,-20(fp)
  20221c:	00000c06 	br	202250 <_free_r+0x1e8>
  202220:	e0bfff17 	ldw	r2,-4(fp)
  202224:	10800317 	ldw	r2,12(r2)
  202228:	e0bffd15 	stw	r2,-12(fp)
  20222c:	e0bfff17 	ldw	r2,-4(fp)
  202230:	10800217 	ldw	r2,8(r2)
  202234:	e0bffc15 	stw	r2,-16(fp)
  202238:	e0bffc17 	ldw	r2,-16(fp)
  20223c:	e0fffd17 	ldw	r3,-12(fp)
  202240:	10c00315 	stw	r3,12(r2)
  202244:	e0bffd17 	ldw	r2,-12(fp)
  202248:	e0fffc17 	ldw	r3,-16(fp)
  20224c:	10c00215 	stw	r3,8(r2)
  202250:	e0fff917 	ldw	r3,-28(fp)
  202254:	e0bff817 	ldw	r2,-32(fp)
  202258:	1885883a 	add	r2,r3,r2
  20225c:	10800117 	ldw	r2,4(r2)
  202260:	1080004c 	andi	r2,r2,1
  202264:	10002a1e 	bne	r2,zero,202310 <_free_r+0x2a8>
  202268:	e0fffe17 	ldw	r3,-8(fp)
  20226c:	e0bff817 	ldw	r2,-32(fp)
  202270:	1885883a 	add	r2,r3,r2
  202274:	e0bffe15 	stw	r2,-8(fp)
  202278:	e0bffb17 	ldw	r2,-20(fp)
  20227c:	1000181e 	bne	r2,zero,2022e0 <_free_r+0x278>
  202280:	e0bff917 	ldw	r2,-28(fp)
  202284:	10c00217 	ldw	r3,8(r2)
  202288:	00800834 	movhi	r2,32
  20228c:	109fd604 	addi	r2,r2,32600
  202290:	1880131e 	bne	r3,r2,2022e0 <_free_r+0x278>
  202294:	00800044 	movi	r2,1
  202298:	e0bffb15 	stw	r2,-20(fp)
  20229c:	00800834 	movhi	r2,32
  2022a0:	109fd604 	addi	r2,r2,32600
  2022a4:	e0ffff17 	ldw	r3,-4(fp)
  2022a8:	10c00315 	stw	r3,12(r2)
  2022ac:	00c00834 	movhi	r3,32
  2022b0:	18dfd604 	addi	r3,r3,32600
  2022b4:	10800317 	ldw	r2,12(r2)
  2022b8:	18800215 	stw	r2,8(r3)
  2022bc:	00800834 	movhi	r2,32
  2022c0:	109fd604 	addi	r2,r2,32600
  2022c4:	e0ffff17 	ldw	r3,-4(fp)
  2022c8:	18800315 	stw	r2,12(r3)
  2022cc:	e0bfff17 	ldw	r2,-4(fp)
  2022d0:	10c00317 	ldw	r3,12(r2)
  2022d4:	e0bfff17 	ldw	r2,-4(fp)
  2022d8:	10c00215 	stw	r3,8(r2)
  2022dc:	00000c06 	br	202310 <_free_r+0x2a8>
  2022e0:	e0bff917 	ldw	r2,-28(fp)
  2022e4:	10800317 	ldw	r2,12(r2)
  2022e8:	e0bffd15 	stw	r2,-12(fp)
  2022ec:	e0bff917 	ldw	r2,-28(fp)
  2022f0:	10800217 	ldw	r2,8(r2)
  2022f4:	e0bffc15 	stw	r2,-16(fp)
  2022f8:	e0bffc17 	ldw	r2,-16(fp)
  2022fc:	e0fffd17 	ldw	r3,-12(fp)
  202300:	10c00315 	stw	r3,12(r2)
  202304:	e0bffd17 	ldw	r2,-12(fp)
  202308:	e0fffc17 	ldw	r3,-16(fp)
  20230c:	10c00215 	stw	r3,8(r2)
  202310:	e0bffe17 	ldw	r2,-8(fp)
  202314:	10c00054 	ori	r3,r2,1
  202318:	e0bfff17 	ldw	r2,-4(fp)
  20231c:	10c00115 	stw	r3,4(r2)
  202320:	e0ffff17 	ldw	r3,-4(fp)
  202324:	e0bffe17 	ldw	r2,-8(fp)
  202328:	1885883a 	add	r2,r3,r2
  20232c:	e0fffe17 	ldw	r3,-8(fp)
  202330:	10c00015 	stw	r3,0(r2)
  202334:	e0bffb17 	ldw	r2,-20(fp)
  202338:	1000981e 	bne	r2,zero,20259c <_free_r+0x534>
  20233c:	e0bffe17 	ldw	r2,-8(fp)
  202340:	10808028 	cmpgeui	r2,r2,512
  202344:	10002b1e 	bne	r2,zero,2023f4 <_free_r+0x38c>
  202348:	e0bffe17 	ldw	r2,-8(fp)
  20234c:	1004d0fa 	srli	r2,r2,3
  202350:	e0bff615 	stw	r2,-40(fp)
  202354:	00800834 	movhi	r2,32
  202358:	109fd404 	addi	r2,r2,32592
  20235c:	11000117 	ldw	r4,4(r2)
  202360:	e0bff617 	ldw	r2,-40(fp)
  202364:	1000010e 	bge	r2,zero,20236c <_free_r+0x304>
  202368:	108000c4 	addi	r2,r2,3
  20236c:	1005d0ba 	srai	r2,r2,2
  202370:	1007883a 	mov	r3,r2
  202374:	00800044 	movi	r2,1
  202378:	10c6983a 	sll	r3,r2,r3
  20237c:	00800834 	movhi	r2,32
  202380:	109fd404 	addi	r2,r2,32592
  202384:	20c6b03a 	or	r3,r4,r3
  202388:	10c00115 	stw	r3,4(r2)
  20238c:	e0bff617 	ldw	r2,-40(fp)
  202390:	10800044 	addi	r2,r2,1
  202394:	1085883a 	add	r2,r2,r2
  202398:	100690ba 	slli	r3,r2,2
  20239c:	00800834 	movhi	r2,32
  2023a0:	109fd404 	addi	r2,r2,32592
  2023a4:	1885883a 	add	r2,r3,r2
  2023a8:	10bffe04 	addi	r2,r2,-8
  2023ac:	e0bffd15 	stw	r2,-12(fp)
  2023b0:	e0bffd17 	ldw	r2,-12(fp)
  2023b4:	10800217 	ldw	r2,8(r2)
  2023b8:	e0bffc15 	stw	r2,-16(fp)
  2023bc:	e0bfff17 	ldw	r2,-4(fp)
  2023c0:	e0fffd17 	ldw	r3,-12(fp)
  2023c4:	10c00315 	stw	r3,12(r2)
  2023c8:	e0bfff17 	ldw	r2,-4(fp)
  2023cc:	e0fffc17 	ldw	r3,-16(fp)
  2023d0:	10c00215 	stw	r3,8(r2)
  2023d4:	e0bffd17 	ldw	r2,-12(fp)
  2023d8:	e0ffff17 	ldw	r3,-4(fp)
  2023dc:	10c00215 	stw	r3,8(r2)
  2023e0:	e0bffd17 	ldw	r2,-12(fp)
  2023e4:	10c00217 	ldw	r3,8(r2)
  2023e8:	e0bffc17 	ldw	r2,-16(fp)
  2023ec:	10c00315 	stw	r3,12(r2)
  2023f0:	00006a06 	br	20259c <_free_r+0x534>
  2023f4:	e0bffe17 	ldw	r2,-8(fp)
  2023f8:	1004d27a 	srli	r2,r2,9
  2023fc:	1000031e 	bne	r2,zero,20240c <_free_r+0x3a4>
  202400:	e0bffe17 	ldw	r2,-8(fp)
  202404:	1004d0fa 	srli	r2,r2,3
  202408:	00002906 	br	2024b0 <_free_r+0x448>
  20240c:	e0bffe17 	ldw	r2,-8(fp)
  202410:	1004d27a 	srli	r2,r2,9
  202414:	10800168 	cmpgeui	r2,r2,5
  202418:	1000041e 	bne	r2,zero,20242c <_free_r+0x3c4>
  20241c:	e0bffe17 	ldw	r2,-8(fp)
  202420:	1004d1ba 	srli	r2,r2,6
  202424:	10800e04 	addi	r2,r2,56
  202428:	00002106 	br	2024b0 <_free_r+0x448>
  20242c:	e0bffe17 	ldw	r2,-8(fp)
  202430:	1004d27a 	srli	r2,r2,9
  202434:	10800568 	cmpgeui	r2,r2,21
  202438:	1000041e 	bne	r2,zero,20244c <_free_r+0x3e4>
  20243c:	e0bffe17 	ldw	r2,-8(fp)
  202440:	1004d27a 	srli	r2,r2,9
  202444:	108016c4 	addi	r2,r2,91
  202448:	00001906 	br	2024b0 <_free_r+0x448>
  20244c:	e0bffe17 	ldw	r2,-8(fp)
  202450:	1004d27a 	srli	r2,r2,9
  202454:	10801568 	cmpgeui	r2,r2,85
  202458:	1000041e 	bne	r2,zero,20246c <_free_r+0x404>
  20245c:	e0bffe17 	ldw	r2,-8(fp)
  202460:	1004d33a 	srli	r2,r2,12
  202464:	10801b84 	addi	r2,r2,110
  202468:	00001106 	br	2024b0 <_free_r+0x448>
  20246c:	e0bffe17 	ldw	r2,-8(fp)
  202470:	1004d27a 	srli	r2,r2,9
  202474:	10805568 	cmpgeui	r2,r2,341
  202478:	1000041e 	bne	r2,zero,20248c <_free_r+0x424>
  20247c:	e0bffe17 	ldw	r2,-8(fp)
  202480:	1004d3fa 	srli	r2,r2,15
  202484:	10801dc4 	addi	r2,r2,119
  202488:	00000906 	br	2024b0 <_free_r+0x448>
  20248c:	e0bffe17 	ldw	r2,-8(fp)
  202490:	1004d27a 	srli	r2,r2,9
  202494:	10815568 	cmpgeui	r2,r2,1365
  202498:	1000041e 	bne	r2,zero,2024ac <_free_r+0x444>
  20249c:	e0bffe17 	ldw	r2,-8(fp)
  2024a0:	1004d4ba 	srli	r2,r2,18
  2024a4:	10801f04 	addi	r2,r2,124
  2024a8:	00000106 	br	2024b0 <_free_r+0x448>
  2024ac:	00801f84 	movi	r2,126
  2024b0:	e0bff615 	stw	r2,-40(fp)
  2024b4:	e0bff617 	ldw	r2,-40(fp)
  2024b8:	10800044 	addi	r2,r2,1
  2024bc:	1085883a 	add	r2,r2,r2
  2024c0:	100690ba 	slli	r3,r2,2
  2024c4:	00800834 	movhi	r2,32
  2024c8:	109fd404 	addi	r2,r2,32592
  2024cc:	1885883a 	add	r2,r3,r2
  2024d0:	10bffe04 	addi	r2,r2,-8
  2024d4:	e0bffd15 	stw	r2,-12(fp)
  2024d8:	e0bffd17 	ldw	r2,-12(fp)
  2024dc:	10800217 	ldw	r2,8(r2)
  2024e0:	e0bffc15 	stw	r2,-16(fp)
  2024e4:	e0fffc17 	ldw	r3,-16(fp)
  2024e8:	e0bffd17 	ldw	r2,-12(fp)
  2024ec:	1880121e 	bne	r3,r2,202538 <_free_r+0x4d0>
  2024f0:	00800834 	movhi	r2,32
  2024f4:	109fd404 	addi	r2,r2,32592
  2024f8:	11000117 	ldw	r4,4(r2)
  2024fc:	e0bff617 	ldw	r2,-40(fp)
  202500:	1000010e 	bge	r2,zero,202508 <_free_r+0x4a0>
  202504:	108000c4 	addi	r2,r2,3
  202508:	1005d0ba 	srai	r2,r2,2
  20250c:	1007883a 	mov	r3,r2
  202510:	00800044 	movi	r2,1
  202514:	10c6983a 	sll	r3,r2,r3
  202518:	00800834 	movhi	r2,32
  20251c:	109fd404 	addi	r2,r2,32592
  202520:	20c6b03a 	or	r3,r4,r3
  202524:	10c00115 	stw	r3,4(r2)
  202528:	00000f06 	br	202568 <_free_r+0x500>
  20252c:	e0bffc17 	ldw	r2,-16(fp)
  202530:	10800217 	ldw	r2,8(r2)
  202534:	e0bffc15 	stw	r2,-16(fp)
  202538:	e0fffc17 	ldw	r3,-16(fp)
  20253c:	e0bffd17 	ldw	r2,-12(fp)
  202540:	18800626 	beq	r3,r2,20255c <_free_r+0x4f4>
  202544:	e0bffc17 	ldw	r2,-16(fp)
  202548:	10c00117 	ldw	r3,4(r2)
  20254c:	00bfff04 	movi	r2,-4
  202550:	1884703a 	and	r2,r3,r2
  202554:	e0fffe17 	ldw	r3,-8(fp)
  202558:	18bff436 	bltu	r3,r2,20252c <_free_r+0x4c4>
  20255c:	e0bffc17 	ldw	r2,-16(fp)
  202560:	10800317 	ldw	r2,12(r2)
  202564:	e0bffd15 	stw	r2,-12(fp)
  202568:	e0bfff17 	ldw	r2,-4(fp)
  20256c:	e0fffd17 	ldw	r3,-12(fp)
  202570:	10c00315 	stw	r3,12(r2)
  202574:	e0bfff17 	ldw	r2,-4(fp)
  202578:	e0fffc17 	ldw	r3,-16(fp)
  20257c:	10c00215 	stw	r3,8(r2)
  202580:	e0bffd17 	ldw	r2,-12(fp)
  202584:	e0ffff17 	ldw	r3,-4(fp)
  202588:	10c00215 	stw	r3,8(r2)
  20258c:	e0bffd17 	ldw	r2,-12(fp)
  202590:	10c00217 	ldw	r3,8(r2)
  202594:	e0bffc17 	ldw	r2,-16(fp)
  202598:	10c00315 	stw	r3,12(r2)
  20259c:	e13ff517 	ldw	r4,-44(fp)
  2025a0:	02054ac0 	call	2054ac <__malloc_unlock>
  2025a4:	00000106 	br	2025ac <_free_r+0x544>
  2025a8:	0001883a 	nop
  2025ac:	e037883a 	mov	sp,fp
  2025b0:	dfc00117 	ldw	ra,4(sp)
  2025b4:	df000017 	ldw	fp,0(sp)
  2025b8:	dec00204 	addi	sp,sp,8
  2025bc:	f800283a 	ret

002025c0 <_malloc_trim_r>:
  2025c0:	defff704 	addi	sp,sp,-36
  2025c4:	dfc00815 	stw	ra,32(sp)
  2025c8:	df000715 	stw	fp,28(sp)
  2025cc:	df000704 	addi	fp,sp,28
  2025d0:	e13ffa15 	stw	r4,-24(fp)
  2025d4:	e17ff915 	stw	r5,-28(fp)
  2025d8:	00840004 	movi	r2,4096
  2025dc:	e0bfff15 	stw	r2,-4(fp)
  2025e0:	e13ffa17 	ldw	r4,-24(fp)
  2025e4:	02054880 	call	205488 <__malloc_lock>
  2025e8:	00800834 	movhi	r2,32
  2025ec:	109fd404 	addi	r2,r2,32592
  2025f0:	10800217 	ldw	r2,8(r2)
  2025f4:	10800117 	ldw	r2,4(r2)
  2025f8:	1007883a 	mov	r3,r2
  2025fc:	00bfff04 	movi	r2,-4
  202600:	1884703a 	and	r2,r3,r2
  202604:	e0bffe15 	stw	r2,-8(fp)
  202608:	e0fffe17 	ldw	r3,-8(fp)
  20260c:	e0bff917 	ldw	r2,-28(fp)
  202610:	1887c83a 	sub	r3,r3,r2
  202614:	e0bfff17 	ldw	r2,-4(fp)
  202618:	1885883a 	add	r2,r3,r2
  20261c:	10bffbc4 	addi	r2,r2,-17
  202620:	e17fff17 	ldw	r5,-4(fp)
  202624:	1009883a 	mov	r4,r2
  202628:	0204e100 	call	204e10 <__udivsi3>
  20262c:	10ffffc4 	addi	r3,r2,-1
  202630:	e0bfff17 	ldw	r2,-4(fp)
  202634:	1885383a 	mul	r2,r3,r2
  202638:	e0bffd15 	stw	r2,-12(fp)
  20263c:	e0bfff17 	ldw	r2,-4(fp)
  202640:	e0fffd17 	ldw	r3,-12(fp)
  202644:	1880040e 	bge	r3,r2,202658 <_malloc_trim_r+0x98>
  202648:	e13ffa17 	ldw	r4,-24(fp)
  20264c:	02054ac0 	call	2054ac <__malloc_unlock>
  202650:	0005883a 	mov	r2,zero
  202654:	00004506 	br	20276c <_malloc_trim_r+0x1ac>
  202658:	000b883a 	mov	r5,zero
  20265c:	e13ffa17 	ldw	r4,-24(fp)
  202660:	0204b300 	call	204b30 <_sbrk_r>
  202664:	e0bffc15 	stw	r2,-16(fp)
  202668:	00800834 	movhi	r2,32
  20266c:	109fd404 	addi	r2,r2,32592
  202670:	10c00217 	ldw	r3,8(r2)
  202674:	e0bffe17 	ldw	r2,-8(fp)
  202678:	1885883a 	add	r2,r3,r2
  20267c:	e0fffc17 	ldw	r3,-16(fp)
  202680:	18800426 	beq	r3,r2,202694 <_malloc_trim_r+0xd4>
  202684:	e13ffa17 	ldw	r4,-24(fp)
  202688:	02054ac0 	call	2054ac <__malloc_unlock>
  20268c:	0005883a 	mov	r2,zero
  202690:	00003606 	br	20276c <_malloc_trim_r+0x1ac>
  202694:	e0bffd17 	ldw	r2,-12(fp)
  202698:	0085c83a 	sub	r2,zero,r2
  20269c:	100b883a 	mov	r5,r2
  2026a0:	e13ffa17 	ldw	r4,-24(fp)
  2026a4:	0204b300 	call	204b30 <_sbrk_r>
  2026a8:	e0bffb15 	stw	r2,-20(fp)
  2026ac:	e0bffb17 	ldw	r2,-20(fp)
  2026b0:	10bfffd8 	cmpnei	r2,r2,-1
  2026b4:	10001c1e 	bne	r2,zero,202728 <_malloc_trim_r+0x168>
  2026b8:	000b883a 	mov	r5,zero
  2026bc:	e13ffa17 	ldw	r4,-24(fp)
  2026c0:	0204b300 	call	204b30 <_sbrk_r>
  2026c4:	e0bffc15 	stw	r2,-16(fp)
  2026c8:	00800834 	movhi	r2,32
  2026cc:	109fd404 	addi	r2,r2,32592
  2026d0:	10800217 	ldw	r2,8(r2)
  2026d4:	e0fffc17 	ldw	r3,-16(fp)
  2026d8:	1885c83a 	sub	r2,r3,r2
  2026dc:	e0bffe15 	stw	r2,-8(fp)
  2026e0:	e0bffe17 	ldw	r2,-8(fp)
  2026e4:	10800410 	cmplti	r2,r2,16
  2026e8:	10000b1e 	bne	r2,zero,202718 <_malloc_trim_r+0x158>
  2026ec:	d0a00217 	ldw	r2,-32760(gp)
  2026f0:	e0fffc17 	ldw	r3,-16(fp)
  2026f4:	1887c83a 	sub	r3,r3,r2
  2026f8:	00800874 	movhi	r2,33
  2026fc:	10ec0015 	stw	r3,-20480(r2)
  202700:	e0bffe17 	ldw	r2,-8(fp)
  202704:	10c00054 	ori	r3,r2,1
  202708:	00800834 	movhi	r2,32
  20270c:	109fd404 	addi	r2,r2,32592
  202710:	10800217 	ldw	r2,8(r2)
  202714:	10c00115 	stw	r3,4(r2)
  202718:	e13ffa17 	ldw	r4,-24(fp)
  20271c:	02054ac0 	call	2054ac <__malloc_unlock>
  202720:	0005883a 	mov	r2,zero
  202724:	00001106 	br	20276c <_malloc_trim_r+0x1ac>
  202728:	e0fffe17 	ldw	r3,-8(fp)
  20272c:	e0bffd17 	ldw	r2,-12(fp)
  202730:	1885c83a 	sub	r2,r3,r2
  202734:	10c00054 	ori	r3,r2,1
  202738:	00800834 	movhi	r2,32
  20273c:	109fd404 	addi	r2,r2,32592
  202740:	10800217 	ldw	r2,8(r2)
  202744:	10c00115 	stw	r3,4(r2)
  202748:	00800874 	movhi	r2,33
  20274c:	10ec0017 	ldw	r3,-20480(r2)
  202750:	e0bffd17 	ldw	r2,-12(fp)
  202754:	1887c83a 	sub	r3,r3,r2
  202758:	00800874 	movhi	r2,33
  20275c:	10ec0015 	stw	r3,-20480(r2)
  202760:	e13ffa17 	ldw	r4,-24(fp)
  202764:	02054ac0 	call	2054ac <__malloc_unlock>
  202768:	00800044 	movi	r2,1
  20276c:	e037883a 	mov	sp,fp
  202770:	dfc00117 	ldw	ra,4(sp)
  202774:	df000017 	ldw	fp,0(sp)
  202778:	dec00204 	addi	sp,sp,8
  20277c:	f800283a 	ret

00202780 <malloc_extend_top>:
  202780:	defff104 	addi	sp,sp,-60
  202784:	dfc00e15 	stw	ra,56(sp)
  202788:	df000d15 	stw	fp,52(sp)
  20278c:	df000d04 	addi	fp,sp,52
  202790:	e13ff415 	stw	r4,-48(fp)
  202794:	e17ff315 	stw	r5,-52(fp)
  202798:	e03ffb15 	stw	zero,-20(fp)
  20279c:	00800834 	movhi	r2,32
  2027a0:	109fd404 	addi	r2,r2,32592
  2027a4:	10800217 	ldw	r2,8(r2)
  2027a8:	e0bffa15 	stw	r2,-24(fp)
  2027ac:	e0bffa17 	ldw	r2,-24(fp)
  2027b0:	10c00117 	ldw	r3,4(r2)
  2027b4:	00bfff04 	movi	r2,-4
  2027b8:	1884703a 	and	r2,r3,r2
  2027bc:	e0bff915 	stw	r2,-28(fp)
  2027c0:	e0fffa17 	ldw	r3,-24(fp)
  2027c4:	e0bff917 	ldw	r2,-28(fp)
  2027c8:	1885883a 	add	r2,r3,r2
  2027cc:	e0bff815 	stw	r2,-32(fp)
  2027d0:	d0e61c17 	ldw	r3,-26512(gp)
  2027d4:	e0bff317 	ldw	r2,-52(fp)
  2027d8:	1885883a 	add	r2,r3,r2
  2027dc:	10800404 	addi	r2,r2,16
  2027e0:	e0bffc15 	stw	r2,-16(fp)
  2027e4:	00840004 	movi	r2,4096
  2027e8:	e0bff715 	stw	r2,-36(fp)
  2027ec:	d0a00217 	ldw	r2,-32760(gp)
  2027f0:	10bfffe0 	cmpeqi	r2,r2,-1
  2027f4:	1000081e 	bne	r2,zero,202818 <malloc_extend_top+0x98>
  2027f8:	e0fff717 	ldw	r3,-36(fp)
  2027fc:	e0bffc17 	ldw	r2,-16(fp)
  202800:	1885883a 	add	r2,r3,r2
  202804:	10ffffc4 	addi	r3,r2,-1
  202808:	e0bff717 	ldw	r2,-36(fp)
  20280c:	0085c83a 	sub	r2,zero,r2
  202810:	1884703a 	and	r2,r3,r2
  202814:	e0bffc15 	stw	r2,-16(fp)
  202818:	e0bffc17 	ldw	r2,-16(fp)
  20281c:	100b883a 	mov	r5,r2
  202820:	e13ff417 	ldw	r4,-48(fp)
  202824:	0204b300 	call	204b30 <_sbrk_r>
  202828:	e0bfff15 	stw	r2,-4(fp)
  20282c:	e0bfff17 	ldw	r2,-4(fp)
  202830:	10bfffe0 	cmpeqi	r2,r2,-1
  202834:	1000bd1e 	bne	r2,zero,202b2c <malloc_extend_top+0x3ac>
  202838:	e0ffff17 	ldw	r3,-4(fp)
  20283c:	e0bff817 	ldw	r2,-32(fp)
  202840:	1880042e 	bgeu	r3,r2,202854 <malloc_extend_top+0xd4>
  202844:	00800834 	movhi	r2,32
  202848:	109fd404 	addi	r2,r2,32592
  20284c:	e0fffa17 	ldw	r3,-24(fp)
  202850:	1880b61e 	bne	r3,r2,202b2c <malloc_extend_top+0x3ac>
  202854:	00800874 	movhi	r2,33
  202858:	10ac0017 	ldw	r2,-20480(r2)
  20285c:	1007883a 	mov	r3,r2
  202860:	e0bffc17 	ldw	r2,-16(fp)
  202864:	1885883a 	add	r2,r3,r2
  202868:	1007883a 	mov	r3,r2
  20286c:	00800874 	movhi	r2,33
  202870:	10ec0015 	stw	r3,-20480(r2)
  202874:	e0ffff17 	ldw	r3,-4(fp)
  202878:	e0bff817 	ldw	r2,-32(fp)
  20287c:	1880101e 	bne	r3,r2,2028c0 <malloc_extend_top+0x140>
  202880:	e0bff717 	ldw	r2,-36(fp)
  202884:	10ffffc4 	addi	r3,r2,-1
  202888:	e0bff817 	ldw	r2,-32(fp)
  20288c:	1884703a 	and	r2,r3,r2
  202890:	10000b1e 	bne	r2,zero,2028c0 <malloc_extend_top+0x140>
  202894:	e0fffc17 	ldw	r3,-16(fp)
  202898:	e0bff917 	ldw	r2,-28(fp)
  20289c:	1885883a 	add	r2,r3,r2
  2028a0:	e0bff615 	stw	r2,-40(fp)
  2028a4:	00800834 	movhi	r2,32
  2028a8:	109fd404 	addi	r2,r2,32592
  2028ac:	10800217 	ldw	r2,8(r2)
  2028b0:	e0fff617 	ldw	r3,-40(fp)
  2028b4:	18c00054 	ori	r3,r3,1
  2028b8:	10c00115 	stw	r3,4(r2)
  2028bc:	00008a06 	br	202ae8 <malloc_extend_top+0x368>
  2028c0:	d0a00217 	ldw	r2,-32760(gp)
  2028c4:	10bfffd8 	cmpnei	r2,r2,-1
  2028c8:	1000031e 	bne	r2,zero,2028d8 <malloc_extend_top+0x158>
  2028cc:	e0bfff17 	ldw	r2,-4(fp)
  2028d0:	d0a00215 	stw	r2,-32760(gp)
  2028d4:	00000806 	br	2028f8 <malloc_extend_top+0x178>
  2028d8:	00800874 	movhi	r2,33
  2028dc:	10ec0017 	ldw	r3,-20480(r2)
  2028e0:	e13fff17 	ldw	r4,-4(fp)
  2028e4:	e0bff817 	ldw	r2,-32(fp)
  2028e8:	2085c83a 	sub	r2,r4,r2
  2028ec:	1887883a 	add	r3,r3,r2
  2028f0:	00800874 	movhi	r2,33
  2028f4:	10ec0015 	stw	r3,-20480(r2)
  2028f8:	e0bfff17 	ldw	r2,-4(fp)
  2028fc:	10800204 	addi	r2,r2,8
  202900:	108001cc 	andi	r2,r2,7
  202904:	e0bff515 	stw	r2,-44(fp)
  202908:	e0bff517 	ldw	r2,-44(fp)
  20290c:	10000926 	beq	r2,zero,202934 <malloc_extend_top+0x1b4>
  202910:	00c00204 	movi	r3,8
  202914:	e0bff517 	ldw	r2,-44(fp)
  202918:	1885c83a 	sub	r2,r3,r2
  20291c:	e0bffe15 	stw	r2,-8(fp)
  202920:	e0ffff17 	ldw	r3,-4(fp)
  202924:	e0bffe17 	ldw	r2,-8(fp)
  202928:	1885883a 	add	r2,r3,r2
  20292c:	e0bfff15 	stw	r2,-4(fp)
  202930:	00000106 	br	202938 <malloc_extend_top+0x1b8>
  202934:	e03ffe15 	stw	zero,-8(fp)
  202938:	e0ffff17 	ldw	r3,-4(fp)
  20293c:	e0bffc17 	ldw	r2,-16(fp)
  202940:	1885883a 	add	r2,r3,r2
  202944:	1007883a 	mov	r3,r2
  202948:	e0bff717 	ldw	r2,-36(fp)
  20294c:	10bfffc4 	addi	r2,r2,-1
  202950:	1884703a 	and	r2,r3,r2
  202954:	e0fff717 	ldw	r3,-36(fp)
  202958:	1885c83a 	sub	r2,r3,r2
  20295c:	e0fffe17 	ldw	r3,-8(fp)
  202960:	1885883a 	add	r2,r3,r2
  202964:	e0bffe15 	stw	r2,-8(fp)
  202968:	e0bff717 	ldw	r2,-36(fp)
  20296c:	10bfffc4 	addi	r2,r2,-1
  202970:	e0fffe17 	ldw	r3,-8(fp)
  202974:	1884703a 	and	r2,r3,r2
  202978:	e0bffe15 	stw	r2,-8(fp)
  20297c:	e0bffe17 	ldw	r2,-8(fp)
  202980:	100b883a 	mov	r5,r2
  202984:	e13ff417 	ldw	r4,-48(fp)
  202988:	0204b300 	call	204b30 <_sbrk_r>
  20298c:	e0bffd15 	stw	r2,-12(fp)
  202990:	e0bffd17 	ldw	r2,-12(fp)
  202994:	10bfffd8 	cmpnei	r2,r2,-1
  202998:	10000e1e 	bne	r2,zero,2029d4 <malloc_extend_top+0x254>
  20299c:	e03ffe15 	stw	zero,-8(fp)
  2029a0:	00800044 	movi	r2,1
  2029a4:	e0bffb15 	stw	r2,-20(fp)
  2029a8:	e0ffff17 	ldw	r3,-4(fp)
  2029ac:	e0bffc17 	ldw	r2,-16(fp)
  2029b0:	1885883a 	add	r2,r3,r2
  2029b4:	e0bffd15 	stw	r2,-12(fp)
  2029b8:	e0bff517 	ldw	r2,-44(fp)
  2029bc:	10000526 	beq	r2,zero,2029d4 <malloc_extend_top+0x254>
  2029c0:	e0bff517 	ldw	r2,-44(fp)
  2029c4:	10bffe04 	addi	r2,r2,-8
  2029c8:	e0fffd17 	ldw	r3,-12(fp)
  2029cc:	1885883a 	add	r2,r3,r2
  2029d0:	e0bffd15 	stw	r2,-12(fp)
  2029d4:	00800874 	movhi	r2,33
  2029d8:	10ac0017 	ldw	r2,-20480(r2)
  2029dc:	1007883a 	mov	r3,r2
  2029e0:	e0bffe17 	ldw	r2,-8(fp)
  2029e4:	1885883a 	add	r2,r3,r2
  2029e8:	1007883a 	mov	r3,r2
  2029ec:	00800874 	movhi	r2,33
  2029f0:	10ec0015 	stw	r3,-20480(r2)
  2029f4:	00800834 	movhi	r2,32
  2029f8:	109fd404 	addi	r2,r2,32592
  2029fc:	e0ffff17 	ldw	r3,-4(fp)
  202a00:	10c00215 	stw	r3,8(r2)
  202a04:	e0fffd17 	ldw	r3,-12(fp)
  202a08:	e0bfff17 	ldw	r2,-4(fp)
  202a0c:	1885c83a 	sub	r2,r3,r2
  202a10:	1007883a 	mov	r3,r2
  202a14:	e0bffe17 	ldw	r2,-8(fp)
  202a18:	10c5883a 	add	r2,r2,r3
  202a1c:	e0bff615 	stw	r2,-40(fp)
  202a20:	00800834 	movhi	r2,32
  202a24:	109fd404 	addi	r2,r2,32592
  202a28:	10800217 	ldw	r2,8(r2)
  202a2c:	e0fff617 	ldw	r3,-40(fp)
  202a30:	18c00054 	ori	r3,r3,1
  202a34:	10c00115 	stw	r3,4(r2)
  202a38:	00800834 	movhi	r2,32
  202a3c:	109fd404 	addi	r2,r2,32592
  202a40:	e0fffa17 	ldw	r3,-24(fp)
  202a44:	18802826 	beq	r3,r2,202ae8 <malloc_extend_top+0x368>
  202a48:	e0bff917 	ldw	r2,-28(fp)
  202a4c:	10800428 	cmpgeui	r2,r2,16
  202a50:	1000061e 	bne	r2,zero,202a6c <malloc_extend_top+0x2ec>
  202a54:	00800834 	movhi	r2,32
  202a58:	109fd404 	addi	r2,r2,32592
  202a5c:	10800217 	ldw	r2,8(r2)
  202a60:	00c00044 	movi	r3,1
  202a64:	10c00115 	stw	r3,4(r2)
  202a68:	00003106 	br	202b30 <malloc_extend_top+0x3b0>
  202a6c:	e0bff917 	ldw	r2,-28(fp)
  202a70:	10fffd04 	addi	r3,r2,-12
  202a74:	00bffe04 	movi	r2,-8
  202a78:	1884703a 	and	r2,r3,r2
  202a7c:	e0bff915 	stw	r2,-28(fp)
  202a80:	e0bffa17 	ldw	r2,-24(fp)
  202a84:	10800117 	ldw	r2,4(r2)
  202a88:	10c0004c 	andi	r3,r2,1
  202a8c:	e0bff917 	ldw	r2,-28(fp)
  202a90:	1886b03a 	or	r3,r3,r2
  202a94:	e0bffa17 	ldw	r2,-24(fp)
  202a98:	10c00115 	stw	r3,4(r2)
  202a9c:	e0fffa17 	ldw	r3,-24(fp)
  202aa0:	e0bff917 	ldw	r2,-28(fp)
  202aa4:	1885883a 	add	r2,r3,r2
  202aa8:	00c00144 	movi	r3,5
  202aac:	10c00115 	stw	r3,4(r2)
  202ab0:	e0bff917 	ldw	r2,-28(fp)
  202ab4:	10800104 	addi	r2,r2,4
  202ab8:	e0fffa17 	ldw	r3,-24(fp)
  202abc:	1885883a 	add	r2,r3,r2
  202ac0:	00c00144 	movi	r3,5
  202ac4:	10c00115 	stw	r3,4(r2)
  202ac8:	e0bff917 	ldw	r2,-28(fp)
  202acc:	10800430 	cmpltui	r2,r2,16
  202ad0:	1000051e 	bne	r2,zero,202ae8 <malloc_extend_top+0x368>
  202ad4:	e0bffa17 	ldw	r2,-24(fp)
  202ad8:	10800204 	addi	r2,r2,8
  202adc:	100b883a 	mov	r5,r2
  202ae0:	e13ff417 	ldw	r4,-48(fp)
  202ae4:	02020680 	call	202068 <_free_r>
  202ae8:	00800874 	movhi	r2,33
  202aec:	10ac0017 	ldw	r2,-20480(r2)
  202af0:	1007883a 	mov	r3,r2
  202af4:	d0a61d17 	ldw	r2,-26508(gp)
  202af8:	10c0032e 	bgeu	r2,r3,202b08 <malloc_extend_top+0x388>
  202afc:	00800874 	movhi	r2,33
  202b00:	10ac0017 	ldw	r2,-20480(r2)
  202b04:	d0a61d15 	stw	r2,-26508(gp)
  202b08:	00800874 	movhi	r2,33
  202b0c:	10ac0017 	ldw	r2,-20480(r2)
  202b10:	1007883a 	mov	r3,r2
  202b14:	d0a61e17 	ldw	r2,-26504(gp)
  202b18:	10c0052e 	bgeu	r2,r3,202b30 <malloc_extend_top+0x3b0>
  202b1c:	00800874 	movhi	r2,33
  202b20:	10ac0017 	ldw	r2,-20480(r2)
  202b24:	d0a61e15 	stw	r2,-26504(gp)
  202b28:	00000106 	br	202b30 <malloc_extend_top+0x3b0>
  202b2c:	0001883a 	nop
  202b30:	e037883a 	mov	sp,fp
  202b34:	dfc00117 	ldw	ra,4(sp)
  202b38:	df000017 	ldw	fp,0(sp)
  202b3c:	dec00204 	addi	sp,sp,8
  202b40:	f800283a 	ret

00202b44 <_malloc_r>:
  202b44:	deffef04 	addi	sp,sp,-68
  202b48:	dfc01015 	stw	ra,64(sp)
  202b4c:	df000f15 	stw	fp,60(sp)
  202b50:	df000f04 	addi	fp,sp,60
  202b54:	e13ff215 	stw	r4,-56(fp)
  202b58:	e17ff115 	stw	r5,-60(fp)
  202b5c:	e0bff117 	ldw	r2,-60(fp)
  202b60:	108002c4 	addi	r2,r2,11
  202b64:	108005f0 	cmpltui	r2,r2,23
  202b68:	1000051e 	bne	r2,zero,202b80 <_malloc_r+0x3c>
  202b6c:	e0bff117 	ldw	r2,-60(fp)
  202b70:	10c002c4 	addi	r3,r2,11
  202b74:	00bffe04 	movi	r2,-8
  202b78:	1884703a 	and	r2,r3,r2
  202b7c:	00000106 	br	202b84 <_malloc_r+0x40>
  202b80:	00800404 	movi	r2,16
  202b84:	e0bff615 	stw	r2,-40(fp)
  202b88:	e0bff617 	ldw	r2,-40(fp)
  202b8c:	10000316 	blt	r2,zero,202b9c <_malloc_r+0x58>
  202b90:	e0fff617 	ldw	r3,-40(fp)
  202b94:	e0bff117 	ldw	r2,-60(fp)
  202b98:	1880052e 	bgeu	r3,r2,202bb0 <_malloc_r+0x6c>
  202b9c:	e0bff217 	ldw	r2,-56(fp)
  202ba0:	00c00304 	movi	r3,12
  202ba4:	10c00015 	stw	r3,0(r2)
  202ba8:	0005883a 	mov	r2,zero
  202bac:	0002bb06 	br	20369c <_malloc_r+0xb58>
  202bb0:	e13ff217 	ldw	r4,-56(fp)
  202bb4:	02054880 	call	205488 <__malloc_lock>
  202bb8:	e0bff617 	ldw	r2,-40(fp)
  202bbc:	10807e28 	cmpgeui	r2,r2,504
  202bc0:	10003e1e 	bne	r2,zero,202cbc <_malloc_r+0x178>
  202bc4:	e0bff617 	ldw	r2,-40(fp)
  202bc8:	1004d0fa 	srli	r2,r2,3
  202bcc:	e0bffe15 	stw	r2,-8(fp)
  202bd0:	e0bffe17 	ldw	r2,-8(fp)
  202bd4:	10800044 	addi	r2,r2,1
  202bd8:	1085883a 	add	r2,r2,r2
  202bdc:	100690ba 	slli	r3,r2,2
  202be0:	00800834 	movhi	r2,32
  202be4:	109fd404 	addi	r2,r2,32592
  202be8:	1885883a 	add	r2,r3,r2
  202bec:	10bffe04 	addi	r2,r2,-8
  202bf0:	e0bff715 	stw	r2,-36(fp)
  202bf4:	e0bff717 	ldw	r2,-36(fp)
  202bf8:	10800317 	ldw	r2,12(r2)
  202bfc:	e0bfff15 	stw	r2,-4(fp)
  202c00:	e0ffff17 	ldw	r3,-4(fp)
  202c04:	e0bff717 	ldw	r2,-36(fp)
  202c08:	1880061e 	bne	r3,r2,202c24 <_malloc_r+0xe0>
  202c0c:	e0bff717 	ldw	r2,-36(fp)
  202c10:	10800204 	addi	r2,r2,8
  202c14:	e0bff715 	stw	r2,-36(fp)
  202c18:	e0bff717 	ldw	r2,-36(fp)
  202c1c:	10800317 	ldw	r2,12(r2)
  202c20:	e0bfff15 	stw	r2,-4(fp)
  202c24:	e0ffff17 	ldw	r3,-4(fp)
  202c28:	e0bff717 	ldw	r2,-36(fp)
  202c2c:	18801f26 	beq	r3,r2,202cac <_malloc_r+0x168>
  202c30:	e0bfff17 	ldw	r2,-4(fp)
  202c34:	10c00117 	ldw	r3,4(r2)
  202c38:	00bfff04 	movi	r2,-4
  202c3c:	1884703a 	and	r2,r3,r2
  202c40:	e0bff515 	stw	r2,-44(fp)
  202c44:	e0bfff17 	ldw	r2,-4(fp)
  202c48:	10800317 	ldw	r2,12(r2)
  202c4c:	e0bff815 	stw	r2,-32(fp)
  202c50:	e0bfff17 	ldw	r2,-4(fp)
  202c54:	10800217 	ldw	r2,8(r2)
  202c58:	e0bff915 	stw	r2,-28(fp)
  202c5c:	e0bff917 	ldw	r2,-28(fp)
  202c60:	e0fff817 	ldw	r3,-32(fp)
  202c64:	10c00315 	stw	r3,12(r2)
  202c68:	e0bff817 	ldw	r2,-32(fp)
  202c6c:	e0fff917 	ldw	r3,-28(fp)
  202c70:	10c00215 	stw	r3,8(r2)
  202c74:	e0ffff17 	ldw	r3,-4(fp)
  202c78:	e0bff517 	ldw	r2,-44(fp)
  202c7c:	1885883a 	add	r2,r3,r2
  202c80:	10c00117 	ldw	r3,4(r2)
  202c84:	e13fff17 	ldw	r4,-4(fp)
  202c88:	e0bff517 	ldw	r2,-44(fp)
  202c8c:	2085883a 	add	r2,r4,r2
  202c90:	18c00054 	ori	r3,r3,1
  202c94:	10c00115 	stw	r3,4(r2)
  202c98:	e13ff217 	ldw	r4,-56(fp)
  202c9c:	02054ac0 	call	2054ac <__malloc_unlock>
  202ca0:	e0bfff17 	ldw	r2,-4(fp)
  202ca4:	10800204 	addi	r2,r2,8
  202ca8:	00027c06 	br	20369c <_malloc_r+0xb58>
  202cac:	e0bffe17 	ldw	r2,-8(fp)
  202cb0:	10800084 	addi	r2,r2,2
  202cb4:	e0bffe15 	stw	r2,-8(fp)
  202cb8:	00007206 	br	202e84 <_malloc_r+0x340>
  202cbc:	e0bff617 	ldw	r2,-40(fp)
  202cc0:	1004d27a 	srli	r2,r2,9
  202cc4:	1000031e 	bne	r2,zero,202cd4 <_malloc_r+0x190>
  202cc8:	e0bff617 	ldw	r2,-40(fp)
  202ccc:	1004d0fa 	srli	r2,r2,3
  202cd0:	00002906 	br	202d78 <_malloc_r+0x234>
  202cd4:	e0bff617 	ldw	r2,-40(fp)
  202cd8:	1004d27a 	srli	r2,r2,9
  202cdc:	10800168 	cmpgeui	r2,r2,5
  202ce0:	1000041e 	bne	r2,zero,202cf4 <_malloc_r+0x1b0>
  202ce4:	e0bff617 	ldw	r2,-40(fp)
  202ce8:	1004d1ba 	srli	r2,r2,6
  202cec:	10800e04 	addi	r2,r2,56
  202cf0:	00002106 	br	202d78 <_malloc_r+0x234>
  202cf4:	e0bff617 	ldw	r2,-40(fp)
  202cf8:	1004d27a 	srli	r2,r2,9
  202cfc:	10800568 	cmpgeui	r2,r2,21
  202d00:	1000041e 	bne	r2,zero,202d14 <_malloc_r+0x1d0>
  202d04:	e0bff617 	ldw	r2,-40(fp)
  202d08:	1004d27a 	srli	r2,r2,9
  202d0c:	108016c4 	addi	r2,r2,91
  202d10:	00001906 	br	202d78 <_malloc_r+0x234>
  202d14:	e0bff617 	ldw	r2,-40(fp)
  202d18:	1004d27a 	srli	r2,r2,9
  202d1c:	10801568 	cmpgeui	r2,r2,85
  202d20:	1000041e 	bne	r2,zero,202d34 <_malloc_r+0x1f0>
  202d24:	e0bff617 	ldw	r2,-40(fp)
  202d28:	1004d33a 	srli	r2,r2,12
  202d2c:	10801b84 	addi	r2,r2,110
  202d30:	00001106 	br	202d78 <_malloc_r+0x234>
  202d34:	e0bff617 	ldw	r2,-40(fp)
  202d38:	1004d27a 	srli	r2,r2,9
  202d3c:	10805568 	cmpgeui	r2,r2,341
  202d40:	1000041e 	bne	r2,zero,202d54 <_malloc_r+0x210>
  202d44:	e0bff617 	ldw	r2,-40(fp)
  202d48:	1004d3fa 	srli	r2,r2,15
  202d4c:	10801dc4 	addi	r2,r2,119
  202d50:	00000906 	br	202d78 <_malloc_r+0x234>
  202d54:	e0bff617 	ldw	r2,-40(fp)
  202d58:	1004d27a 	srli	r2,r2,9
  202d5c:	10815568 	cmpgeui	r2,r2,1365
  202d60:	1000041e 	bne	r2,zero,202d74 <_malloc_r+0x230>
  202d64:	e0bff617 	ldw	r2,-40(fp)
  202d68:	1004d4ba 	srli	r2,r2,18
  202d6c:	10801f04 	addi	r2,r2,124
  202d70:	00000106 	br	202d78 <_malloc_r+0x234>
  202d74:	00801f84 	movi	r2,126
  202d78:	e0bffe15 	stw	r2,-8(fp)
  202d7c:	e0bffe17 	ldw	r2,-8(fp)
  202d80:	10800044 	addi	r2,r2,1
  202d84:	1085883a 	add	r2,r2,r2
  202d88:	100690ba 	slli	r3,r2,2
  202d8c:	00800834 	movhi	r2,32
  202d90:	109fd404 	addi	r2,r2,32592
  202d94:	1885883a 	add	r2,r3,r2
  202d98:	10bffe04 	addi	r2,r2,-8
  202d9c:	e0bffd15 	stw	r2,-12(fp)
  202da0:	e0bffd17 	ldw	r2,-12(fp)
  202da4:	10800317 	ldw	r2,12(r2)
  202da8:	e0bfff15 	stw	r2,-4(fp)
  202dac:	00002f06 	br	202e6c <_malloc_r+0x328>
  202db0:	e0bfff17 	ldw	r2,-4(fp)
  202db4:	10c00117 	ldw	r3,4(r2)
  202db8:	00bfff04 	movi	r2,-4
  202dbc:	1884703a 	and	r2,r3,r2
  202dc0:	e0bff515 	stw	r2,-44(fp)
  202dc4:	e0fff517 	ldw	r3,-44(fp)
  202dc8:	e0bff617 	ldw	r2,-40(fp)
  202dcc:	1885c83a 	sub	r2,r3,r2
  202dd0:	e0bffc15 	stw	r2,-16(fp)
  202dd4:	e0bffc17 	ldw	r2,-16(fp)
  202dd8:	10800410 	cmplti	r2,r2,16
  202ddc:	1000041e 	bne	r2,zero,202df0 <_malloc_r+0x2ac>
  202de0:	e0bffe17 	ldw	r2,-8(fp)
  202de4:	10bfffc4 	addi	r2,r2,-1
  202de8:	e0bffe15 	stw	r2,-8(fp)
  202dec:	00002206 	br	202e78 <_malloc_r+0x334>
  202df0:	e0bffc17 	ldw	r2,-16(fp)
  202df4:	10001a16 	blt	r2,zero,202e60 <_malloc_r+0x31c>
  202df8:	e0bfff17 	ldw	r2,-4(fp)
  202dfc:	10800317 	ldw	r2,12(r2)
  202e00:	e0bff815 	stw	r2,-32(fp)
  202e04:	e0bfff17 	ldw	r2,-4(fp)
  202e08:	10800217 	ldw	r2,8(r2)
  202e0c:	e0bff915 	stw	r2,-28(fp)
  202e10:	e0bff917 	ldw	r2,-28(fp)
  202e14:	e0fff817 	ldw	r3,-32(fp)
  202e18:	10c00315 	stw	r3,12(r2)
  202e1c:	e0bff817 	ldw	r2,-32(fp)
  202e20:	e0fff917 	ldw	r3,-28(fp)
  202e24:	10c00215 	stw	r3,8(r2)
  202e28:	e0ffff17 	ldw	r3,-4(fp)
  202e2c:	e0bff517 	ldw	r2,-44(fp)
  202e30:	1885883a 	add	r2,r3,r2
  202e34:	10c00117 	ldw	r3,4(r2)
  202e38:	e13fff17 	ldw	r4,-4(fp)
  202e3c:	e0bff517 	ldw	r2,-44(fp)
  202e40:	2085883a 	add	r2,r4,r2
  202e44:	18c00054 	ori	r3,r3,1
  202e48:	10c00115 	stw	r3,4(r2)
  202e4c:	e13ff217 	ldw	r4,-56(fp)
  202e50:	02054ac0 	call	2054ac <__malloc_unlock>
  202e54:	e0bfff17 	ldw	r2,-4(fp)
  202e58:	10800204 	addi	r2,r2,8
  202e5c:	00020f06 	br	20369c <_malloc_r+0xb58>
  202e60:	e0bfff17 	ldw	r2,-4(fp)
  202e64:	10800317 	ldw	r2,12(r2)
  202e68:	e0bfff15 	stw	r2,-4(fp)
  202e6c:	e0ffff17 	ldw	r3,-4(fp)
  202e70:	e0bffd17 	ldw	r2,-12(fp)
  202e74:	18bfce1e 	bne	r3,r2,202db0 <_malloc_r+0x26c>
  202e78:	e0bffe17 	ldw	r2,-8(fp)
  202e7c:	10800044 	addi	r2,r2,1
  202e80:	e0bffe15 	stw	r2,-8(fp)
  202e84:	00800834 	movhi	r2,32
  202e88:	109fd604 	addi	r2,r2,32600
  202e8c:	10800217 	ldw	r2,8(r2)
  202e90:	e0bfff15 	stw	r2,-4(fp)
  202e94:	00800834 	movhi	r2,32
  202e98:	109fd604 	addi	r2,r2,32600
  202e9c:	e0ffff17 	ldw	r3,-4(fp)
  202ea0:	1880e426 	beq	r3,r2,203234 <_malloc_r+0x6f0>
  202ea4:	e0bfff17 	ldw	r2,-4(fp)
  202ea8:	10c00117 	ldw	r3,4(r2)
  202eac:	00bfff04 	movi	r2,-4
  202eb0:	1884703a 	and	r2,r3,r2
  202eb4:	e0bff515 	stw	r2,-44(fp)
  202eb8:	e0fff517 	ldw	r3,-44(fp)
  202ebc:	e0bff617 	ldw	r2,-40(fp)
  202ec0:	1885c83a 	sub	r2,r3,r2
  202ec4:	e0bffc15 	stw	r2,-16(fp)
  202ec8:	e0bffc17 	ldw	r2,-16(fp)
  202ecc:	10800410 	cmplti	r2,r2,16
  202ed0:	1000271e 	bne	r2,zero,202f70 <_malloc_r+0x42c>
  202ed4:	e0ffff17 	ldw	r3,-4(fp)
  202ed8:	e0bff617 	ldw	r2,-40(fp)
  202edc:	1885883a 	add	r2,r3,r2
  202ee0:	e0bff315 	stw	r2,-52(fp)
  202ee4:	e0bff617 	ldw	r2,-40(fp)
  202ee8:	10c00054 	ori	r3,r2,1
  202eec:	e0bfff17 	ldw	r2,-4(fp)
  202ef0:	10c00115 	stw	r3,4(r2)
  202ef4:	00800834 	movhi	r2,32
  202ef8:	109fd604 	addi	r2,r2,32600
  202efc:	e0fff317 	ldw	r3,-52(fp)
  202f00:	10c00315 	stw	r3,12(r2)
  202f04:	00c00834 	movhi	r3,32
  202f08:	18dfd604 	addi	r3,r3,32600
  202f0c:	10800317 	ldw	r2,12(r2)
  202f10:	18800215 	stw	r2,8(r3)
  202f14:	00800834 	movhi	r2,32
  202f18:	109fd604 	addi	r2,r2,32600
  202f1c:	e0fff317 	ldw	r3,-52(fp)
  202f20:	18800315 	stw	r2,12(r3)
  202f24:	e0bff317 	ldw	r2,-52(fp)
  202f28:	10c00317 	ldw	r3,12(r2)
  202f2c:	e0bff317 	ldw	r2,-52(fp)
  202f30:	10c00215 	stw	r3,8(r2)
  202f34:	e0bffc17 	ldw	r2,-16(fp)
  202f38:	10800054 	ori	r2,r2,1
  202f3c:	1007883a 	mov	r3,r2
  202f40:	e0bff317 	ldw	r2,-52(fp)
  202f44:	10c00115 	stw	r3,4(r2)
  202f48:	e0bffc17 	ldw	r2,-16(fp)
  202f4c:	e0fff317 	ldw	r3,-52(fp)
  202f50:	1885883a 	add	r2,r3,r2
  202f54:	e0fffc17 	ldw	r3,-16(fp)
  202f58:	10c00015 	stw	r3,0(r2)
  202f5c:	e13ff217 	ldw	r4,-56(fp)
  202f60:	02054ac0 	call	2054ac <__malloc_unlock>
  202f64:	e0bfff17 	ldw	r2,-4(fp)
  202f68:	10800204 	addi	r2,r2,8
  202f6c:	0001cb06 	br	20369c <_malloc_r+0xb58>
  202f70:	00800834 	movhi	r2,32
  202f74:	109fd604 	addi	r2,r2,32600
  202f78:	00c00834 	movhi	r3,32
  202f7c:	18dfd604 	addi	r3,r3,32600
  202f80:	10c00315 	stw	r3,12(r2)
  202f84:	00c00834 	movhi	r3,32
  202f88:	18dfd604 	addi	r3,r3,32600
  202f8c:	10800317 	ldw	r2,12(r2)
  202f90:	18800215 	stw	r2,8(r3)
  202f94:	e0bffc17 	ldw	r2,-16(fp)
  202f98:	10000e16 	blt	r2,zero,202fd4 <_malloc_r+0x490>
  202f9c:	e0ffff17 	ldw	r3,-4(fp)
  202fa0:	e0bff517 	ldw	r2,-44(fp)
  202fa4:	1885883a 	add	r2,r3,r2
  202fa8:	10c00117 	ldw	r3,4(r2)
  202fac:	e13fff17 	ldw	r4,-4(fp)
  202fb0:	e0bff517 	ldw	r2,-44(fp)
  202fb4:	2085883a 	add	r2,r4,r2
  202fb8:	18c00054 	ori	r3,r3,1
  202fbc:	10c00115 	stw	r3,4(r2)
  202fc0:	e13ff217 	ldw	r4,-56(fp)
  202fc4:	02054ac0 	call	2054ac <__malloc_unlock>
  202fc8:	e0bfff17 	ldw	r2,-4(fp)
  202fcc:	10800204 	addi	r2,r2,8
  202fd0:	0001b206 	br	20369c <_malloc_r+0xb58>
  202fd4:	e0bff517 	ldw	r2,-44(fp)
  202fd8:	10808028 	cmpgeui	r2,r2,512
  202fdc:	10002b1e 	bne	r2,zero,20308c <_malloc_r+0x548>
  202fe0:	e0bff517 	ldw	r2,-44(fp)
  202fe4:	1004d0fa 	srli	r2,r2,3
  202fe8:	e0bff415 	stw	r2,-48(fp)
  202fec:	00800834 	movhi	r2,32
  202ff0:	109fd404 	addi	r2,r2,32592
  202ff4:	11000117 	ldw	r4,4(r2)
  202ff8:	e0bff417 	ldw	r2,-48(fp)
  202ffc:	1000010e 	bge	r2,zero,203004 <_malloc_r+0x4c0>
  203000:	108000c4 	addi	r2,r2,3
  203004:	1005d0ba 	srai	r2,r2,2
  203008:	1007883a 	mov	r3,r2
  20300c:	00800044 	movi	r2,1
  203010:	10c6983a 	sll	r3,r2,r3
  203014:	00800834 	movhi	r2,32
  203018:	109fd404 	addi	r2,r2,32592
  20301c:	20c6b03a 	or	r3,r4,r3
  203020:	10c00115 	stw	r3,4(r2)
  203024:	e0bff417 	ldw	r2,-48(fp)
  203028:	10800044 	addi	r2,r2,1
  20302c:	1085883a 	add	r2,r2,r2
  203030:	100690ba 	slli	r3,r2,2
  203034:	00800834 	movhi	r2,32
  203038:	109fd404 	addi	r2,r2,32592
  20303c:	1885883a 	add	r2,r3,r2
  203040:	10bffe04 	addi	r2,r2,-8
  203044:	e0bff815 	stw	r2,-32(fp)
  203048:	e0bff817 	ldw	r2,-32(fp)
  20304c:	10800217 	ldw	r2,8(r2)
  203050:	e0bff915 	stw	r2,-28(fp)
  203054:	e0bfff17 	ldw	r2,-4(fp)
  203058:	e0fff817 	ldw	r3,-32(fp)
  20305c:	10c00315 	stw	r3,12(r2)
  203060:	e0bfff17 	ldw	r2,-4(fp)
  203064:	e0fff917 	ldw	r3,-28(fp)
  203068:	10c00215 	stw	r3,8(r2)
  20306c:	e0bff817 	ldw	r2,-32(fp)
  203070:	e0ffff17 	ldw	r3,-4(fp)
  203074:	10c00215 	stw	r3,8(r2)
  203078:	e0bff817 	ldw	r2,-32(fp)
  20307c:	10c00217 	ldw	r3,8(r2)
  203080:	e0bff917 	ldw	r2,-28(fp)
  203084:	10c00315 	stw	r3,12(r2)
  203088:	00006a06 	br	203234 <_malloc_r+0x6f0>
  20308c:	e0bff517 	ldw	r2,-44(fp)
  203090:	1004d27a 	srli	r2,r2,9
  203094:	1000031e 	bne	r2,zero,2030a4 <_malloc_r+0x560>
  203098:	e0bff517 	ldw	r2,-44(fp)
  20309c:	1004d0fa 	srli	r2,r2,3
  2030a0:	00002906 	br	203148 <_malloc_r+0x604>
  2030a4:	e0bff517 	ldw	r2,-44(fp)
  2030a8:	1004d27a 	srli	r2,r2,9
  2030ac:	10800168 	cmpgeui	r2,r2,5
  2030b0:	1000041e 	bne	r2,zero,2030c4 <_malloc_r+0x580>
  2030b4:	e0bff517 	ldw	r2,-44(fp)
  2030b8:	1004d1ba 	srli	r2,r2,6
  2030bc:	10800e04 	addi	r2,r2,56
  2030c0:	00002106 	br	203148 <_malloc_r+0x604>
  2030c4:	e0bff517 	ldw	r2,-44(fp)
  2030c8:	1004d27a 	srli	r2,r2,9
  2030cc:	10800568 	cmpgeui	r2,r2,21
  2030d0:	1000041e 	bne	r2,zero,2030e4 <_malloc_r+0x5a0>
  2030d4:	e0bff517 	ldw	r2,-44(fp)
  2030d8:	1004d27a 	srli	r2,r2,9
  2030dc:	108016c4 	addi	r2,r2,91
  2030e0:	00001906 	br	203148 <_malloc_r+0x604>
  2030e4:	e0bff517 	ldw	r2,-44(fp)
  2030e8:	1004d27a 	srli	r2,r2,9
  2030ec:	10801568 	cmpgeui	r2,r2,85
  2030f0:	1000041e 	bne	r2,zero,203104 <_malloc_r+0x5c0>
  2030f4:	e0bff517 	ldw	r2,-44(fp)
  2030f8:	1004d33a 	srli	r2,r2,12
  2030fc:	10801b84 	addi	r2,r2,110
  203100:	00001106 	br	203148 <_malloc_r+0x604>
  203104:	e0bff517 	ldw	r2,-44(fp)
  203108:	1004d27a 	srli	r2,r2,9
  20310c:	10805568 	cmpgeui	r2,r2,341
  203110:	1000041e 	bne	r2,zero,203124 <_malloc_r+0x5e0>
  203114:	e0bff517 	ldw	r2,-44(fp)
  203118:	1004d3fa 	srli	r2,r2,15
  20311c:	10801dc4 	addi	r2,r2,119
  203120:	00000906 	br	203148 <_malloc_r+0x604>
  203124:	e0bff517 	ldw	r2,-44(fp)
  203128:	1004d27a 	srli	r2,r2,9
  20312c:	10815568 	cmpgeui	r2,r2,1365
  203130:	1000041e 	bne	r2,zero,203144 <_malloc_r+0x600>
  203134:	e0bff517 	ldw	r2,-44(fp)
  203138:	1004d4ba 	srli	r2,r2,18
  20313c:	10801f04 	addi	r2,r2,124
  203140:	00000106 	br	203148 <_malloc_r+0x604>
  203144:	00801f84 	movi	r2,126
  203148:	e0bff415 	stw	r2,-48(fp)
  20314c:	e0bff417 	ldw	r2,-48(fp)
  203150:	10800044 	addi	r2,r2,1
  203154:	1085883a 	add	r2,r2,r2
  203158:	100690ba 	slli	r3,r2,2
  20315c:	00800834 	movhi	r2,32
  203160:	109fd404 	addi	r2,r2,32592
  203164:	1885883a 	add	r2,r3,r2
  203168:	10bffe04 	addi	r2,r2,-8
  20316c:	e0bff815 	stw	r2,-32(fp)
  203170:	e0bff817 	ldw	r2,-32(fp)
  203174:	10800217 	ldw	r2,8(r2)
  203178:	e0bff915 	stw	r2,-28(fp)
  20317c:	e0fff917 	ldw	r3,-28(fp)
  203180:	e0bff817 	ldw	r2,-32(fp)
  203184:	1880121e 	bne	r3,r2,2031d0 <_malloc_r+0x68c>
  203188:	00800834 	movhi	r2,32
  20318c:	109fd404 	addi	r2,r2,32592
  203190:	11000117 	ldw	r4,4(r2)
  203194:	e0bff417 	ldw	r2,-48(fp)
  203198:	1000010e 	bge	r2,zero,2031a0 <_malloc_r+0x65c>
  20319c:	108000c4 	addi	r2,r2,3
  2031a0:	1005d0ba 	srai	r2,r2,2
  2031a4:	1007883a 	mov	r3,r2
  2031a8:	00800044 	movi	r2,1
  2031ac:	10c6983a 	sll	r3,r2,r3
  2031b0:	00800834 	movhi	r2,32
  2031b4:	109fd404 	addi	r2,r2,32592
  2031b8:	20c6b03a 	or	r3,r4,r3
  2031bc:	10c00115 	stw	r3,4(r2)
  2031c0:	00000f06 	br	203200 <_malloc_r+0x6bc>
  2031c4:	e0bff917 	ldw	r2,-28(fp)
  2031c8:	10800217 	ldw	r2,8(r2)
  2031cc:	e0bff915 	stw	r2,-28(fp)
  2031d0:	e0fff917 	ldw	r3,-28(fp)
  2031d4:	e0bff817 	ldw	r2,-32(fp)
  2031d8:	18800626 	beq	r3,r2,2031f4 <_malloc_r+0x6b0>
  2031dc:	e0bff917 	ldw	r2,-28(fp)
  2031e0:	10c00117 	ldw	r3,4(r2)
  2031e4:	00bfff04 	movi	r2,-4
  2031e8:	1884703a 	and	r2,r3,r2
  2031ec:	e0fff517 	ldw	r3,-44(fp)
  2031f0:	18bff436 	bltu	r3,r2,2031c4 <_malloc_r+0x680>
  2031f4:	e0bff917 	ldw	r2,-28(fp)
  2031f8:	10800317 	ldw	r2,12(r2)
  2031fc:	e0bff815 	stw	r2,-32(fp)
  203200:	e0bfff17 	ldw	r2,-4(fp)
  203204:	e0fff817 	ldw	r3,-32(fp)
  203208:	10c00315 	stw	r3,12(r2)
  20320c:	e0bfff17 	ldw	r2,-4(fp)
  203210:	e0fff917 	ldw	r3,-28(fp)
  203214:	10c00215 	stw	r3,8(r2)
  203218:	e0bff817 	ldw	r2,-32(fp)
  20321c:	e0ffff17 	ldw	r3,-4(fp)
  203220:	10c00215 	stw	r3,8(r2)
  203224:	e0bff817 	ldw	r2,-32(fp)
  203228:	10c00217 	ldw	r3,8(r2)
  20322c:	e0bff917 	ldw	r2,-28(fp)
  203230:	10c00315 	stw	r3,12(r2)
  203234:	e0bffe17 	ldw	r2,-8(fp)
  203238:	1000010e 	bge	r2,zero,203240 <_malloc_r+0x6fc>
  20323c:	108000c4 	addi	r2,r2,3
  203240:	1005d0ba 	srai	r2,r2,2
  203244:	1007883a 	mov	r3,r2
  203248:	00800044 	movi	r2,1
  20324c:	10c4983a 	sll	r2,r2,r3
  203250:	e0bffb15 	stw	r2,-20(fp)
  203254:	00800834 	movhi	r2,32
  203258:	109fd404 	addi	r2,r2,32592
  20325c:	10c00117 	ldw	r3,4(r2)
  203260:	e0bffb17 	ldw	r2,-20(fp)
  203264:	1880c636 	bltu	r3,r2,203580 <_malloc_r+0xa3c>
  203268:	00800834 	movhi	r2,32
  20326c:	109fd404 	addi	r2,r2,32592
  203270:	10c00117 	ldw	r3,4(r2)
  203274:	e0bffb17 	ldw	r2,-20(fp)
  203278:	1884703a 	and	r2,r3,r2
  20327c:	10000126 	beq	r2,zero,203284 <_malloc_r+0x740>
  203280:	00001506 	br	2032d8 <_malloc_r+0x794>
  203284:	e0fffe17 	ldw	r3,-8(fp)
  203288:	00bfff04 	movi	r2,-4
  20328c:	1884703a 	and	r2,r3,r2
  203290:	10800104 	addi	r2,r2,4
  203294:	e0bffe15 	stw	r2,-8(fp)
  203298:	e0bffb17 	ldw	r2,-20(fp)
  20329c:	1085883a 	add	r2,r2,r2
  2032a0:	e0bffb15 	stw	r2,-20(fp)
  2032a4:	00000606 	br	2032c0 <_malloc_r+0x77c>
  2032a8:	e0bffe17 	ldw	r2,-8(fp)
  2032ac:	10800104 	addi	r2,r2,4
  2032b0:	e0bffe15 	stw	r2,-8(fp)
  2032b4:	e0bffb17 	ldw	r2,-20(fp)
  2032b8:	1085883a 	add	r2,r2,r2
  2032bc:	e0bffb15 	stw	r2,-20(fp)
  2032c0:	00800834 	movhi	r2,32
  2032c4:	109fd404 	addi	r2,r2,32592
  2032c8:	10c00117 	ldw	r3,4(r2)
  2032cc:	e0bffb17 	ldw	r2,-20(fp)
  2032d0:	1884703a 	and	r2,r3,r2
  2032d4:	103ff426 	beq	r2,zero,2032a8 <_malloc_r+0x764>
  2032d8:	e0bffe17 	ldw	r2,-8(fp)
  2032dc:	e0bffa15 	stw	r2,-24(fp)
  2032e0:	e0bffe17 	ldw	r2,-8(fp)
  2032e4:	10800044 	addi	r2,r2,1
  2032e8:	1085883a 	add	r2,r2,r2
  2032ec:	100690ba 	slli	r3,r2,2
  2032f0:	00800834 	movhi	r2,32
  2032f4:	109fd404 	addi	r2,r2,32592
  2032f8:	1885883a 	add	r2,r3,r2
  2032fc:	10bffe04 	addi	r2,r2,-8
  203300:	e0bffd15 	stw	r2,-12(fp)
  203304:	e0bffd17 	ldw	r2,-12(fp)
  203308:	e0bff715 	stw	r2,-36(fp)
  20330c:	e0bffd17 	ldw	r2,-12(fp)
  203310:	10800317 	ldw	r2,12(r2)
  203314:	e0bfff15 	stw	r2,-4(fp)
  203318:	00005e06 	br	203494 <_malloc_r+0x950>
  20331c:	e0bfff17 	ldw	r2,-4(fp)
  203320:	10c00117 	ldw	r3,4(r2)
  203324:	00bfff04 	movi	r2,-4
  203328:	1884703a 	and	r2,r3,r2
  20332c:	e0bff515 	stw	r2,-44(fp)
  203330:	e0fff517 	ldw	r3,-44(fp)
  203334:	e0bff617 	ldw	r2,-40(fp)
  203338:	1885c83a 	sub	r2,r3,r2
  20333c:	e0bffc15 	stw	r2,-16(fp)
  203340:	e0bffc17 	ldw	r2,-16(fp)
  203344:	10800410 	cmplti	r2,r2,16
  203348:	1000331e 	bne	r2,zero,203418 <_malloc_r+0x8d4>
  20334c:	e0ffff17 	ldw	r3,-4(fp)
  203350:	e0bff617 	ldw	r2,-40(fp)
  203354:	1885883a 	add	r2,r3,r2
  203358:	e0bff315 	stw	r2,-52(fp)
  20335c:	e0bff617 	ldw	r2,-40(fp)
  203360:	10c00054 	ori	r3,r2,1
  203364:	e0bfff17 	ldw	r2,-4(fp)
  203368:	10c00115 	stw	r3,4(r2)
  20336c:	e0bfff17 	ldw	r2,-4(fp)
  203370:	10800317 	ldw	r2,12(r2)
  203374:	e0bff815 	stw	r2,-32(fp)
  203378:	e0bfff17 	ldw	r2,-4(fp)
  20337c:	10800217 	ldw	r2,8(r2)
  203380:	e0bff915 	stw	r2,-28(fp)
  203384:	e0bff917 	ldw	r2,-28(fp)
  203388:	e0fff817 	ldw	r3,-32(fp)
  20338c:	10c00315 	stw	r3,12(r2)
  203390:	e0bff817 	ldw	r2,-32(fp)
  203394:	e0fff917 	ldw	r3,-28(fp)
  203398:	10c00215 	stw	r3,8(r2)
  20339c:	00800834 	movhi	r2,32
  2033a0:	109fd604 	addi	r2,r2,32600
  2033a4:	e0fff317 	ldw	r3,-52(fp)
  2033a8:	10c00315 	stw	r3,12(r2)
  2033ac:	00c00834 	movhi	r3,32
  2033b0:	18dfd604 	addi	r3,r3,32600
  2033b4:	10800317 	ldw	r2,12(r2)
  2033b8:	18800215 	stw	r2,8(r3)
  2033bc:	00800834 	movhi	r2,32
  2033c0:	109fd604 	addi	r2,r2,32600
  2033c4:	e0fff317 	ldw	r3,-52(fp)
  2033c8:	18800315 	stw	r2,12(r3)
  2033cc:	e0bff317 	ldw	r2,-52(fp)
  2033d0:	10c00317 	ldw	r3,12(r2)
  2033d4:	e0bff317 	ldw	r2,-52(fp)
  2033d8:	10c00215 	stw	r3,8(r2)
  2033dc:	e0bffc17 	ldw	r2,-16(fp)
  2033e0:	10800054 	ori	r2,r2,1
  2033e4:	1007883a 	mov	r3,r2
  2033e8:	e0bff317 	ldw	r2,-52(fp)
  2033ec:	10c00115 	stw	r3,4(r2)
  2033f0:	e0bffc17 	ldw	r2,-16(fp)
  2033f4:	e0fff317 	ldw	r3,-52(fp)
  2033f8:	1885883a 	add	r2,r3,r2
  2033fc:	e0fffc17 	ldw	r3,-16(fp)
  203400:	10c00015 	stw	r3,0(r2)
  203404:	e13ff217 	ldw	r4,-56(fp)
  203408:	02054ac0 	call	2054ac <__malloc_unlock>
  20340c:	e0bfff17 	ldw	r2,-4(fp)
  203410:	10800204 	addi	r2,r2,8
  203414:	0000a106 	br	20369c <_malloc_r+0xb58>
  203418:	e0bffc17 	ldw	r2,-16(fp)
  20341c:	10001a16 	blt	r2,zero,203488 <_malloc_r+0x944>
  203420:	e0ffff17 	ldw	r3,-4(fp)
  203424:	e0bff517 	ldw	r2,-44(fp)
  203428:	1885883a 	add	r2,r3,r2
  20342c:	10c00117 	ldw	r3,4(r2)
  203430:	e13fff17 	ldw	r4,-4(fp)
  203434:	e0bff517 	ldw	r2,-44(fp)
  203438:	2085883a 	add	r2,r4,r2
  20343c:	18c00054 	ori	r3,r3,1
  203440:	10c00115 	stw	r3,4(r2)
  203444:	e0bfff17 	ldw	r2,-4(fp)
  203448:	10800317 	ldw	r2,12(r2)
  20344c:	e0bff815 	stw	r2,-32(fp)
  203450:	e0bfff17 	ldw	r2,-4(fp)
  203454:	10800217 	ldw	r2,8(r2)
  203458:	e0bff915 	stw	r2,-28(fp)
  20345c:	e0bff917 	ldw	r2,-28(fp)
  203460:	e0fff817 	ldw	r3,-32(fp)
  203464:	10c00315 	stw	r3,12(r2)
  203468:	e0bff817 	ldw	r2,-32(fp)
  20346c:	e0fff917 	ldw	r3,-28(fp)
  203470:	10c00215 	stw	r3,8(r2)
  203474:	e13ff217 	ldw	r4,-56(fp)
  203478:	02054ac0 	call	2054ac <__malloc_unlock>
  20347c:	e0bfff17 	ldw	r2,-4(fp)
  203480:	10800204 	addi	r2,r2,8
  203484:	00008506 	br	20369c <_malloc_r+0xb58>
  203488:	e0bfff17 	ldw	r2,-4(fp)
  20348c:	10800317 	ldw	r2,12(r2)
  203490:	e0bfff15 	stw	r2,-4(fp)
  203494:	e0ffff17 	ldw	r3,-4(fp)
  203498:	e0bffd17 	ldw	r2,-12(fp)
  20349c:	18bf9f1e 	bne	r3,r2,20331c <_malloc_r+0x7d8>
  2034a0:	e0bffd17 	ldw	r2,-12(fp)
  2034a4:	10800204 	addi	r2,r2,8
  2034a8:	e0bffd15 	stw	r2,-12(fp)
  2034ac:	e0bffe17 	ldw	r2,-8(fp)
  2034b0:	10800044 	addi	r2,r2,1
  2034b4:	e0bffe15 	stw	r2,-8(fp)
  2034b8:	e0bffe17 	ldw	r2,-8(fp)
  2034bc:	108000cc 	andi	r2,r2,3
  2034c0:	103f921e 	bne	r2,zero,20330c <_malloc_r+0x7c8>
  2034c4:	e0bffa17 	ldw	r2,-24(fp)
  2034c8:	108000cc 	andi	r2,r2,3
  2034cc:	10000a1e 	bne	r2,zero,2034f8 <_malloc_r+0x9b4>
  2034d0:	00800834 	movhi	r2,32
  2034d4:	109fd404 	addi	r2,r2,32592
  2034d8:	11000117 	ldw	r4,4(r2)
  2034dc:	e0bffb17 	ldw	r2,-20(fp)
  2034e0:	0086303a 	nor	r3,zero,r2
  2034e4:	00800834 	movhi	r2,32
  2034e8:	109fd404 	addi	r2,r2,32592
  2034ec:	20c6703a 	and	r3,r4,r3
  2034f0:	10c00115 	stw	r3,4(r2)
  2034f4:	00000a06 	br	203520 <_malloc_r+0x9dc>
  2034f8:	e0bffa17 	ldw	r2,-24(fp)
  2034fc:	10bfffc4 	addi	r2,r2,-1
  203500:	e0bffa15 	stw	r2,-24(fp)
  203504:	e0bff717 	ldw	r2,-36(fp)
  203508:	10bffe04 	addi	r2,r2,-8
  20350c:	e0bff715 	stw	r2,-36(fp)
  203510:	e0bff717 	ldw	r2,-36(fp)
  203514:	10800217 	ldw	r2,8(r2)
  203518:	e0fff717 	ldw	r3,-36(fp)
  20351c:	18bfe926 	beq	r3,r2,2034c4 <_malloc_r+0x980>
  203520:	e0bffb17 	ldw	r2,-20(fp)
  203524:	1085883a 	add	r2,r2,r2
  203528:	e0bffb15 	stw	r2,-20(fp)
  20352c:	00800834 	movhi	r2,32
  203530:	109fd404 	addi	r2,r2,32592
  203534:	10c00117 	ldw	r3,4(r2)
  203538:	e0bffb17 	ldw	r2,-20(fp)
  20353c:	18801036 	bltu	r3,r2,203580 <_malloc_r+0xa3c>
  203540:	e0bffb17 	ldw	r2,-20(fp)
  203544:	10000e26 	beq	r2,zero,203580 <_malloc_r+0xa3c>
  203548:	00000606 	br	203564 <_malloc_r+0xa20>
  20354c:	e0bffe17 	ldw	r2,-8(fp)
  203550:	10800104 	addi	r2,r2,4
  203554:	e0bffe15 	stw	r2,-8(fp)
  203558:	e0bffb17 	ldw	r2,-20(fp)
  20355c:	1085883a 	add	r2,r2,r2
  203560:	e0bffb15 	stw	r2,-20(fp)
  203564:	00800834 	movhi	r2,32
  203568:	109fd404 	addi	r2,r2,32592
  20356c:	10c00117 	ldw	r3,4(r2)
  203570:	e0bffb17 	ldw	r2,-20(fp)
  203574:	1884703a 	and	r2,r3,r2
  203578:	103ff426 	beq	r2,zero,20354c <_malloc_r+0xa08>
  20357c:	003f5606 	br	2032d8 <_malloc_r+0x794>
  203580:	00800834 	movhi	r2,32
  203584:	109fd404 	addi	r2,r2,32592
  203588:	10800217 	ldw	r2,8(r2)
  20358c:	10c00117 	ldw	r3,4(r2)
  203590:	00bfff04 	movi	r2,-4
  203594:	1886703a 	and	r3,r3,r2
  203598:	e0bff617 	ldw	r2,-40(fp)
  20359c:	1885c83a 	sub	r2,r3,r2
  2035a0:	e0bffc15 	stw	r2,-16(fp)
  2035a4:	00800834 	movhi	r2,32
  2035a8:	109fd404 	addi	r2,r2,32592
  2035ac:	10800217 	ldw	r2,8(r2)
  2035b0:	10c00117 	ldw	r3,4(r2)
  2035b4:	00bfff04 	movi	r2,-4
  2035b8:	1886703a 	and	r3,r3,r2
  2035bc:	e0bff617 	ldw	r2,-40(fp)
  2035c0:	18800336 	bltu	r3,r2,2035d0 <_malloc_r+0xa8c>
  2035c4:	e0bffc17 	ldw	r2,-16(fp)
  2035c8:	10800408 	cmpgei	r2,r2,16
  2035cc:	10001b1e 	bne	r2,zero,20363c <_malloc_r+0xaf8>
  2035d0:	e17ff617 	ldw	r5,-40(fp)
  2035d4:	e13ff217 	ldw	r4,-56(fp)
  2035d8:	02027800 	call	202780 <malloc_extend_top>
  2035dc:	00800834 	movhi	r2,32
  2035e0:	109fd404 	addi	r2,r2,32592
  2035e4:	10800217 	ldw	r2,8(r2)
  2035e8:	10c00117 	ldw	r3,4(r2)
  2035ec:	00bfff04 	movi	r2,-4
  2035f0:	1886703a 	and	r3,r3,r2
  2035f4:	e0bff617 	ldw	r2,-40(fp)
  2035f8:	1885c83a 	sub	r2,r3,r2
  2035fc:	e0bffc15 	stw	r2,-16(fp)
  203600:	00800834 	movhi	r2,32
  203604:	109fd404 	addi	r2,r2,32592
  203608:	10800217 	ldw	r2,8(r2)
  20360c:	10c00117 	ldw	r3,4(r2)
  203610:	00bfff04 	movi	r2,-4
  203614:	1886703a 	and	r3,r3,r2
  203618:	e0bff617 	ldw	r2,-40(fp)
  20361c:	18800336 	bltu	r3,r2,20362c <_malloc_r+0xae8>
  203620:	e0bffc17 	ldw	r2,-16(fp)
  203624:	10800408 	cmpgei	r2,r2,16
  203628:	1000041e 	bne	r2,zero,20363c <_malloc_r+0xaf8>
  20362c:	e13ff217 	ldw	r4,-56(fp)
  203630:	02054ac0 	call	2054ac <__malloc_unlock>
  203634:	0005883a 	mov	r2,zero
  203638:	00001806 	br	20369c <_malloc_r+0xb58>
  20363c:	00800834 	movhi	r2,32
  203640:	109fd404 	addi	r2,r2,32592
  203644:	10800217 	ldw	r2,8(r2)
  203648:	e0bfff15 	stw	r2,-4(fp)
  20364c:	e0bff617 	ldw	r2,-40(fp)
  203650:	10c00054 	ori	r3,r2,1
  203654:	e0bfff17 	ldw	r2,-4(fp)
  203658:	10c00115 	stw	r3,4(r2)
  20365c:	00800834 	movhi	r2,32
  203660:	109fd404 	addi	r2,r2,32592
  203664:	e13fff17 	ldw	r4,-4(fp)
  203668:	e0fff617 	ldw	r3,-40(fp)
  20366c:	20c7883a 	add	r3,r4,r3
  203670:	10c00215 	stw	r3,8(r2)
  203674:	e0bffc17 	ldw	r2,-16(fp)
  203678:	10c00054 	ori	r3,r2,1
  20367c:	00800834 	movhi	r2,32
  203680:	109fd404 	addi	r2,r2,32592
  203684:	10800217 	ldw	r2,8(r2)
  203688:	10c00115 	stw	r3,4(r2)
  20368c:	e13ff217 	ldw	r4,-56(fp)
  203690:	02054ac0 	call	2054ac <__malloc_unlock>
  203694:	e0bfff17 	ldw	r2,-4(fp)
  203698:	10800204 	addi	r2,r2,8
  20369c:	e037883a 	mov	sp,fp
  2036a0:	dfc00117 	ldw	ra,4(sp)
  2036a4:	df000017 	ldw	fp,0(sp)
  2036a8:	dec00204 	addi	sp,sp,8
  2036ac:	f800283a 	ret

002036b0 <_realloc_r>:
  2036b0:	deffe104 	addi	sp,sp,-124
  2036b4:	dfc01e15 	stw	ra,120(sp)
  2036b8:	df001d15 	stw	fp,116(sp)
  2036bc:	df001d04 	addi	fp,sp,116
  2036c0:	e13fe515 	stw	r4,-108(fp)
  2036c4:	e17fe415 	stw	r5,-112(fp)
  2036c8:	e1bfe315 	stw	r6,-116(fp)
  2036cc:	e0bfe417 	ldw	r2,-112(fp)
  2036d0:	1000041e 	bne	r2,zero,2036e4 <_realloc_r+0x34>
  2036d4:	e17fe317 	ldw	r5,-116(fp)
  2036d8:	e13fe517 	ldw	r4,-108(fp)
  2036dc:	0202b440 	call	202b44 <_malloc_r>
  2036e0:	0002eb06 	br	204290 <_realloc_r+0xbe0>
  2036e4:	e13fe517 	ldw	r4,-108(fp)
  2036e8:	02054880 	call	205488 <__malloc_lock>
  2036ec:	e0bfe417 	ldw	r2,-112(fp)
  2036f0:	10bffe04 	addi	r2,r2,-8
  2036f4:	e0bff315 	stw	r2,-52(fp)
  2036f8:	e0bff317 	ldw	r2,-52(fp)
  2036fc:	e0bfff15 	stw	r2,-4(fp)
  203700:	e0bff317 	ldw	r2,-52(fp)
  203704:	10c00117 	ldw	r3,4(r2)
  203708:	00bfff04 	movi	r2,-4
  20370c:	1884703a 	and	r2,r3,r2
  203710:	e0bff215 	stw	r2,-56(fp)
  203714:	e0bff217 	ldw	r2,-56(fp)
  203718:	e0bffe15 	stw	r2,-8(fp)
  20371c:	e0bfe317 	ldw	r2,-116(fp)
  203720:	108002c4 	addi	r2,r2,11
  203724:	108005f0 	cmpltui	r2,r2,23
  203728:	1000051e 	bne	r2,zero,203740 <_realloc_r+0x90>
  20372c:	e0bfe317 	ldw	r2,-116(fp)
  203730:	10c002c4 	addi	r3,r2,11
  203734:	00bffe04 	movi	r2,-8
  203738:	1884703a 	and	r2,r3,r2
  20373c:	00000106 	br	203744 <_realloc_r+0x94>
  203740:	00800404 	movi	r2,16
  203744:	e0bff115 	stw	r2,-60(fp)
  203748:	e0bff117 	ldw	r2,-60(fp)
  20374c:	10000316 	blt	r2,zero,20375c <_realloc_r+0xac>
  203750:	e0fff117 	ldw	r3,-60(fp)
  203754:	e0bfe317 	ldw	r2,-116(fp)
  203758:	1880052e 	bgeu	r3,r2,203770 <_realloc_r+0xc0>
  20375c:	e0bfe517 	ldw	r2,-108(fp)
  203760:	00c00304 	movi	r3,12
  203764:	10c00015 	stw	r3,0(r2)
  203768:	0005883a 	mov	r2,zero
  20376c:	0002c806 	br	204290 <_realloc_r+0xbe0>
  203770:	e0fff217 	ldw	r3,-56(fp)
  203774:	e0bff117 	ldw	r2,-60(fp)
  203778:	18828b0e 	bge	r3,r2,2041a8 <_realloc_r+0xaf8>
  20377c:	e0fff317 	ldw	r3,-52(fp)
  203780:	e0bff217 	ldw	r2,-56(fp)
  203784:	1885883a 	add	r2,r3,r2
  203788:	e0bffd15 	stw	r2,-12(fp)
  20378c:	00800834 	movhi	r2,32
  203790:	109fd404 	addi	r2,r2,32592
  203794:	10800217 	ldw	r2,8(r2)
  203798:	e0fffd17 	ldw	r3,-12(fp)
  20379c:	18800926 	beq	r3,r2,2037c4 <_realloc_r+0x114>
  2037a0:	e0bffd17 	ldw	r2,-12(fp)
  2037a4:	10c00117 	ldw	r3,4(r2)
  2037a8:	00bfff84 	movi	r2,-2
  2037ac:	1884703a 	and	r2,r3,r2
  2037b0:	e0fffd17 	ldw	r3,-12(fp)
  2037b4:	1885883a 	add	r2,r3,r2
  2037b8:	10800117 	ldw	r2,4(r2)
  2037bc:	1080004c 	andi	r2,r2,1
  2037c0:	1000461e 	bne	r2,zero,2038dc <_realloc_r+0x22c>
  2037c4:	e0bffd17 	ldw	r2,-12(fp)
  2037c8:	10c00117 	ldw	r3,4(r2)
  2037cc:	00bfff04 	movi	r2,-4
  2037d0:	1884703a 	and	r2,r3,r2
  2037d4:	e0bffc15 	stw	r2,-16(fp)
  2037d8:	00800834 	movhi	r2,32
  2037dc:	109fd404 	addi	r2,r2,32592
  2037e0:	10800217 	ldw	r2,8(r2)
  2037e4:	e0fffd17 	ldw	r3,-12(fp)
  2037e8:	1880251e 	bne	r3,r2,203880 <_realloc_r+0x1d0>
  2037ec:	e0fffc17 	ldw	r3,-16(fp)
  2037f0:	e0bffe17 	ldw	r2,-8(fp)
  2037f4:	1885883a 	add	r2,r3,r2
  2037f8:	1007883a 	mov	r3,r2
  2037fc:	e0bff117 	ldw	r2,-60(fp)
  203800:	10800404 	addi	r2,r2,16
  203804:	18803816 	blt	r3,r2,2038e8 <_realloc_r+0x238>
  203808:	e0fffe17 	ldw	r3,-8(fp)
  20380c:	e0bffc17 	ldw	r2,-16(fp)
  203810:	1885883a 	add	r2,r3,r2
  203814:	e0bffe15 	stw	r2,-8(fp)
  203818:	00800834 	movhi	r2,32
  20381c:	109fd404 	addi	r2,r2,32592
  203820:	e13ff317 	ldw	r4,-52(fp)
  203824:	e0fff117 	ldw	r3,-60(fp)
  203828:	20c7883a 	add	r3,r4,r3
  20382c:	10c00215 	stw	r3,8(r2)
  203830:	e0fffe17 	ldw	r3,-8(fp)
  203834:	e0bff117 	ldw	r2,-60(fp)
  203838:	1887c83a 	sub	r3,r3,r2
  20383c:	00800834 	movhi	r2,32
  203840:	109fd404 	addi	r2,r2,32592
  203844:	10800217 	ldw	r2,8(r2)
  203848:	18c00054 	ori	r3,r3,1
  20384c:	10c00115 	stw	r3,4(r2)
  203850:	e0bff317 	ldw	r2,-52(fp)
  203854:	10800117 	ldw	r2,4(r2)
  203858:	10c0004c 	andi	r3,r2,1
  20385c:	e0bff117 	ldw	r2,-60(fp)
  203860:	1886b03a 	or	r3,r3,r2
  203864:	e0bff317 	ldw	r2,-52(fp)
  203868:	10c00115 	stw	r3,4(r2)
  20386c:	e13fe517 	ldw	r4,-108(fp)
  203870:	02054ac0 	call	2054ac <__malloc_unlock>
  203874:	e0bff317 	ldw	r2,-52(fp)
  203878:	10800204 	addi	r2,r2,8
  20387c:	00028406 	br	204290 <_realloc_r+0xbe0>
  203880:	e0fffc17 	ldw	r3,-16(fp)
  203884:	e0bffe17 	ldw	r2,-8(fp)
  203888:	1885883a 	add	r2,r3,r2
  20388c:	1007883a 	mov	r3,r2
  203890:	e0bff117 	ldw	r2,-60(fp)
  203894:	18801416 	blt	r3,r2,2038e8 <_realloc_r+0x238>
  203898:	e0bffd17 	ldw	r2,-12(fp)
  20389c:	10800317 	ldw	r2,12(r2)
  2038a0:	e0bff015 	stw	r2,-64(fp)
  2038a4:	e0bffd17 	ldw	r2,-12(fp)
  2038a8:	10800217 	ldw	r2,8(r2)
  2038ac:	e0bfef15 	stw	r2,-68(fp)
  2038b0:	e0bfef17 	ldw	r2,-68(fp)
  2038b4:	e0fff017 	ldw	r3,-64(fp)
  2038b8:	10c00315 	stw	r3,12(r2)
  2038bc:	e0bff017 	ldw	r2,-64(fp)
  2038c0:	e0ffef17 	ldw	r3,-68(fp)
  2038c4:	10c00215 	stw	r3,8(r2)
  2038c8:	e0fffe17 	ldw	r3,-8(fp)
  2038cc:	e0bffc17 	ldw	r2,-16(fp)
  2038d0:	1885883a 	add	r2,r3,r2
  2038d4:	e0bffe15 	stw	r2,-8(fp)
  2038d8:	00023406 	br	2041ac <_realloc_r+0xafc>
  2038dc:	e03ffd15 	stw	zero,-12(fp)
  2038e0:	e03ffc15 	stw	zero,-16(fp)
  2038e4:	00000106 	br	2038ec <_realloc_r+0x23c>
  2038e8:	0001883a 	nop
  2038ec:	e0bff317 	ldw	r2,-52(fp)
  2038f0:	10800117 	ldw	r2,4(r2)
  2038f4:	1080004c 	andi	r2,r2,1
  2038f8:	1001a91e 	bne	r2,zero,203fa0 <_realloc_r+0x8f0>
  2038fc:	e0bff317 	ldw	r2,-52(fp)
  203900:	10800017 	ldw	r2,0(r2)
  203904:	0085c83a 	sub	r2,zero,r2
  203908:	e0fff317 	ldw	r3,-52(fp)
  20390c:	1885883a 	add	r2,r3,r2
  203910:	e0bfee15 	stw	r2,-72(fp)
  203914:	e0bfee17 	ldw	r2,-72(fp)
  203918:	10c00117 	ldw	r3,4(r2)
  20391c:	00bfff04 	movi	r2,-4
  203920:	1884703a 	and	r2,r3,r2
  203924:	e0bfed15 	stw	r2,-76(fp)
  203928:	e0bffd17 	ldw	r2,-12(fp)
  20392c:	10012226 	beq	r2,zero,203db8 <_realloc_r+0x708>
  203930:	00800834 	movhi	r2,32
  203934:	109fd404 	addi	r2,r2,32592
  203938:	10800217 	ldw	r2,8(r2)
  20393c:	e0fffd17 	ldw	r3,-12(fp)
  203940:	1880951e 	bne	r3,r2,203b98 <_realloc_r+0x4e8>
  203944:	e0fffc17 	ldw	r3,-16(fp)
  203948:	e0bfed17 	ldw	r2,-76(fp)
  20394c:	1887883a 	add	r3,r3,r2
  203950:	e0bffe17 	ldw	r2,-8(fp)
  203954:	1885883a 	add	r2,r3,r2
  203958:	1007883a 	mov	r3,r2
  20395c:	e0bff117 	ldw	r2,-60(fp)
  203960:	10800404 	addi	r2,r2,16
  203964:	18811416 	blt	r3,r2,203db8 <_realloc_r+0x708>
  203968:	e0bfee17 	ldw	r2,-72(fp)
  20396c:	10800317 	ldw	r2,12(r2)
  203970:	e0bff015 	stw	r2,-64(fp)
  203974:	e0bfee17 	ldw	r2,-72(fp)
  203978:	10800217 	ldw	r2,8(r2)
  20397c:	e0bfef15 	stw	r2,-68(fp)
  203980:	e0bfef17 	ldw	r2,-68(fp)
  203984:	e0fff017 	ldw	r3,-64(fp)
  203988:	10c00315 	stw	r3,12(r2)
  20398c:	e0bff017 	ldw	r2,-64(fp)
  203990:	e0ffef17 	ldw	r3,-68(fp)
  203994:	10c00215 	stw	r3,8(r2)
  203998:	e0bfee17 	ldw	r2,-72(fp)
  20399c:	e0bfff15 	stw	r2,-4(fp)
  2039a0:	e0ffed17 	ldw	r3,-76(fp)
  2039a4:	e0bffc17 	ldw	r2,-16(fp)
  2039a8:	1885883a 	add	r2,r3,r2
  2039ac:	e0fffe17 	ldw	r3,-8(fp)
  2039b0:	1885883a 	add	r2,r3,r2
  2039b4:	e0bffe15 	stw	r2,-8(fp)
  2039b8:	e0bfff17 	ldw	r2,-4(fp)
  2039bc:	10800204 	addi	r2,r2,8
  2039c0:	e0bfec15 	stw	r2,-80(fp)
  2039c4:	e0bff217 	ldw	r2,-56(fp)
  2039c8:	10bfff04 	addi	r2,r2,-4
  2039cc:	e0bfea15 	stw	r2,-88(fp)
  2039d0:	e0bfea17 	ldw	r2,-88(fp)
  2039d4:	10800968 	cmpgeui	r2,r2,37
  2039d8:	1000521e 	bne	r2,zero,203b24 <_realloc_r+0x474>
  2039dc:	e0bfe417 	ldw	r2,-112(fp)
  2039e0:	e0bffb15 	stw	r2,-20(fp)
  2039e4:	e0bfec17 	ldw	r2,-80(fp)
  2039e8:	e0bffa15 	stw	r2,-24(fp)
  2039ec:	e0bfea17 	ldw	r2,-88(fp)
  2039f0:	10800530 	cmpltui	r2,r2,20
  2039f4:	1000361e 	bne	r2,zero,203ad0 <_realloc_r+0x420>
  2039f8:	e0fffb17 	ldw	r3,-20(fp)
  2039fc:	18800104 	addi	r2,r3,4
  203a00:	e0bffb15 	stw	r2,-20(fp)
  203a04:	e0bffa17 	ldw	r2,-24(fp)
  203a08:	11000104 	addi	r4,r2,4
  203a0c:	e13ffa15 	stw	r4,-24(fp)
  203a10:	18c00017 	ldw	r3,0(r3)
  203a14:	10c00015 	stw	r3,0(r2)
  203a18:	e0fffb17 	ldw	r3,-20(fp)
  203a1c:	18800104 	addi	r2,r3,4
  203a20:	e0bffb15 	stw	r2,-20(fp)
  203a24:	e0bffa17 	ldw	r2,-24(fp)
  203a28:	11000104 	addi	r4,r2,4
  203a2c:	e13ffa15 	stw	r4,-24(fp)
  203a30:	18c00017 	ldw	r3,0(r3)
  203a34:	10c00015 	stw	r3,0(r2)
  203a38:	e0bfea17 	ldw	r2,-88(fp)
  203a3c:	10800730 	cmpltui	r2,r2,28
  203a40:	1000231e 	bne	r2,zero,203ad0 <_realloc_r+0x420>
  203a44:	e0fffb17 	ldw	r3,-20(fp)
  203a48:	18800104 	addi	r2,r3,4
  203a4c:	e0bffb15 	stw	r2,-20(fp)
  203a50:	e0bffa17 	ldw	r2,-24(fp)
  203a54:	11000104 	addi	r4,r2,4
  203a58:	e13ffa15 	stw	r4,-24(fp)
  203a5c:	18c00017 	ldw	r3,0(r3)
  203a60:	10c00015 	stw	r3,0(r2)
  203a64:	e0fffb17 	ldw	r3,-20(fp)
  203a68:	18800104 	addi	r2,r3,4
  203a6c:	e0bffb15 	stw	r2,-20(fp)
  203a70:	e0bffa17 	ldw	r2,-24(fp)
  203a74:	11000104 	addi	r4,r2,4
  203a78:	e13ffa15 	stw	r4,-24(fp)
  203a7c:	18c00017 	ldw	r3,0(r3)
  203a80:	10c00015 	stw	r3,0(r2)
  203a84:	e0bfea17 	ldw	r2,-88(fp)
  203a88:	10800930 	cmpltui	r2,r2,36
  203a8c:	1000101e 	bne	r2,zero,203ad0 <_realloc_r+0x420>
  203a90:	e0fffb17 	ldw	r3,-20(fp)
  203a94:	18800104 	addi	r2,r3,4
  203a98:	e0bffb15 	stw	r2,-20(fp)
  203a9c:	e0bffa17 	ldw	r2,-24(fp)
  203aa0:	11000104 	addi	r4,r2,4
  203aa4:	e13ffa15 	stw	r4,-24(fp)
  203aa8:	18c00017 	ldw	r3,0(r3)
  203aac:	10c00015 	stw	r3,0(r2)
  203ab0:	e0fffb17 	ldw	r3,-20(fp)
  203ab4:	18800104 	addi	r2,r3,4
  203ab8:	e0bffb15 	stw	r2,-20(fp)
  203abc:	e0bffa17 	ldw	r2,-24(fp)
  203ac0:	11000104 	addi	r4,r2,4
  203ac4:	e13ffa15 	stw	r4,-24(fp)
  203ac8:	18c00017 	ldw	r3,0(r3)
  203acc:	10c00015 	stw	r3,0(r2)
  203ad0:	e0fffb17 	ldw	r3,-20(fp)
  203ad4:	18800104 	addi	r2,r3,4
  203ad8:	e0bffb15 	stw	r2,-20(fp)
  203adc:	e0bffa17 	ldw	r2,-24(fp)
  203ae0:	11000104 	addi	r4,r2,4
  203ae4:	e13ffa15 	stw	r4,-24(fp)
  203ae8:	18c00017 	ldw	r3,0(r3)
  203aec:	10c00015 	stw	r3,0(r2)
  203af0:	e0fffb17 	ldw	r3,-20(fp)
  203af4:	18800104 	addi	r2,r3,4
  203af8:	e0bffb15 	stw	r2,-20(fp)
  203afc:	e0bffa17 	ldw	r2,-24(fp)
  203b00:	11000104 	addi	r4,r2,4
  203b04:	e13ffa15 	stw	r4,-24(fp)
  203b08:	18c00017 	ldw	r3,0(r3)
  203b0c:	10c00015 	stw	r3,0(r2)
  203b10:	e0bffb17 	ldw	r2,-20(fp)
  203b14:	10c00017 	ldw	r3,0(r2)
  203b18:	e0bffa17 	ldw	r2,-24(fp)
  203b1c:	10c00015 	stw	r3,0(r2)
  203b20:	00000406 	br	203b34 <_realloc_r+0x484>
  203b24:	e1bfea17 	ldw	r6,-88(fp)
  203b28:	e17fe417 	ldw	r5,-112(fp)
  203b2c:	e13fec17 	ldw	r4,-80(fp)
  203b30:	02019980 	call	201998 <memmove>
  203b34:	00800834 	movhi	r2,32
  203b38:	109fd404 	addi	r2,r2,32592
  203b3c:	e13fff17 	ldw	r4,-4(fp)
  203b40:	e0fff117 	ldw	r3,-60(fp)
  203b44:	20c7883a 	add	r3,r4,r3
  203b48:	10c00215 	stw	r3,8(r2)
  203b4c:	e0fffe17 	ldw	r3,-8(fp)
  203b50:	e0bff117 	ldw	r2,-60(fp)
  203b54:	1887c83a 	sub	r3,r3,r2
  203b58:	00800834 	movhi	r2,32
  203b5c:	109fd404 	addi	r2,r2,32592
  203b60:	10800217 	ldw	r2,8(r2)
  203b64:	18c00054 	ori	r3,r3,1
  203b68:	10c00115 	stw	r3,4(r2)
  203b6c:	e0bfff17 	ldw	r2,-4(fp)
  203b70:	10800117 	ldw	r2,4(r2)
  203b74:	10c0004c 	andi	r3,r2,1
  203b78:	e0bff117 	ldw	r2,-60(fp)
  203b7c:	1886b03a 	or	r3,r3,r2
  203b80:	e0bfff17 	ldw	r2,-4(fp)
  203b84:	10c00115 	stw	r3,4(r2)
  203b88:	e13fe517 	ldw	r4,-108(fp)
  203b8c:	02054ac0 	call	2054ac <__malloc_unlock>
  203b90:	e0bfec17 	ldw	r2,-80(fp)
  203b94:	0001be06 	br	204290 <_realloc_r+0xbe0>
  203b98:	e0fffc17 	ldw	r3,-16(fp)
  203b9c:	e0bfed17 	ldw	r2,-76(fp)
  203ba0:	1887883a 	add	r3,r3,r2
  203ba4:	e0bffe17 	ldw	r2,-8(fp)
  203ba8:	1885883a 	add	r2,r3,r2
  203bac:	1007883a 	mov	r3,r2
  203bb0:	e0bff117 	ldw	r2,-60(fp)
  203bb4:	18808016 	blt	r3,r2,203db8 <_realloc_r+0x708>
  203bb8:	e0bffd17 	ldw	r2,-12(fp)
  203bbc:	10800317 	ldw	r2,12(r2)
  203bc0:	e0bff015 	stw	r2,-64(fp)
  203bc4:	e0bffd17 	ldw	r2,-12(fp)
  203bc8:	10800217 	ldw	r2,8(r2)
  203bcc:	e0bfef15 	stw	r2,-68(fp)
  203bd0:	e0bfef17 	ldw	r2,-68(fp)
  203bd4:	e0fff017 	ldw	r3,-64(fp)
  203bd8:	10c00315 	stw	r3,12(r2)
  203bdc:	e0bff017 	ldw	r2,-64(fp)
  203be0:	e0ffef17 	ldw	r3,-68(fp)
  203be4:	10c00215 	stw	r3,8(r2)
  203be8:	e0bfee17 	ldw	r2,-72(fp)
  203bec:	10800317 	ldw	r2,12(r2)
  203bf0:	e0bff015 	stw	r2,-64(fp)
  203bf4:	e0bfee17 	ldw	r2,-72(fp)
  203bf8:	10800217 	ldw	r2,8(r2)
  203bfc:	e0bfef15 	stw	r2,-68(fp)
  203c00:	e0bfef17 	ldw	r2,-68(fp)
  203c04:	e0fff017 	ldw	r3,-64(fp)
  203c08:	10c00315 	stw	r3,12(r2)
  203c0c:	e0bff017 	ldw	r2,-64(fp)
  203c10:	e0ffef17 	ldw	r3,-68(fp)
  203c14:	10c00215 	stw	r3,8(r2)
  203c18:	e0bfee17 	ldw	r2,-72(fp)
  203c1c:	e0bfff15 	stw	r2,-4(fp)
  203c20:	e0fffc17 	ldw	r3,-16(fp)
  203c24:	e0bfed17 	ldw	r2,-76(fp)
  203c28:	1885883a 	add	r2,r3,r2
  203c2c:	e0fffe17 	ldw	r3,-8(fp)
  203c30:	1885883a 	add	r2,r3,r2
  203c34:	e0bffe15 	stw	r2,-8(fp)
  203c38:	e0bfff17 	ldw	r2,-4(fp)
  203c3c:	10800204 	addi	r2,r2,8
  203c40:	e0bfec15 	stw	r2,-80(fp)
  203c44:	e0bff217 	ldw	r2,-56(fp)
  203c48:	10bfff04 	addi	r2,r2,-4
  203c4c:	e0bfeb15 	stw	r2,-84(fp)
  203c50:	e0bfeb17 	ldw	r2,-84(fp)
  203c54:	10800968 	cmpgeui	r2,r2,37
  203c58:	1000521e 	bne	r2,zero,203da4 <_realloc_r+0x6f4>
  203c5c:	e0bfe417 	ldw	r2,-112(fp)
  203c60:	e0bff915 	stw	r2,-28(fp)
  203c64:	e0bfec17 	ldw	r2,-80(fp)
  203c68:	e0bff815 	stw	r2,-32(fp)
  203c6c:	e0bfeb17 	ldw	r2,-84(fp)
  203c70:	10800530 	cmpltui	r2,r2,20
  203c74:	1000361e 	bne	r2,zero,203d50 <_realloc_r+0x6a0>
  203c78:	e0fff917 	ldw	r3,-28(fp)
  203c7c:	18800104 	addi	r2,r3,4
  203c80:	e0bff915 	stw	r2,-28(fp)
  203c84:	e0bff817 	ldw	r2,-32(fp)
  203c88:	11000104 	addi	r4,r2,4
  203c8c:	e13ff815 	stw	r4,-32(fp)
  203c90:	18c00017 	ldw	r3,0(r3)
  203c94:	10c00015 	stw	r3,0(r2)
  203c98:	e0fff917 	ldw	r3,-28(fp)
  203c9c:	18800104 	addi	r2,r3,4
  203ca0:	e0bff915 	stw	r2,-28(fp)
  203ca4:	e0bff817 	ldw	r2,-32(fp)
  203ca8:	11000104 	addi	r4,r2,4
  203cac:	e13ff815 	stw	r4,-32(fp)
  203cb0:	18c00017 	ldw	r3,0(r3)
  203cb4:	10c00015 	stw	r3,0(r2)
  203cb8:	e0bfeb17 	ldw	r2,-84(fp)
  203cbc:	10800730 	cmpltui	r2,r2,28
  203cc0:	1000231e 	bne	r2,zero,203d50 <_realloc_r+0x6a0>
  203cc4:	e0fff917 	ldw	r3,-28(fp)
  203cc8:	18800104 	addi	r2,r3,4
  203ccc:	e0bff915 	stw	r2,-28(fp)
  203cd0:	e0bff817 	ldw	r2,-32(fp)
  203cd4:	11000104 	addi	r4,r2,4
  203cd8:	e13ff815 	stw	r4,-32(fp)
  203cdc:	18c00017 	ldw	r3,0(r3)
  203ce0:	10c00015 	stw	r3,0(r2)
  203ce4:	e0fff917 	ldw	r3,-28(fp)
  203ce8:	18800104 	addi	r2,r3,4
  203cec:	e0bff915 	stw	r2,-28(fp)
  203cf0:	e0bff817 	ldw	r2,-32(fp)
  203cf4:	11000104 	addi	r4,r2,4
  203cf8:	e13ff815 	stw	r4,-32(fp)
  203cfc:	18c00017 	ldw	r3,0(r3)
  203d00:	10c00015 	stw	r3,0(r2)
  203d04:	e0bfeb17 	ldw	r2,-84(fp)
  203d08:	10800930 	cmpltui	r2,r2,36
  203d0c:	1000101e 	bne	r2,zero,203d50 <_realloc_r+0x6a0>
  203d10:	e0fff917 	ldw	r3,-28(fp)
  203d14:	18800104 	addi	r2,r3,4
  203d18:	e0bff915 	stw	r2,-28(fp)
  203d1c:	e0bff817 	ldw	r2,-32(fp)
  203d20:	11000104 	addi	r4,r2,4
  203d24:	e13ff815 	stw	r4,-32(fp)
  203d28:	18c00017 	ldw	r3,0(r3)
  203d2c:	10c00015 	stw	r3,0(r2)
  203d30:	e0fff917 	ldw	r3,-28(fp)
  203d34:	18800104 	addi	r2,r3,4
  203d38:	e0bff915 	stw	r2,-28(fp)
  203d3c:	e0bff817 	ldw	r2,-32(fp)
  203d40:	11000104 	addi	r4,r2,4
  203d44:	e13ff815 	stw	r4,-32(fp)
  203d48:	18c00017 	ldw	r3,0(r3)
  203d4c:	10c00015 	stw	r3,0(r2)
  203d50:	e0fff917 	ldw	r3,-28(fp)
  203d54:	18800104 	addi	r2,r3,4
  203d58:	e0bff915 	stw	r2,-28(fp)
  203d5c:	e0bff817 	ldw	r2,-32(fp)
  203d60:	11000104 	addi	r4,r2,4
  203d64:	e13ff815 	stw	r4,-32(fp)
  203d68:	18c00017 	ldw	r3,0(r3)
  203d6c:	10c00015 	stw	r3,0(r2)
  203d70:	e0fff917 	ldw	r3,-28(fp)
  203d74:	18800104 	addi	r2,r3,4
  203d78:	e0bff915 	stw	r2,-28(fp)
  203d7c:	e0bff817 	ldw	r2,-32(fp)
  203d80:	11000104 	addi	r4,r2,4
  203d84:	e13ff815 	stw	r4,-32(fp)
  203d88:	18c00017 	ldw	r3,0(r3)
  203d8c:	10c00015 	stw	r3,0(r2)
  203d90:	e0bff917 	ldw	r2,-28(fp)
  203d94:	10c00017 	ldw	r3,0(r2)
  203d98:	e0bff817 	ldw	r2,-32(fp)
  203d9c:	10c00015 	stw	r3,0(r2)
  203da0:	00010206 	br	2041ac <_realloc_r+0xafc>
  203da4:	e1bfeb17 	ldw	r6,-84(fp)
  203da8:	e17fe417 	ldw	r5,-112(fp)
  203dac:	e13fec17 	ldw	r4,-80(fp)
  203db0:	02019980 	call	201998 <memmove>
  203db4:	0000fd06 	br	2041ac <_realloc_r+0xafc>
  203db8:	e0bfee17 	ldw	r2,-72(fp)
  203dbc:	10007826 	beq	r2,zero,203fa0 <_realloc_r+0x8f0>
  203dc0:	e0ffed17 	ldw	r3,-76(fp)
  203dc4:	e0bffe17 	ldw	r2,-8(fp)
  203dc8:	1885883a 	add	r2,r3,r2
  203dcc:	1007883a 	mov	r3,r2
  203dd0:	e0bff117 	ldw	r2,-60(fp)
  203dd4:	18807216 	blt	r3,r2,203fa0 <_realloc_r+0x8f0>
  203dd8:	e0bfee17 	ldw	r2,-72(fp)
  203ddc:	10800317 	ldw	r2,12(r2)
  203de0:	e0bff015 	stw	r2,-64(fp)
  203de4:	e0bfee17 	ldw	r2,-72(fp)
  203de8:	10800217 	ldw	r2,8(r2)
  203dec:	e0bfef15 	stw	r2,-68(fp)
  203df0:	e0bfef17 	ldw	r2,-68(fp)
  203df4:	e0fff017 	ldw	r3,-64(fp)
  203df8:	10c00315 	stw	r3,12(r2)
  203dfc:	e0bff017 	ldw	r2,-64(fp)
  203e00:	e0ffef17 	ldw	r3,-68(fp)
  203e04:	10c00215 	stw	r3,8(r2)
  203e08:	e0bfee17 	ldw	r2,-72(fp)
  203e0c:	e0bfff15 	stw	r2,-4(fp)
  203e10:	e0fffe17 	ldw	r3,-8(fp)
  203e14:	e0bfed17 	ldw	r2,-76(fp)
  203e18:	1885883a 	add	r2,r3,r2
  203e1c:	e0bffe15 	stw	r2,-8(fp)
  203e20:	e0bfff17 	ldw	r2,-4(fp)
  203e24:	10800204 	addi	r2,r2,8
  203e28:	e0bfec15 	stw	r2,-80(fp)
  203e2c:	e0bff217 	ldw	r2,-56(fp)
  203e30:	10bfff04 	addi	r2,r2,-4
  203e34:	e0bfe915 	stw	r2,-92(fp)
  203e38:	e0bfe917 	ldw	r2,-92(fp)
  203e3c:	10800968 	cmpgeui	r2,r2,37
  203e40:	1000521e 	bne	r2,zero,203f8c <_realloc_r+0x8dc>
  203e44:	e0bfe417 	ldw	r2,-112(fp)
  203e48:	e0bff715 	stw	r2,-36(fp)
  203e4c:	e0bfec17 	ldw	r2,-80(fp)
  203e50:	e0bff615 	stw	r2,-40(fp)
  203e54:	e0bfe917 	ldw	r2,-92(fp)
  203e58:	10800530 	cmpltui	r2,r2,20
  203e5c:	1000361e 	bne	r2,zero,203f38 <_realloc_r+0x888>
  203e60:	e0fff717 	ldw	r3,-36(fp)
  203e64:	18800104 	addi	r2,r3,4
  203e68:	e0bff715 	stw	r2,-36(fp)
  203e6c:	e0bff617 	ldw	r2,-40(fp)
  203e70:	11000104 	addi	r4,r2,4
  203e74:	e13ff615 	stw	r4,-40(fp)
  203e78:	18c00017 	ldw	r3,0(r3)
  203e7c:	10c00015 	stw	r3,0(r2)
  203e80:	e0fff717 	ldw	r3,-36(fp)
  203e84:	18800104 	addi	r2,r3,4
  203e88:	e0bff715 	stw	r2,-36(fp)
  203e8c:	e0bff617 	ldw	r2,-40(fp)
  203e90:	11000104 	addi	r4,r2,4
  203e94:	e13ff615 	stw	r4,-40(fp)
  203e98:	18c00017 	ldw	r3,0(r3)
  203e9c:	10c00015 	stw	r3,0(r2)
  203ea0:	e0bfe917 	ldw	r2,-92(fp)
  203ea4:	10800730 	cmpltui	r2,r2,28
  203ea8:	1000231e 	bne	r2,zero,203f38 <_realloc_r+0x888>
  203eac:	e0fff717 	ldw	r3,-36(fp)
  203eb0:	18800104 	addi	r2,r3,4
  203eb4:	e0bff715 	stw	r2,-36(fp)
  203eb8:	e0bff617 	ldw	r2,-40(fp)
  203ebc:	11000104 	addi	r4,r2,4
  203ec0:	e13ff615 	stw	r4,-40(fp)
  203ec4:	18c00017 	ldw	r3,0(r3)
  203ec8:	10c00015 	stw	r3,0(r2)
  203ecc:	e0fff717 	ldw	r3,-36(fp)
  203ed0:	18800104 	addi	r2,r3,4
  203ed4:	e0bff715 	stw	r2,-36(fp)
  203ed8:	e0bff617 	ldw	r2,-40(fp)
  203edc:	11000104 	addi	r4,r2,4
  203ee0:	e13ff615 	stw	r4,-40(fp)
  203ee4:	18c00017 	ldw	r3,0(r3)
  203ee8:	10c00015 	stw	r3,0(r2)
  203eec:	e0bfe917 	ldw	r2,-92(fp)
  203ef0:	10800930 	cmpltui	r2,r2,36
  203ef4:	1000101e 	bne	r2,zero,203f38 <_realloc_r+0x888>
  203ef8:	e0fff717 	ldw	r3,-36(fp)
  203efc:	18800104 	addi	r2,r3,4
  203f00:	e0bff715 	stw	r2,-36(fp)
  203f04:	e0bff617 	ldw	r2,-40(fp)
  203f08:	11000104 	addi	r4,r2,4
  203f0c:	e13ff615 	stw	r4,-40(fp)
  203f10:	18c00017 	ldw	r3,0(r3)
  203f14:	10c00015 	stw	r3,0(r2)
  203f18:	e0fff717 	ldw	r3,-36(fp)
  203f1c:	18800104 	addi	r2,r3,4
  203f20:	e0bff715 	stw	r2,-36(fp)
  203f24:	e0bff617 	ldw	r2,-40(fp)
  203f28:	11000104 	addi	r4,r2,4
  203f2c:	e13ff615 	stw	r4,-40(fp)
  203f30:	18c00017 	ldw	r3,0(r3)
  203f34:	10c00015 	stw	r3,0(r2)
  203f38:	e0fff717 	ldw	r3,-36(fp)
  203f3c:	18800104 	addi	r2,r3,4
  203f40:	e0bff715 	stw	r2,-36(fp)
  203f44:	e0bff617 	ldw	r2,-40(fp)
  203f48:	11000104 	addi	r4,r2,4
  203f4c:	e13ff615 	stw	r4,-40(fp)
  203f50:	18c00017 	ldw	r3,0(r3)
  203f54:	10c00015 	stw	r3,0(r2)
  203f58:	e0fff717 	ldw	r3,-36(fp)
  203f5c:	18800104 	addi	r2,r3,4
  203f60:	e0bff715 	stw	r2,-36(fp)
  203f64:	e0bff617 	ldw	r2,-40(fp)
  203f68:	11000104 	addi	r4,r2,4
  203f6c:	e13ff615 	stw	r4,-40(fp)
  203f70:	18c00017 	ldw	r3,0(r3)
  203f74:	10c00015 	stw	r3,0(r2)
  203f78:	e0bff717 	ldw	r2,-36(fp)
  203f7c:	10c00017 	ldw	r3,0(r2)
  203f80:	e0bff617 	ldw	r2,-40(fp)
  203f84:	10c00015 	stw	r3,0(r2)
  203f88:	00008806 	br	2041ac <_realloc_r+0xafc>
  203f8c:	e1bfe917 	ldw	r6,-92(fp)
  203f90:	e17fe417 	ldw	r5,-112(fp)
  203f94:	e13fec17 	ldw	r4,-80(fp)
  203f98:	02019980 	call	201998 <memmove>
  203f9c:	00008306 	br	2041ac <_realloc_r+0xafc>
  203fa0:	e17fe317 	ldw	r5,-116(fp)
  203fa4:	e13fe517 	ldw	r4,-108(fp)
  203fa8:	0202b440 	call	202b44 <_malloc_r>
  203fac:	e0bfec15 	stw	r2,-80(fp)
  203fb0:	e0bfec17 	ldw	r2,-80(fp)
  203fb4:	1000041e 	bne	r2,zero,203fc8 <_realloc_r+0x918>
  203fb8:	e13fe517 	ldw	r4,-108(fp)
  203fbc:	02054ac0 	call	2054ac <__malloc_unlock>
  203fc0:	0005883a 	mov	r2,zero
  203fc4:	0000b206 	br	204290 <_realloc_r+0xbe0>
  203fc8:	e0bfec17 	ldw	r2,-80(fp)
  203fcc:	10bffe04 	addi	r2,r2,-8
  203fd0:	e0bfff15 	stw	r2,-4(fp)
  203fd4:	e0bff317 	ldw	r2,-52(fp)
  203fd8:	10c00117 	ldw	r3,4(r2)
  203fdc:	00bfff84 	movi	r2,-2
  203fe0:	1884703a 	and	r2,r3,r2
  203fe4:	e0fff317 	ldw	r3,-52(fp)
  203fe8:	1885883a 	add	r2,r3,r2
  203fec:	e0ffff17 	ldw	r3,-4(fp)
  203ff0:	18800a1e 	bne	r3,r2,20401c <_realloc_r+0x96c>
  203ff4:	e0bfff17 	ldw	r2,-4(fp)
  203ff8:	10c00117 	ldw	r3,4(r2)
  203ffc:	00bfff04 	movi	r2,-4
  204000:	1884703a 	and	r2,r3,r2
  204004:	e0fffe17 	ldw	r3,-8(fp)
  204008:	1885883a 	add	r2,r3,r2
  20400c:	e0bffe15 	stw	r2,-8(fp)
  204010:	e0bff317 	ldw	r2,-52(fp)
  204014:	e0bfff15 	stw	r2,-4(fp)
  204018:	00006406 	br	2041ac <_realloc_r+0xafc>
  20401c:	e0bff217 	ldw	r2,-56(fp)
  204020:	10bfff04 	addi	r2,r2,-4
  204024:	e0bfe815 	stw	r2,-96(fp)
  204028:	e0bfe817 	ldw	r2,-96(fp)
  20402c:	10800968 	cmpgeui	r2,r2,37
  204030:	1000521e 	bne	r2,zero,20417c <_realloc_r+0xacc>
  204034:	e0bfe417 	ldw	r2,-112(fp)
  204038:	e0bff515 	stw	r2,-44(fp)
  20403c:	e0bfec17 	ldw	r2,-80(fp)
  204040:	e0bff415 	stw	r2,-48(fp)
  204044:	e0bfe817 	ldw	r2,-96(fp)
  204048:	10800530 	cmpltui	r2,r2,20
  20404c:	1000361e 	bne	r2,zero,204128 <_realloc_r+0xa78>
  204050:	e0fff517 	ldw	r3,-44(fp)
  204054:	18800104 	addi	r2,r3,4
  204058:	e0bff515 	stw	r2,-44(fp)
  20405c:	e0bff417 	ldw	r2,-48(fp)
  204060:	11000104 	addi	r4,r2,4
  204064:	e13ff415 	stw	r4,-48(fp)
  204068:	18c00017 	ldw	r3,0(r3)
  20406c:	10c00015 	stw	r3,0(r2)
  204070:	e0fff517 	ldw	r3,-44(fp)
  204074:	18800104 	addi	r2,r3,4
  204078:	e0bff515 	stw	r2,-44(fp)
  20407c:	e0bff417 	ldw	r2,-48(fp)
  204080:	11000104 	addi	r4,r2,4
  204084:	e13ff415 	stw	r4,-48(fp)
  204088:	18c00017 	ldw	r3,0(r3)
  20408c:	10c00015 	stw	r3,0(r2)
  204090:	e0bfe817 	ldw	r2,-96(fp)
  204094:	10800730 	cmpltui	r2,r2,28
  204098:	1000231e 	bne	r2,zero,204128 <_realloc_r+0xa78>
  20409c:	e0fff517 	ldw	r3,-44(fp)
  2040a0:	18800104 	addi	r2,r3,4
  2040a4:	e0bff515 	stw	r2,-44(fp)
  2040a8:	e0bff417 	ldw	r2,-48(fp)
  2040ac:	11000104 	addi	r4,r2,4
  2040b0:	e13ff415 	stw	r4,-48(fp)
  2040b4:	18c00017 	ldw	r3,0(r3)
  2040b8:	10c00015 	stw	r3,0(r2)
  2040bc:	e0fff517 	ldw	r3,-44(fp)
  2040c0:	18800104 	addi	r2,r3,4
  2040c4:	e0bff515 	stw	r2,-44(fp)
  2040c8:	e0bff417 	ldw	r2,-48(fp)
  2040cc:	11000104 	addi	r4,r2,4
  2040d0:	e13ff415 	stw	r4,-48(fp)
  2040d4:	18c00017 	ldw	r3,0(r3)
  2040d8:	10c00015 	stw	r3,0(r2)
  2040dc:	e0bfe817 	ldw	r2,-96(fp)
  2040e0:	10800930 	cmpltui	r2,r2,36
  2040e4:	1000101e 	bne	r2,zero,204128 <_realloc_r+0xa78>
  2040e8:	e0fff517 	ldw	r3,-44(fp)
  2040ec:	18800104 	addi	r2,r3,4
  2040f0:	e0bff515 	stw	r2,-44(fp)
  2040f4:	e0bff417 	ldw	r2,-48(fp)
  2040f8:	11000104 	addi	r4,r2,4
  2040fc:	e13ff415 	stw	r4,-48(fp)
  204100:	18c00017 	ldw	r3,0(r3)
  204104:	10c00015 	stw	r3,0(r2)
  204108:	e0fff517 	ldw	r3,-44(fp)
  20410c:	18800104 	addi	r2,r3,4
  204110:	e0bff515 	stw	r2,-44(fp)
  204114:	e0bff417 	ldw	r2,-48(fp)
  204118:	11000104 	addi	r4,r2,4
  20411c:	e13ff415 	stw	r4,-48(fp)
  204120:	18c00017 	ldw	r3,0(r3)
  204124:	10c00015 	stw	r3,0(r2)
  204128:	e0fff517 	ldw	r3,-44(fp)
  20412c:	18800104 	addi	r2,r3,4
  204130:	e0bff515 	stw	r2,-44(fp)
  204134:	e0bff417 	ldw	r2,-48(fp)
  204138:	11000104 	addi	r4,r2,4
  20413c:	e13ff415 	stw	r4,-48(fp)
  204140:	18c00017 	ldw	r3,0(r3)
  204144:	10c00015 	stw	r3,0(r2)
  204148:	e0fff517 	ldw	r3,-44(fp)
  20414c:	18800104 	addi	r2,r3,4
  204150:	e0bff515 	stw	r2,-44(fp)
  204154:	e0bff417 	ldw	r2,-48(fp)
  204158:	11000104 	addi	r4,r2,4
  20415c:	e13ff415 	stw	r4,-48(fp)
  204160:	18c00017 	ldw	r3,0(r3)
  204164:	10c00015 	stw	r3,0(r2)
  204168:	e0bff517 	ldw	r2,-44(fp)
  20416c:	10c00017 	ldw	r3,0(r2)
  204170:	e0bff417 	ldw	r2,-48(fp)
  204174:	10c00015 	stw	r3,0(r2)
  204178:	00000406 	br	20418c <_realloc_r+0xadc>
  20417c:	e1bfe817 	ldw	r6,-96(fp)
  204180:	e17fe417 	ldw	r5,-112(fp)
  204184:	e13fec17 	ldw	r4,-80(fp)
  204188:	02019980 	call	201998 <memmove>
  20418c:	e17fe417 	ldw	r5,-112(fp)
  204190:	e13fe517 	ldw	r4,-108(fp)
  204194:	02020680 	call	202068 <_free_r>
  204198:	e13fe517 	ldw	r4,-108(fp)
  20419c:	02054ac0 	call	2054ac <__malloc_unlock>
  2041a0:	e0bfec17 	ldw	r2,-80(fp)
  2041a4:	00003a06 	br	204290 <_realloc_r+0xbe0>
  2041a8:	0001883a 	nop
  2041ac:	e0fffe17 	ldw	r3,-8(fp)
  2041b0:	e0bff117 	ldw	r2,-60(fp)
  2041b4:	1885c83a 	sub	r2,r3,r2
  2041b8:	e0bfe715 	stw	r2,-100(fp)
  2041bc:	e0bfe717 	ldw	r2,-100(fp)
  2041c0:	10800430 	cmpltui	r2,r2,16
  2041c4:	10001e1e 	bne	r2,zero,204240 <_realloc_r+0xb90>
  2041c8:	e0ffff17 	ldw	r3,-4(fp)
  2041cc:	e0bff117 	ldw	r2,-60(fp)
  2041d0:	1885883a 	add	r2,r3,r2
  2041d4:	e0bfe615 	stw	r2,-104(fp)
  2041d8:	e0bfff17 	ldw	r2,-4(fp)
  2041dc:	10800117 	ldw	r2,4(r2)
  2041e0:	10c0004c 	andi	r3,r2,1
  2041e4:	e0bff117 	ldw	r2,-60(fp)
  2041e8:	1886b03a 	or	r3,r3,r2
  2041ec:	e0bfff17 	ldw	r2,-4(fp)
  2041f0:	10c00115 	stw	r3,4(r2)
  2041f4:	e0bfe717 	ldw	r2,-100(fp)
  2041f8:	10c00054 	ori	r3,r2,1
  2041fc:	e0bfe617 	ldw	r2,-104(fp)
  204200:	10c00115 	stw	r3,4(r2)
  204204:	e0ffe617 	ldw	r3,-104(fp)
  204208:	e0bfe717 	ldw	r2,-100(fp)
  20420c:	1885883a 	add	r2,r3,r2
  204210:	10c00117 	ldw	r3,4(r2)
  204214:	e13fe617 	ldw	r4,-104(fp)
  204218:	e0bfe717 	ldw	r2,-100(fp)
  20421c:	2085883a 	add	r2,r4,r2
  204220:	18c00054 	ori	r3,r3,1
  204224:	10c00115 	stw	r3,4(r2)
  204228:	e0bfe617 	ldw	r2,-104(fp)
  20422c:	10800204 	addi	r2,r2,8
  204230:	100b883a 	mov	r5,r2
  204234:	e13fe517 	ldw	r4,-108(fp)
  204238:	02020680 	call	202068 <_free_r>
  20423c:	00001006 	br	204280 <_realloc_r+0xbd0>
  204240:	e0bfff17 	ldw	r2,-4(fp)
  204244:	10800117 	ldw	r2,4(r2)
  204248:	10c0004c 	andi	r3,r2,1
  20424c:	e0bffe17 	ldw	r2,-8(fp)
  204250:	1886b03a 	or	r3,r3,r2
  204254:	e0bfff17 	ldw	r2,-4(fp)
  204258:	10c00115 	stw	r3,4(r2)
  20425c:	e0ffff17 	ldw	r3,-4(fp)
  204260:	e0bffe17 	ldw	r2,-8(fp)
  204264:	1885883a 	add	r2,r3,r2
  204268:	10c00117 	ldw	r3,4(r2)
  20426c:	e13fff17 	ldw	r4,-4(fp)
  204270:	e0bffe17 	ldw	r2,-8(fp)
  204274:	2085883a 	add	r2,r4,r2
  204278:	18c00054 	ori	r3,r3,1
  20427c:	10c00115 	stw	r3,4(r2)
  204280:	e13fe517 	ldw	r4,-108(fp)
  204284:	02054ac0 	call	2054ac <__malloc_unlock>
  204288:	e0bfff17 	ldw	r2,-4(fp)
  20428c:	10800204 	addi	r2,r2,8
  204290:	e037883a 	mov	sp,fp
  204294:	dfc00117 	ldw	ra,4(sp)
  204298:	df000017 	ldw	fp,0(sp)
  20429c:	dec00204 	addi	sp,sp,8
  2042a0:	f800283a 	ret

002042a4 <_fclose_r>:
#include "local.h"

int
_fclose_r (struct _reent *rptr,
      register FILE * fp)
{
  2042a4:	defffa04 	addi	sp,sp,-24
  2042a8:	dfc00515 	stw	ra,20(sp)
  2042ac:	df000415 	stw	fp,16(sp)
  2042b0:	dc000315 	stw	r16,12(sp)
  2042b4:	df000404 	addi	fp,sp,16
  2042b8:	e13ffc15 	stw	r4,-16(fp)
  2042bc:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
  2042c0:	8000021e 	bne	r16,zero,2042cc <_fclose_r+0x28>
    return (0);			/* on NULL */
  2042c4:	0005883a 	mov	r2,zero
  2042c8:	00003b06 	br	2043b8 <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
  2042cc:	e0bffc17 	ldw	r2,-16(fp)
  2042d0:	e0bffd15 	stw	r2,-12(fp)
  2042d4:	e0bffd17 	ldw	r2,-12(fp)
  2042d8:	10000526 	beq	r2,zero,2042f0 <_fclose_r+0x4c>
  2042dc:	e0bffd17 	ldw	r2,-12(fp)
  2042e0:	10800d17 	ldw	r2,52(r2)
  2042e4:	1000021e 	bne	r2,zero,2042f0 <_fclose_r+0x4c>
  2042e8:	e13ffd17 	ldw	r4,-12(fp)
  2042ec:	0200a0c0 	call	200a0c <__sinit>
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  if (!(fp->_flags2 & __SNLK))
    _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
  2042f0:	8080030b 	ldhu	r2,12(r16)
  2042f4:	10bfffcc 	andi	r2,r2,65535
  2042f8:	10a0001c 	xori	r2,r2,32768
  2042fc:	10a00004 	addi	r2,r2,-32768
  204300:	1000021e 	bne	r2,zero,20430c <_fclose_r+0x68>
      if (!(fp->_flags2 & __SNLK))
	_funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
  204304:	0005883a 	mov	r2,zero
  204308:	00002b06 	br	2043b8 <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
  20430c:	800b883a 	mov	r5,r16
  204310:	e13ffc17 	ldw	r4,-16(fp)
  204314:	02044080 	call	204408 <__sflush_r>
  204318:	e0bffe15 	stw	r2,-8(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
  20431c:	80800b17 	ldw	r2,44(r16)
  204320:	10000826 	beq	r2,zero,204344 <_fclose_r+0xa0>
  204324:	80800b17 	ldw	r2,44(r16)
  204328:	80c00717 	ldw	r3,28(r16)
  20432c:	180b883a 	mov	r5,r3
  204330:	e13ffc17 	ldw	r4,-16(fp)
  204334:	103ee83a 	callr	r2
  204338:	1000020e 	bge	r2,zero,204344 <_fclose_r+0xa0>
    r = EOF;
  20433c:	00bfffc4 	movi	r2,-1
  204340:	e0bffe15 	stw	r2,-8(fp)
  if (fp->_flags & __SMBF)
  204344:	8080030b 	ldhu	r2,12(r16)
  204348:	10bfffcc 	andi	r2,r2,65535
  20434c:	1080200c 	andi	r2,r2,128
  204350:	10000426 	beq	r2,zero,204364 <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
  204354:	80800417 	ldw	r2,16(r16)
  204358:	100b883a 	mov	r5,r2
  20435c:	e13ffc17 	ldw	r4,-16(fp)
  204360:	02020680 	call	202068 <_free_r>
  if (HASUB (fp))
  204364:	80800c17 	ldw	r2,48(r16)
  204368:	10000826 	beq	r2,zero,20438c <_fclose_r+0xe8>
    FREEUB (rptr, fp);
  20436c:	80c00c17 	ldw	r3,48(r16)
  204370:	80801004 	addi	r2,r16,64
  204374:	18800426 	beq	r3,r2,204388 <_fclose_r+0xe4>
  204378:	80800c17 	ldw	r2,48(r16)
  20437c:	100b883a 	mov	r5,r2
  204380:	e13ffc17 	ldw	r4,-16(fp)
  204384:	02020680 	call	202068 <_free_r>
  204388:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
  20438c:	80801117 	ldw	r2,68(r16)
  204390:	10000526 	beq	r2,zero,2043a8 <_fclose_r+0x104>
    FREELB (rptr, fp);
  204394:	80801117 	ldw	r2,68(r16)
  204398:	100b883a 	mov	r5,r2
  20439c:	e13ffc17 	ldw	r4,-16(fp)
  2043a0:	02020680 	call	202068 <_free_r>
  2043a4:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
  2043a8:	0200a640 	call	200a64 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
  2043ac:	8000030d 	sth	zero,12(r16)
    _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
  2043b0:	0200a840 	call	200a84 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
  2043b4:	e0bffe17 	ldw	r2,-8(fp)
}
  2043b8:	e6ffff04 	addi	sp,fp,-4
  2043bc:	dfc00217 	ldw	ra,8(sp)
  2043c0:	df000117 	ldw	fp,4(sp)
  2043c4:	dc000017 	ldw	r16,0(sp)
  2043c8:	dec00304 	addi	sp,sp,12
  2043cc:	f800283a 	ret

002043d0 <fclose>:

#ifndef _REENT_ONLY

int
fclose (register FILE * fp)
{
  2043d0:	defffe04 	addi	sp,sp,-8
  2043d4:	dfc00115 	stw	ra,4(sp)
  2043d8:	df000015 	stw	fp,0(sp)
  2043dc:	d839883a 	mov	fp,sp
  2043e0:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
  2043e4:	d0a00017 	ldw	r2,-32768(gp)
  2043e8:	180b883a 	mov	r5,r3
  2043ec:	1009883a 	mov	r4,r2
  2043f0:	02042a40 	call	2042a4 <_fclose_r>
}
  2043f4:	e037883a 	mov	sp,fp
  2043f8:	dfc00117 	ldw	ra,4(sp)
  2043fc:	df000017 	ldw	fp,0(sp)
  204400:	dec00204 	addi	sp,sp,8
  204404:	f800283a 	ret

00204408 <__sflush_r>:
/* Core function which does not lock file pointer.  This gets called
   directly from __srefill. */
int
__sflush_r (struct _reent *ptr,
       register FILE * fp)
{
  204408:	defff504 	addi	sp,sp,-44
  20440c:	dfc00a15 	stw	ra,40(sp)
  204410:	df000915 	stw	fp,36(sp)
  204414:	dcc00815 	stw	r19,32(sp)
  204418:	dc800715 	stw	r18,28(sp)
  20441c:	dc400615 	stw	r17,24(sp)
  204420:	dc000515 	stw	r16,20(sp)
  204424:	df000904 	addi	fp,sp,36
  204428:	e13ff715 	stw	r4,-36(fp)
  20442c:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  204430:	8080030b 	ldhu	r2,12(r16)
  204434:	e0bff98d 	sth	r2,-26(fp)
  if ((flags & __SWR) == 0)
  204438:	e0bff98b 	ldhu	r2,-26(fp)
  20443c:	10bfffcc 	andi	r2,r2,65535
  204440:	1080020c 	andi	r2,r2,8
  204444:	1000831e 	bne	r2,zero,204654 <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
  204448:	8080030b 	ldhu	r2,12(r16)
  20444c:	10820014 	ori	r2,r2,2048
  204450:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
  204454:	80800117 	ldw	r2,4(r16)
  204458:	00800216 	blt	zero,r2,204464 <__sflush_r+0x5c>
  20445c:	80800f17 	ldw	r2,60(r16)
  204460:	00807a0e 	bge	zero,r2,20464c <__sflush_r+0x244>
  204464:	80800a17 	ldw	r2,40(r16)
  204468:	10007826 	beq	r2,zero,20464c <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = _REENT_ERRNO(ptr);
  20446c:	e0bff717 	ldw	r2,-36(fp)
  204470:	10800017 	ldw	r2,0(r2)
  204474:	e0bff815 	stw	r2,-32(fp)
	  _REENT_ERRNO(ptr) = 0;
  204478:	e0bff717 	ldw	r2,-36(fp)
  20447c:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
  204480:	8080030b 	ldhu	r2,12(r16)
  204484:	10bfffcc 	andi	r2,r2,65535
  204488:	1084000c 	andi	r2,r2,4096
  20448c:	10000326 	beq	r2,zero,20449c <__sflush_r+0x94>
	    curoff = fp->_offset;
  204490:	80801417 	ldw	r2,80(r16)
  204494:	e0bffb15 	stw	r2,-20(fp)
  204498:	00002206 	br	204524 <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
  20449c:	80800a17 	ldw	r2,40(r16)
  2044a0:	80c00717 	ldw	r3,28(r16)
  2044a4:	01c00044 	movi	r7,1
  2044a8:	000d883a 	mov	r6,zero
  2044ac:	180b883a 	mov	r5,r3
  2044b0:	e13ff717 	ldw	r4,-36(fp)
  2044b4:	103ee83a 	callr	r2
  2044b8:	e0bffb15 	stw	r2,-20(fp)
	      if (curoff == -1L && _REENT_ERRNO(ptr) != 0)
  2044bc:	e0bffb17 	ldw	r2,-20(fp)
  2044c0:	10bfffd8 	cmpnei	r2,r2,-1
  2044c4:	1000171e 	bne	r2,zero,204524 <__sflush_r+0x11c>
  2044c8:	e0bff717 	ldw	r2,-36(fp)
  2044cc:	10800017 	ldw	r2,0(r2)
  2044d0:	10001426 	beq	r2,zero,204524 <__sflush_r+0x11c>
		{
		  int result = EOF;
  2044d4:	00bfffc4 	movi	r2,-1
  2044d8:	e0bffa15 	stw	r2,-24(fp)
		  if (_REENT_ERRNO(ptr) == ESPIPE || _REENT_ERRNO(ptr) == EINVAL)
  2044dc:	e0bff717 	ldw	r2,-36(fp)
  2044e0:	10800017 	ldw	r2,0(r2)
  2044e4:	10800760 	cmpeqi	r2,r2,29
  2044e8:	1000041e 	bne	r2,zero,2044fc <__sflush_r+0xf4>
  2044ec:	e0bff717 	ldw	r2,-36(fp)
  2044f0:	10800017 	ldw	r2,0(r2)
  2044f4:	10800598 	cmpnei	r2,r2,22
  2044f8:	1000051e 	bne	r2,zero,204510 <__sflush_r+0x108>
		    {
		      result = 0;
  2044fc:	e03ffa15 	stw	zero,-24(fp)
		      _REENT_ERRNO(ptr) = tmp_errno;
  204500:	e0bff717 	ldw	r2,-36(fp)
  204504:	e0fff817 	ldw	r3,-32(fp)
  204508:	10c00015 	stw	r3,0(r2)
  20450c:	00000306 	br	20451c <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
  204510:	8080030b 	ldhu	r2,12(r16)
  204514:	10801014 	ori	r2,r2,64
  204518:	8080030d 	sth	r2,12(r16)
		  return result;
  20451c:	e0bffa17 	ldw	r2,-24(fp)
  204520:	00006f06 	br	2046e0 <__sflush_r+0x2d8>
		}
            }
          if (fp->_flags & __SRD)
  204524:	8080030b 	ldhu	r2,12(r16)
  204528:	10bfffcc 	andi	r2,r2,65535
  20452c:	1080010c 	andi	r2,r2,4
  204530:	10000a26 	beq	r2,zero,20455c <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
  204534:	80800117 	ldw	r2,4(r16)
  204538:	e0fffb17 	ldw	r3,-20(fp)
  20453c:	1885c83a 	sub	r2,r3,r2
  204540:	e0bffb15 	stw	r2,-20(fp)
              if (HASUB (fp))
  204544:	80800c17 	ldw	r2,48(r16)
  204548:	10000426 	beq	r2,zero,20455c <__sflush_r+0x154>
                curoff -= fp->_ur;
  20454c:	80800f17 	ldw	r2,60(r16)
  204550:	e0fffb17 	ldw	r3,-20(fp)
  204554:	1885c83a 	sub	r2,r3,r2
  204558:	e0bffb15 	stw	r2,-20(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
  20455c:	80800a17 	ldw	r2,40(r16)
  204560:	80c00717 	ldw	r3,28(r16)
  204564:	000f883a 	mov	r7,zero
  204568:	e1bffb17 	ldw	r6,-20(fp)
  20456c:	180b883a 	mov	r5,r3
  204570:	e13ff717 	ldw	r4,-36(fp)
  204574:	103ee83a 	callr	r2
  204578:	e0bffb15 	stw	r2,-20(fp)
	  if (curoff != -1 || _REENT_ERRNO(ptr) == 0
  20457c:	e0bffb17 	ldw	r2,-20(fp)
  204580:	10bfffd8 	cmpnei	r2,r2,-1
  204584:	10000b1e 	bne	r2,zero,2045b4 <__sflush_r+0x1ac>
  204588:	e0bff717 	ldw	r2,-36(fp)
  20458c:	10800017 	ldw	r2,0(r2)
  204590:	10000826 	beq	r2,zero,2045b4 <__sflush_r+0x1ac>
	      || _REENT_ERRNO(ptr) == ESPIPE || _REENT_ERRNO(ptr) == EINVAL)
  204594:	e0bff717 	ldw	r2,-36(fp)
  204598:	10800017 	ldw	r2,0(r2)
  20459c:	10800760 	cmpeqi	r2,r2,29
  2045a0:	1000041e 	bne	r2,zero,2045b4 <__sflush_r+0x1ac>
  2045a4:	e0bff717 	ldw	r2,-36(fp)
  2045a8:	10800017 	ldw	r2,0(r2)
  2045ac:	10800598 	cmpnei	r2,r2,22
  2045b0:	1000211e 	bne	r2,zero,204638 <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
  2045b4:	80c0030b 	ldhu	r3,12(r16)
  2045b8:	00bdffc4 	movi	r2,-2049
  2045bc:	1884703a 	and	r2,r3,r2
  2045c0:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
  2045c4:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
  2045c8:	80800417 	ldw	r2,16(r16)
  2045cc:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || _REENT_ERRNO(ptr) == 0))
  2045d0:	8080030b 	ldhu	r2,12(r16)
  2045d4:	10bfffcc 	andi	r2,r2,65535
  2045d8:	1084000c 	andi	r2,r2,4096
  2045dc:	10000826 	beq	r2,zero,204600 <__sflush_r+0x1f8>
  2045e0:	e0bffb17 	ldw	r2,-20(fp)
  2045e4:	10bfffd8 	cmpnei	r2,r2,-1
  2045e8:	1000031e 	bne	r2,zero,2045f8 <__sflush_r+0x1f0>
  2045ec:	e0bff717 	ldw	r2,-36(fp)
  2045f0:	10800017 	ldw	r2,0(r2)
  2045f4:	1000021e 	bne	r2,zero,204600 <__sflush_r+0x1f8>
		fp->_offset = curoff;
  2045f8:	e0bffb17 	ldw	r2,-20(fp)
  2045fc:	80801415 	stw	r2,80(r16)
	      _REENT_ERRNO(ptr) = tmp_errno;
  204600:	e0bff717 	ldw	r2,-36(fp)
  204604:	e0fff817 	ldw	r3,-32(fp)
  204608:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
  20460c:	80800c17 	ldw	r2,48(r16)
  204610:	10000e26 	beq	r2,zero,20464c <__sflush_r+0x244>
		FREEUB (ptr, fp);
  204614:	80c00c17 	ldw	r3,48(r16)
  204618:	80801004 	addi	r2,r16,64
  20461c:	18800426 	beq	r3,r2,204630 <__sflush_r+0x228>
  204620:	80800c17 	ldw	r2,48(r16)
  204624:	100b883a 	mov	r5,r2
  204628:	e13ff717 	ldw	r4,-36(fp)
  20462c:	02020680 	call	202068 <_free_r>
  204630:	80000c15 	stw	zero,48(r16)
	      if (HASUB (fp))
  204634:	00000506 	br	20464c <__sflush_r+0x244>
	    }
	  else
	    {
	      fp->_flags |= __SERR;
  204638:	8080030b 	ldhu	r2,12(r16)
  20463c:	10801014 	ori	r2,r2,64
  204640:	8080030d 	sth	r2,12(r16)
	      return EOF;
  204644:	00bfffc4 	movi	r2,-1
  204648:	00002506 	br	2046e0 <__sflush_r+0x2d8>
	    }
	}
      return 0;
  20464c:	0005883a 	mov	r2,zero
  204650:	00002306 	br	2046e0 <__sflush_r+0x2d8>
    }
  if ((p = fp->_bf._base) == NULL)
  204654:	84400417 	ldw	r17,16(r16)
  204658:	8800021e 	bne	r17,zero,204664 <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
  20465c:	0005883a 	mov	r2,zero
  204660:	00001f06 	br	2046e0 <__sflush_r+0x2d8>
    }
  n = fp->_p - p;		/* write this much */
  204664:	80800017 	ldw	r2,0(r16)
  204668:	1465c83a 	sub	r18,r2,r17
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  20466c:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
  204670:	e0bff98b 	ldhu	r2,-26(fp)
  204674:	10bfffcc 	andi	r2,r2,65535
  204678:	108000cc 	andi	r2,r2,3
  20467c:	1000021e 	bne	r2,zero,204688 <__sflush_r+0x280>
  204680:	80800517 	ldw	r2,20(r16)
  204684:	00000106 	br	20468c <__sflush_r+0x284>
  204688:	0005883a 	mov	r2,zero
  20468c:	80800215 	stw	r2,8(r16)

  while (n > 0)
  204690:	00001106 	br	2046d8 <__sflush_r+0x2d0>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
  204694:	80800917 	ldw	r2,36(r16)
  204698:	80c00717 	ldw	r3,28(r16)
  20469c:	900f883a 	mov	r7,r18
  2046a0:	880d883a 	mov	r6,r17
  2046a4:	180b883a 	mov	r5,r3
  2046a8:	e13ff717 	ldw	r4,-36(fp)
  2046ac:	103ee83a 	callr	r2
  2046b0:	1027883a 	mov	r19,r2
      if (t <= 0)
  2046b4:	04c00516 	blt	zero,r19,2046cc <__sflush_r+0x2c4>
	{
          fp->_flags |= __SERR;
  2046b8:	8080030b 	ldhu	r2,12(r16)
  2046bc:	10801014 	ori	r2,r2,64
  2046c0:	8080030d 	sth	r2,12(r16)
          return EOF;
  2046c4:	00bfffc4 	movi	r2,-1
  2046c8:	00000506 	br	2046e0 <__sflush_r+0x2d8>
	}
      p += t;
  2046cc:	9805883a 	mov	r2,r19
  2046d0:	88a3883a 	add	r17,r17,r2
      n -= t;
  2046d4:	94e5c83a 	sub	r18,r18,r19
  while (n > 0)
  2046d8:	04bfee16 	blt	zero,r18,204694 <__sflush_r+0x28c>
    }
  return 0;
  2046dc:	0005883a 	mov	r2,zero
}
  2046e0:	e6fffc04 	addi	sp,fp,-16
  2046e4:	dfc00517 	ldw	ra,20(sp)
  2046e8:	df000417 	ldw	fp,16(sp)
  2046ec:	dcc00317 	ldw	r19,12(sp)
  2046f0:	dc800217 	ldw	r18,8(sp)
  2046f4:	dc400117 	ldw	r17,4(sp)
  2046f8:	dc000017 	ldw	r16,0(sp)
  2046fc:	dec00604 	addi	sp,sp,24
  204700:	f800283a 	ret

00204704 <_fflush_r>:
#endif /* __IMPL_UNLOCKED__ */

int
_fflush_r (struct _reent *ptr,
       register FILE * fp)
{
  204704:	defffa04 	addi	sp,sp,-24
  204708:	dfc00515 	stw	ra,20(sp)
  20470c:	df000415 	stw	fp,16(sp)
  204710:	dc000315 	stw	r16,12(sp)
  204714:	df000404 	addi	fp,sp,16
  204718:	e13ffc15 	stw	r4,-16(fp)
  20471c:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
  204720:	e0bffc17 	ldw	r2,-16(fp)
  204724:	e0bffe15 	stw	r2,-8(fp)
  204728:	e0bffe17 	ldw	r2,-8(fp)
  20472c:	10000526 	beq	r2,zero,204744 <_fflush_r+0x40>
  204730:	e0bffe17 	ldw	r2,-8(fp)
  204734:	10800d17 	ldw	r2,52(r2)
  204738:	1000021e 	bne	r2,zero,204744 <_fflush_r+0x40>
  20473c:	e13ffe17 	ldw	r4,-8(fp)
  204740:	0200a0c0 	call	200a0c <__sinit>

  if (!fp->_flags)
  204744:	8080030b 	ldhu	r2,12(r16)
  204748:	10bfffcc 	andi	r2,r2,65535
  20474c:	10a0001c 	xori	r2,r2,32768
  204750:	10a00004 	addi	r2,r2,-32768
  204754:	1000021e 	bne	r2,zero,204760 <_fflush_r+0x5c>
    return 0;
  204758:	0005883a 	mov	r2,zero
  20475c:	00000506 	br	204774 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  204760:	800b883a 	mov	r5,r16
  204764:	e13ffc17 	ldw	r4,-16(fp)
  204768:	02044080 	call	204408 <__sflush_r>
  20476c:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
  204770:	e0bffd17 	ldw	r2,-12(fp)
}
  204774:	e6ffff04 	addi	sp,fp,-4
  204778:	dfc00217 	ldw	ra,8(sp)
  20477c:	df000117 	ldw	fp,4(sp)
  204780:	dc000017 	ldw	r16,0(sp)
  204784:	dec00304 	addi	sp,sp,12
  204788:	f800283a 	ret

0020478c <fflush>:

#ifndef _REENT_ONLY

int
fflush (register FILE * fp)
{
  20478c:	defffe04 	addi	sp,sp,-8
  204790:	dfc00115 	stw	ra,4(sp)
  204794:	df000015 	stw	fp,0(sp)
  204798:	d839883a 	mov	fp,sp
  20479c:	2005883a 	mov	r2,r4
  if (fp == NULL)
  2047a0:	1000081e 	bne	r2,zero,2047c4 <fflush+0x38>
    return _fwalk_sglue (_GLOBAL_REENT, _fflush_r, &__sglue);
  2047a4:	01800834 	movhi	r6,32
  2047a8:	319fd104 	addi	r6,r6,32580
  2047ac:	01400834 	movhi	r5,32
  2047b0:	2951c104 	addi	r5,r5,18180
  2047b4:	01000834 	movhi	r4,32
  2047b8:	211f8a04 	addi	r4,r4,32296
  2047bc:	02011500 	call	201150 <_fwalk_sglue>
  2047c0:	00000406 	br	2047d4 <fflush+0x48>

  return _fflush_r (_REENT, fp);
  2047c4:	d0e00017 	ldw	r3,-32768(gp)
  2047c8:	100b883a 	mov	r5,r2
  2047cc:	1809883a 	mov	r4,r3
  2047d0:	02047040 	call	204704 <_fflush_r>
}
  2047d4:	e037883a 	mov	sp,fp
  2047d8:	dfc00117 	ldw	ra,4(sp)
  2047dc:	df000017 	ldw	fp,0(sp)
  2047e0:	dec00204 	addi	sp,sp,8
  2047e4:	f800283a 	ret

002047e8 <__smakebuf_r>:
 */

void
__smakebuf_r (struct _reent *ptr,
       register FILE *fp)
{
  2047e8:	defff804 	addi	sp,sp,-32
  2047ec:	dfc00715 	stw	ra,28(sp)
  2047f0:	df000615 	stw	fp,24(sp)
  2047f4:	dc400515 	stw	r17,20(sp)
  2047f8:	dc000415 	stw	r16,16(sp)
  2047fc:	df000604 	addi	fp,sp,24
  204800:	e13ffa15 	stw	r4,-24(fp)
  204804:	2821883a 	mov	r16,r5
  register void *p;
  int flags;
  size_t size;
  int couldbetty;

  if (fp->_flags & __SNBF)
  204808:	8080030b 	ldhu	r2,12(r16)
  20480c:	10bfffcc 	andi	r2,r2,65535
  204810:	1080008c 	andi	r2,r2,2
  204814:	10000726 	beq	r2,zero,204834 <__smakebuf_r+0x4c>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
  204818:	808010c4 	addi	r2,r16,67
  20481c:	80800015 	stw	r2,0(r16)
  204820:	80800017 	ldw	r2,0(r16)
  204824:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
  204828:	00800044 	movi	r2,1
  20482c:	80800515 	stw	r2,20(r16)
  204830:	00004c06 	br	204964 <__smakebuf_r+0x17c>
      return;
    }
  flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);
  204834:	e0fffb04 	addi	r3,fp,-20
  204838:	e0bffc04 	addi	r2,fp,-16
  20483c:	180f883a 	mov	r7,r3
  204840:	100d883a 	mov	r6,r2
  204844:	800b883a 	mov	r5,r16
  204848:	e13ffa17 	ldw	r4,-24(fp)
  20484c:	02049800 	call	204980 <__swhatbuf_r>
  204850:	e0bffd15 	stw	r2,-12(fp)
  /* Make unbuffered by default: */                /* IntelSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))    /* IntelSpecific */
  204854:	e0bffb17 	ldw	r2,-20(fp)
  204858:	10001126 	beq	r2,zero,2048a0 <__smakebuf_r+0xb8>
  20485c:	8080038b 	ldhu	r2,14(r16)
  204860:	10bfffcc 	andi	r2,r2,65535
  204864:	10a0001c 	xori	r2,r2,32768
  204868:	10a00004 	addi	r2,r2,-32768
  20486c:	100b883a 	mov	r5,r2
  204870:	e13ffa17 	ldw	r4,-24(fp)
  204874:	0204ad00 	call	204ad0 <_isatty_r>
  204878:	10000926 	beq	r2,zero,2048a0 <__smakebuf_r+0xb8>
  {                                                /* IntelSpecific */
    fp->_flags |= __SLBF;                          /* IntelSpecific __SLBF == "line buffered */
  20487c:	8080030b 	ldhu	r2,12(r16)
  204880:	10800054 	ori	r2,r2,1
  204884:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;            /* IntelSpecific (see newlib/libc/include/stdio.h) */
  204888:	808010c4 	addi	r2,r16,67
  20488c:	80800015 	stw	r2,0(r16)
  204890:	80800017 	ldw	r2,0(r16)
  204894:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;                             /* IntelSpecific */
  204898:	00800044 	movi	r2,1
  20489c:	80800515 	stw	r2,20(r16)
  }                                                /* IntelSpecific */
  if ((p = _malloc_r (ptr, size)) == NULL)
  2048a0:	e0bffc17 	ldw	r2,-16(fp)
  2048a4:	100b883a 	mov	r5,r2
  2048a8:	e13ffa17 	ldw	r4,-24(fp)
  2048ac:	0202b440 	call	202b44 <_malloc_r>
  2048b0:	1023883a 	mov	r17,r2
  2048b4:	8800101e 	bne	r17,zero,2048f8 <__smakebuf_r+0x110>
    {
      if (!(fp->_flags & __SSTR))
  2048b8:	8080030b 	ldhu	r2,12(r16)
  2048bc:	10bfffcc 	andi	r2,r2,65535
  2048c0:	1080800c 	andi	r2,r2,512
  2048c4:	1000271e 	bne	r2,zero,204964 <__smakebuf_r+0x17c>
	{
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
  2048c8:	80c0030b 	ldhu	r3,12(r16)
  2048cc:	00bfff04 	movi	r2,-4
  2048d0:	1884703a 	and	r2,r3,r2
  2048d4:	10800094 	ori	r2,r2,2
  2048d8:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
  2048dc:	808010c4 	addi	r2,r16,67
  2048e0:	80800015 	stw	r2,0(r16)
  2048e4:	80800017 	ldw	r2,0(r16)
  2048e8:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
  2048ec:	00800044 	movi	r2,1
  2048f0:	80800515 	stw	r2,20(r16)
  2048f4:	00001b06 	br	204964 <__smakebuf_r+0x17c>
	}
    }
  else
    {
      fp->_flags |= __SMBF;
  2048f8:	8080030b 	ldhu	r2,12(r16)
  2048fc:	10802014 	ori	r2,r2,128
  204900:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
  204904:	84400015 	stw	r17,0(r16)
  204908:	80800017 	ldw	r2,0(r16)
  20490c:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
  204910:	e0bffc17 	ldw	r2,-16(fp)
  204914:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
  204918:	e0bffb17 	ldw	r2,-20(fp)
  20491c:	10000d26 	beq	r2,zero,204954 <__smakebuf_r+0x16c>
  204920:	8080038b 	ldhu	r2,14(r16)
  204924:	10bfffcc 	andi	r2,r2,65535
  204928:	10a0001c 	xori	r2,r2,32768
  20492c:	10a00004 	addi	r2,r2,-32768
  204930:	100b883a 	mov	r5,r2
  204934:	e13ffa17 	ldw	r4,-24(fp)
  204938:	0204ad00 	call	204ad0 <_isatty_r>
  20493c:	10000526 	beq	r2,zero,204954 <__smakebuf_r+0x16c>
	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
  204940:	80c0030b 	ldhu	r3,12(r16)
  204944:	00bfff04 	movi	r2,-4
  204948:	1884703a 	and	r2,r3,r2
  20494c:	10800054 	ori	r2,r2,1
  204950:	8080030d 	sth	r2,12(r16)
      fp->_flags |= flags;
  204954:	8080030b 	ldhu	r2,12(r16)
  204958:	e0fffd17 	ldw	r3,-12(fp)
  20495c:	10c4b03a 	or	r2,r2,r3
  204960:	8080030d 	sth	r2,12(r16)
    }
}
  204964:	e6fffe04 	addi	sp,fp,-8
  204968:	dfc00317 	ldw	ra,12(sp)
  20496c:	df000217 	ldw	fp,8(sp)
  204970:	dc400117 	ldw	r17,4(sp)
  204974:	dc000017 	ldw	r16,0(sp)
  204978:	dec00404 	addi	sp,sp,16
  20497c:	f800283a 	ret

00204980 <__swhatbuf_r>:
int
__swhatbuf_r (struct _reent *ptr,
	FILE *fp,
	size_t *bufsize,
	int *couldbetty)
{
  204980:	deffe704 	addi	sp,sp,-100
  204984:	dfc01815 	stw	ra,96(sp)
  204988:	df001715 	stw	fp,92(sp)
  20498c:	df001704 	addi	fp,sp,92
  204990:	e13fec15 	stw	r4,-80(fp)
  204994:	e17feb15 	stw	r5,-84(fp)
  204998:	e1bfea15 	stw	r6,-88(fp)
  20499c:	e1ffe915 	stw	r7,-92(fp)
#ifdef _FSEEK_OPTIMIZATION
  const int snpt = __SNPT;
  2049a0:	00820004 	movi	r2,2048
  2049a4:	e0bfff15 	stw	r2,-4(fp)

  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  struct stat st;

  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
  2049a8:	e0bfeb17 	ldw	r2,-84(fp)
  2049ac:	1080038b 	ldhu	r2,14(r2)
  2049b0:	10bfffcc 	andi	r2,r2,65535
  2049b4:	10a0001c 	xori	r2,r2,32768
  2049b8:	10a00004 	addi	r2,r2,-32768
  2049bc:	10000b16 	blt	r2,zero,2049ec <__swhatbuf_r+0x6c>
  2049c0:	e0bfeb17 	ldw	r2,-84(fp)
  2049c4:	1080038b 	ldhu	r2,14(r2)
  2049c8:	10bfffcc 	andi	r2,r2,65535
  2049cc:	10a0001c 	xori	r2,r2,32768
  2049d0:	10a00004 	addi	r2,r2,-32768
  2049d4:	e0ffed04 	addi	r3,fp,-76
  2049d8:	180d883a 	mov	r6,r3
  2049dc:	100b883a 	mov	r5,r2
  2049e0:	e13fec17 	ldw	r4,-80(fp)
  2049e4:	0204a680 	call	204a68 <_fstat_r>
  2049e8:	1000100e 	bge	r2,zero,204a2c <__swhatbuf_r+0xac>
#endif
    {
      *couldbetty = 0;
  2049ec:	e0bfe917 	ldw	r2,-92(fp)
  2049f0:	10000015 	stw	zero,0(r2)
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
  2049f4:	e0bfeb17 	ldw	r2,-84(fp)
  2049f8:	1080030b 	ldhu	r2,12(r2)
  2049fc:	10bfffcc 	andi	r2,r2,65535
  204a00:	1080200c 	andi	r2,r2,128
  204a04:	10000426 	beq	r2,zero,204a18 <__swhatbuf_r+0x98>
        *bufsize = _DEFAULT_ASPRINTF_BUFSIZE;
  204a08:	e0bfea17 	ldw	r2,-88(fp)
  204a0c:	00c01004 	movi	r3,64
  204a10:	10c00015 	stw	r3,0(r2)
  204a14:	00000306 	br	204a24 <__swhatbuf_r+0xa4>
      else
        *bufsize = BUFSIZ;
  204a18:	e0bfea17 	ldw	r2,-88(fp)
  204a1c:	00c10004 	movi	r3,1024
  204a20:	10c00015 	stw	r3,0(r2)
      return (0);
  204a24:	0005883a 	mov	r2,zero
  204a28:	00000a06 	br	204a54 <__swhatbuf_r+0xd4>
    }

  /* could be a tty iff it is a character device */
  *couldbetty = S_ISCHR(st.st_mode);
  204a2c:	e0bfee17 	ldw	r2,-72(fp)
  204a30:	10bc000c 	andi	r2,r2,61440
  204a34:	10880020 	cmpeqi	r2,r2,8192
  204a38:	10c03fcc 	andi	r3,r2,255
  204a3c:	e0bfe917 	ldw	r2,-92(fp)
  204a40:	10c00015 	stw	r3,0(r2)
      *bufsize = st.st_blksize;
      fp->_blksize = st.st_blksize;
      return ((st.st_mode & S_IFMT) == S_IFREG ?  __SOPT : snpt);
    }
#endif
  *bufsize = BUFSIZ;
  204a44:	e0bfea17 	ldw	r2,-88(fp)
  204a48:	00c10004 	movi	r3,1024
  204a4c:	10c00015 	stw	r3,0(r2)
  return (snpt);
  204a50:	e0bfff17 	ldw	r2,-4(fp)
}
  204a54:	e037883a 	mov	sp,fp
  204a58:	dfc00117 	ldw	ra,4(sp)
  204a5c:	df000017 	ldw	fp,0(sp)
  204a60:	dec00204 	addi	sp,sp,8
  204a64:	f800283a 	ret

00204a68 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
  204a68:	defffa04 	addi	sp,sp,-24
  204a6c:	dfc00515 	stw	ra,20(sp)
  204a70:	df000415 	stw	fp,16(sp)
  204a74:	df000404 	addi	fp,sp,16
  204a78:	e13ffe15 	stw	r4,-8(fp)
  204a7c:	e17ffd15 	stw	r5,-12(fp)
  204a80:	e1bffc15 	stw	r6,-16(fp)
  int ret;

  errno = 0;
  204a84:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
  204a88:	e17ffc17 	ldw	r5,-16(fp)
  204a8c:	e13ffd17 	ldw	r4,-12(fp)
  204a90:	02050800 	call	205080 <fstat>
  204a94:	e0bfff15 	stw	r2,-4(fp)
  204a98:	e0bfff17 	ldw	r2,-4(fp)
  204a9c:	10bfffd8 	cmpnei	r2,r2,-1
  204aa0:	1000051e 	bne	r2,zero,204ab8 <_fstat_r+0x50>
  204aa4:	d0a61a17 	ldw	r2,-26520(gp)
  204aa8:	10000326 	beq	r2,zero,204ab8 <_fstat_r+0x50>
    _REENT_ERRNO(ptr) = errno;
  204aac:	d0e61a17 	ldw	r3,-26520(gp)
  204ab0:	e0bffe17 	ldw	r2,-8(fp)
  204ab4:	10c00015 	stw	r3,0(r2)
  return ret;
  204ab8:	e0bfff17 	ldw	r2,-4(fp)
}
  204abc:	e037883a 	mov	sp,fp
  204ac0:	dfc00117 	ldw	ra,4(sp)
  204ac4:	df000017 	ldw	fp,0(sp)
  204ac8:	dec00204 	addi	sp,sp,8
  204acc:	f800283a 	ret

00204ad0 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
  204ad0:	defffb04 	addi	sp,sp,-20
  204ad4:	dfc00415 	stw	ra,16(sp)
  204ad8:	df000315 	stw	fp,12(sp)
  204adc:	df000304 	addi	fp,sp,12
  204ae0:	e13ffe15 	stw	r4,-8(fp)
  204ae4:	e17ffd15 	stw	r5,-12(fp)
  int ret;

  errno = 0;
  204ae8:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
  204aec:	e13ffd17 	ldw	r4,-12(fp)
  204af0:	020516c0 	call	20516c <isatty>
  204af4:	e0bfff15 	stw	r2,-4(fp)
  204af8:	e0bfff17 	ldw	r2,-4(fp)
  204afc:	10bfffd8 	cmpnei	r2,r2,-1
  204b00:	1000051e 	bne	r2,zero,204b18 <_isatty_r+0x48>
  204b04:	d0a61a17 	ldw	r2,-26520(gp)
  204b08:	10000326 	beq	r2,zero,204b18 <_isatty_r+0x48>
    _REENT_ERRNO(ptr) = errno;
  204b0c:	d0e61a17 	ldw	r3,-26520(gp)
  204b10:	e0bffe17 	ldw	r2,-8(fp)
  204b14:	10c00015 	stw	r3,0(r2)
  return ret;
  204b18:	e0bfff17 	ldw	r2,-4(fp)
}
  204b1c:	e037883a 	mov	sp,fp
  204b20:	dfc00117 	ldw	ra,4(sp)
  204b24:	df000017 	ldw	fp,0(sp)
  204b28:	dec00204 	addi	sp,sp,8
  204b2c:	f800283a 	ret

00204b30 <_sbrk_r>:
*/

void *
_sbrk_r (struct _reent *ptr,
     ptrdiff_t incr)
{
  204b30:	defffb04 	addi	sp,sp,-20
  204b34:	dfc00415 	stw	ra,16(sp)
  204b38:	df000315 	stw	fp,12(sp)
  204b3c:	df000304 	addi	fp,sp,12
  204b40:	e13ffe15 	stw	r4,-8(fp)
  204b44:	e17ffd15 	stw	r5,-12(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
  204b48:	d0261a15 	stw	zero,-26520(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
  204b4c:	e13ffd17 	ldw	r4,-12(fp)
  204b50:	02056600 	call	205660 <sbrk>
  204b54:	e0bfff15 	stw	r2,-4(fp)
  204b58:	e0bfff17 	ldw	r2,-4(fp)
  204b5c:	10bfffd8 	cmpnei	r2,r2,-1
  204b60:	1000051e 	bne	r2,zero,204b78 <_sbrk_r+0x48>
  204b64:	d0a61a17 	ldw	r2,-26520(gp)
  204b68:	10000326 	beq	r2,zero,204b78 <_sbrk_r+0x48>
    _REENT_ERRNO(ptr) = errno;
  204b6c:	d0e61a17 	ldw	r3,-26520(gp)
  204b70:	e0bffe17 	ldw	r2,-8(fp)
  204b74:	10c00015 	stw	r3,0(r2)
  return ret;
  204b78:	e0bfff17 	ldw	r2,-4(fp)
}
  204b7c:	e037883a 	mov	sp,fp
  204b80:	dfc00117 	ldw	ra,4(sp)
  204b84:	df000017 	ldw	fp,0(sp)
  204b88:	dec00204 	addi	sp,sp,8
  204b8c:	f800283a 	ret

00204b90 <__call_exitprocs>:
 * otherwise only the handlers from that DSO are called.
 */

void 
__call_exitprocs (int code, void *d)
{
  204b90:	defff504 	addi	sp,sp,-44
  204b94:	dfc00a15 	stw	ra,40(sp)
  204b98:	df000915 	stw	fp,36(sp)
  204b9c:	dc800815 	stw	r18,32(sp)
  204ba0:	dc400715 	stw	r17,28(sp)
  204ba4:	dc000615 	stw	r16,24(sp)
  204ba8:	df000904 	addi	fp,sp,36
  204bac:	e13ff815 	stw	r4,-32(fp)
  204bb0:	e17ff715 	stw	r5,-36(fp)
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

 restart:

  p = __atexit;
  204bb4:	d4262017 	ldw	r16,-26496(gp)
  lastp = &__atexit;
  204bb8:	d0a62004 	addi	r2,gp,-26496
  204bbc:	e0bffc15 	stw	r2,-16(fp)
  while (p)
  204bc0:	0001883a 	nop
  204bc4:	80004b26 	beq	r16,zero,204cf4 <__call_exitprocs+0x164>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
  204bc8:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
  204bcc:	80800117 	ldw	r2,4(r16)
  204bd0:	147fffc4 	addi	r17,r2,-1
  204bd4:	00004506 	br	204cec <__call_exitprocs+0x15c>
	{
	  int ind;

	  i = 1 << n;
  204bd8:	00800044 	movi	r2,1
  204bdc:	1444983a 	sll	r2,r2,r17
  204be0:	e0bffb15 	stw	r2,-20(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
  204be4:	e0bff717 	ldw	r2,-36(fp)
  204be8:	10000726 	beq	r2,zero,204c08 <__call_exitprocs+0x78>
  204bec:	90003b26 	beq	r18,zero,204cdc <__call_exitprocs+0x14c>
  204bf0:	88800804 	addi	r2,r17,32
  204bf4:	100490ba 	slli	r2,r2,2
  204bf8:	9085883a 	add	r2,r18,r2
  204bfc:	10800017 	ldw	r2,0(r2)
  204c00:	e0fff717 	ldw	r3,-36(fp)
  204c04:	1880351e 	bne	r3,r2,204cdc <__call_exitprocs+0x14c>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
  204c08:	88800084 	addi	r2,r17,2
  204c0c:	100490ba 	slli	r2,r2,2
  204c10:	8085883a 	add	r2,r16,r2
  204c14:	10800017 	ldw	r2,0(r2)
  204c18:	e0bffa15 	stw	r2,-24(fp)
	  if (n == p->_ind - 1)
  204c1c:	80800117 	ldw	r2,4(r16)
  204c20:	10bfffc4 	addi	r2,r2,-1
  204c24:	8880041e 	bne	r17,r2,204c38 <__call_exitprocs+0xa8>
	    p->_ind--;
  204c28:	80800117 	ldw	r2,4(r16)
  204c2c:	10bfffc4 	addi	r2,r2,-1
  204c30:	80800115 	stw	r2,4(r16)
  204c34:	00000406 	br	204c48 <__call_exitprocs+0xb8>
	  else
	    p->_fns[n] = NULL;
  204c38:	88800084 	addi	r2,r17,2
  204c3c:	100490ba 	slli	r2,r2,2
  204c40:	8085883a 	add	r2,r16,r2
  204c44:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
  204c48:	e0bffa17 	ldw	r2,-24(fp)
  204c4c:	10002526 	beq	r2,zero,204ce4 <__call_exitprocs+0x154>
	    continue;

	  ind = p->_ind;
  204c50:	80800117 	ldw	r2,4(r16)
  204c54:	e0bff915 	stw	r2,-28(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
  204c58:	90000426 	beq	r18,zero,204c6c <__call_exitprocs+0xdc>
  204c5c:	90c04017 	ldw	r3,256(r18)
  204c60:	e0bffb17 	ldw	r2,-20(fp)
  204c64:	1884703a 	and	r2,r3,r2
  204c68:	1000031e 	bne	r2,zero,204c78 <__call_exitprocs+0xe8>
	    fn ();
  204c6c:	e0bffa17 	ldw	r2,-24(fp)
  204c70:	103ee83a 	callr	r2
  204c74:	00001206 	br	204cc0 <__call_exitprocs+0x130>
	  else if ((args->_is_cxa & i) == 0)
  204c78:	90c04117 	ldw	r3,260(r18)
  204c7c:	e0bffb17 	ldw	r2,-20(fp)
  204c80:	1884703a 	and	r2,r3,r2
  204c84:	1000081e 	bne	r2,zero,204ca8 <__call_exitprocs+0x118>
	    (*((void (*)(int, void *)) fn))(code, args->_fnargs[n]);
  204c88:	880490ba 	slli	r2,r17,2
  204c8c:	9085883a 	add	r2,r18,r2
  204c90:	10c00017 	ldw	r3,0(r2)
  204c94:	e0bffa17 	ldw	r2,-24(fp)
  204c98:	180b883a 	mov	r5,r3
  204c9c:	e13ff817 	ldw	r4,-32(fp)
  204ca0:	103ee83a 	callr	r2
  204ca4:	00000606 	br	204cc0 <__call_exitprocs+0x130>
	  else
	    (*((void (*)(void *)) fn))(args->_fnargs[n]);
  204ca8:	880490ba 	slli	r2,r17,2
  204cac:	9085883a 	add	r2,r18,r2
  204cb0:	10c00017 	ldw	r3,0(r2)
  204cb4:	e0bffa17 	ldw	r2,-24(fp)
  204cb8:	1809883a 	mov	r4,r3
  204cbc:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
  204cc0:	80800117 	ldw	r2,4(r16)
  204cc4:	e0fff917 	ldw	r3,-28(fp)
  204cc8:	18bfba1e 	bne	r3,r2,204bb4 <__call_exitprocs+0x24>
  204ccc:	e0bffc17 	ldw	r2,-16(fp)
  204cd0:	10800017 	ldw	r2,0(r2)
  204cd4:	80800426 	beq	r16,r2,204ce8 <__call_exitprocs+0x158>
	    goto restart;
  204cd8:	003fb606 	br	204bb4 <__call_exitprocs+0x24>
	    continue;
  204cdc:	0001883a 	nop
  204ce0:	00000106 	br	204ce8 <__call_exitprocs+0x158>
	    continue;
  204ce4:	0001883a 	nop
      for (n = p->_ind - 1; n >= 0; n--)
  204ce8:	8c7fffc4 	addi	r17,r17,-1
  204cec:	883fba0e 	bge	r17,zero,204bd8 <__call_exitprocs+0x48>
	}

#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
      break;
  204cf0:	00000106 	br	204cf8 <__call_exitprocs+0x168>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif

}
  204cf4:	0001883a 	nop
  204cf8:	0001883a 	nop
  204cfc:	e6fffd04 	addi	sp,fp,-12
  204d00:	dfc00417 	ldw	ra,16(sp)
  204d04:	df000317 	ldw	fp,12(sp)
  204d08:	dc800217 	ldw	r18,8(sp)
  204d0c:	dc400117 	ldw	r17,4(sp)
  204d10:	dc000017 	ldw	r16,0(sp)
  204d14:	dec00504 	addi	sp,sp,20
  204d18:	f800283a 	ret

00204d1c <__divsi3>:
  204d1c:	20001a16 	blt	r4,zero,204d88 <__divsi3+0x6c>
  204d20:	000f883a 	mov	r7,zero
  204d24:	2800020e 	bge	r5,zero,204d30 <__divsi3+0x14>
  204d28:	014bc83a 	sub	r5,zero,r5
  204d2c:	39c0005c 	xori	r7,r7,1
  204d30:	200d883a 	mov	r6,r4
  204d34:	00c00044 	movi	r3,1
  204d38:	2900092e 	bgeu	r5,r4,204d60 <__divsi3+0x44>
  204d3c:	00800804 	movi	r2,32
  204d40:	00c00044 	movi	r3,1
  204d44:	00000106 	br	204d4c <__divsi3+0x30>
  204d48:	10001226 	beq	r2,zero,204d94 <__divsi3+0x78>
  204d4c:	294b883a 	add	r5,r5,r5
  204d50:	10bfffc4 	addi	r2,r2,-1
  204d54:	18c7883a 	add	r3,r3,r3
  204d58:	293ffb36 	bltu	r5,r4,204d48 <__divsi3+0x2c>
  204d5c:	18000d26 	beq	r3,zero,204d94 <__divsi3+0x78>
  204d60:	0005883a 	mov	r2,zero
  204d64:	31400236 	bltu	r6,r5,204d70 <__divsi3+0x54>
  204d68:	314dc83a 	sub	r6,r6,r5
  204d6c:	10c4b03a 	or	r2,r2,r3
  204d70:	1806d07a 	srli	r3,r3,1
  204d74:	280ad07a 	srli	r5,r5,1
  204d78:	183ffa1e 	bne	r3,zero,204d64 <__divsi3+0x48>
  204d7c:	38000126 	beq	r7,zero,204d84 <__divsi3+0x68>
  204d80:	0085c83a 	sub	r2,zero,r2
  204d84:	f800283a 	ret
  204d88:	0109c83a 	sub	r4,zero,r4
  204d8c:	01c00044 	movi	r7,1
  204d90:	003fe406 	br	204d24 <__divsi3+0x8>
  204d94:	0005883a 	mov	r2,zero
  204d98:	003ff806 	br	204d7c <__divsi3+0x60>

00204d9c <__modsi3>:
  204d9c:	20001716 	blt	r4,zero,204dfc <__modsi3+0x60>
  204da0:	000f883a 	mov	r7,zero
  204da4:	2005883a 	mov	r2,r4
  204da8:	2800010e 	bge	r5,zero,204db0 <__modsi3+0x14>
  204dac:	014bc83a 	sub	r5,zero,r5
  204db0:	00c00044 	movi	r3,1
  204db4:	2900092e 	bgeu	r5,r4,204ddc <__modsi3+0x40>
  204db8:	01800804 	movi	r6,32
  204dbc:	00c00044 	movi	r3,1
  204dc0:	00000106 	br	204dc8 <__modsi3+0x2c>
  204dc4:	30001026 	beq	r6,zero,204e08 <__modsi3+0x6c>
  204dc8:	294b883a 	add	r5,r5,r5
  204dcc:	31bfffc4 	addi	r6,r6,-1
  204dd0:	18c7883a 	add	r3,r3,r3
  204dd4:	293ffb36 	bltu	r5,r4,204dc4 <__modsi3+0x28>
  204dd8:	18000b26 	beq	r3,zero,204e08 <__modsi3+0x6c>
  204ddc:	1806d07a 	srli	r3,r3,1
  204de0:	11400136 	bltu	r2,r5,204de8 <__modsi3+0x4c>
  204de4:	1145c83a 	sub	r2,r2,r5
  204de8:	280ad07a 	srli	r5,r5,1
  204dec:	183ffb1e 	bne	r3,zero,204ddc <__modsi3+0x40>
  204df0:	38000126 	beq	r7,zero,204df8 <__modsi3+0x5c>
  204df4:	0085c83a 	sub	r2,zero,r2
  204df8:	f800283a 	ret
  204dfc:	0109c83a 	sub	r4,zero,r4
  204e00:	01c00044 	movi	r7,1
  204e04:	003fe706 	br	204da4 <__modsi3+0x8>
  204e08:	2005883a 	mov	r2,r4
  204e0c:	003ff806 	br	204df0 <__modsi3+0x54>

00204e10 <__udivsi3>:
  204e10:	200d883a 	mov	r6,r4
  204e14:	2900152e 	bgeu	r5,r4,204e6c <__udivsi3+0x5c>
  204e18:	28001416 	blt	r5,zero,204e6c <__udivsi3+0x5c>
  204e1c:	00800804 	movi	r2,32
  204e20:	00c00044 	movi	r3,1
  204e24:	00000206 	br	204e30 <__udivsi3+0x20>
  204e28:	10000e26 	beq	r2,zero,204e64 <__udivsi3+0x54>
  204e2c:	28000416 	blt	r5,zero,204e40 <__udivsi3+0x30>
  204e30:	294b883a 	add	r5,r5,r5
  204e34:	10bfffc4 	addi	r2,r2,-1
  204e38:	18c7883a 	add	r3,r3,r3
  204e3c:	293ffa36 	bltu	r5,r4,204e28 <__udivsi3+0x18>
  204e40:	18000826 	beq	r3,zero,204e64 <__udivsi3+0x54>
  204e44:	0005883a 	mov	r2,zero
  204e48:	31400236 	bltu	r6,r5,204e54 <__udivsi3+0x44>
  204e4c:	314dc83a 	sub	r6,r6,r5
  204e50:	10c4b03a 	or	r2,r2,r3
  204e54:	1806d07a 	srli	r3,r3,1
  204e58:	280ad07a 	srli	r5,r5,1
  204e5c:	183ffa1e 	bne	r3,zero,204e48 <__udivsi3+0x38>
  204e60:	f800283a 	ret
  204e64:	0005883a 	mov	r2,zero
  204e68:	f800283a 	ret
  204e6c:	00c00044 	movi	r3,1
  204e70:	003ff406 	br	204e44 <__udivsi3+0x34>

00204e74 <__umodsi3>:
  204e74:	2005883a 	mov	r2,r4
  204e78:	2900132e 	bgeu	r5,r4,204ec8 <__umodsi3+0x54>
  204e7c:	28001216 	blt	r5,zero,204ec8 <__umodsi3+0x54>
  204e80:	01800804 	movi	r6,32
  204e84:	00c00044 	movi	r3,1
  204e88:	00000206 	br	204e94 <__umodsi3+0x20>
  204e8c:	30000c26 	beq	r6,zero,204ec0 <__umodsi3+0x4c>
  204e90:	28000416 	blt	r5,zero,204ea4 <__umodsi3+0x30>
  204e94:	294b883a 	add	r5,r5,r5
  204e98:	31bfffc4 	addi	r6,r6,-1
  204e9c:	18c7883a 	add	r3,r3,r3
  204ea0:	293ffa36 	bltu	r5,r4,204e8c <__umodsi3+0x18>
  204ea4:	18000626 	beq	r3,zero,204ec0 <__umodsi3+0x4c>
  204ea8:	1806d07a 	srli	r3,r3,1
  204eac:	11400136 	bltu	r2,r5,204eb4 <__umodsi3+0x40>
  204eb0:	1145c83a 	sub	r2,r2,r5
  204eb4:	280ad07a 	srli	r5,r5,1
  204eb8:	183ffb1e 	bne	r3,zero,204ea8 <__umodsi3+0x34>
  204ebc:	f800283a 	ret
  204ec0:	2005883a 	mov	r2,r4
  204ec4:	f800283a 	ret
  204ec8:	00c00044 	movi	r3,1
  204ecc:	003ff606 	br	204ea8 <__umodsi3+0x34>

00204ed0 <alt_get_errno>:

  if (fd)
  {
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
  204ed0:	defffe04 	addi	sp,sp,-8
  204ed4:	dfc00115 	stw	ra,4(sp)
  204ed8:	df000015 	stw	fp,0(sp)
  204edc:	d839883a 	mov	fp,sp
     */
  204ee0:	d0a00817 	ldw	r2,-32736(gp)
  204ee4:	10000326 	beq	r2,zero,204ef4 <alt_get_errno+0x24>
  204ee8:	d0a00817 	ldw	r2,-32736(gp)
  204eec:	103ee83a 	callr	r2
  204ef0:	00000106 	br	204ef8 <alt_get_errno+0x28>
  204ef4:	d0a61a04 	addi	r2,gp,-26520

  204ef8:	e037883a 	mov	sp,fp
  204efc:	dfc00117 	ldw	ra,4(sp)
  204f00:	df000017 	ldw	fp,0(sp)
  204f04:	dec00204 	addi	sp,sp,8
  204f08:	f800283a 	ret

00204f0c <close>:
{
  204f0c:	defffb04 	addi	sp,sp,-20
  204f10:	dfc00415 	stw	ra,16(sp)
  204f14:	df000315 	stw	fp,12(sp)
  204f18:	df000304 	addi	fp,sp,12
  204f1c:	e13ffd15 	stw	r4,-12(fp)
  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  204f20:	e0bffd17 	ldw	r2,-12(fp)
  204f24:	10000616 	blt	r2,zero,204f40 <close+0x34>
  204f28:	e0bffd17 	ldw	r2,-12(fp)
  204f2c:	10c00324 	muli	r3,r2,12
  204f30:	00800874 	movhi	r2,33
  204f34:	10a0e004 	addi	r2,r2,-31872
  204f38:	1885883a 	add	r2,r3,r2
  204f3c:	00000106 	br	204f44 <close+0x38>
  204f40:	0005883a 	mov	r2,zero
  204f44:	e0bfff15 	stw	r2,-4(fp)
  if (fd)
  204f48:	e0bfff17 	ldw	r2,-4(fp)
  204f4c:	10001926 	beq	r2,zero,204fb4 <close+0xa8>
    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  204f50:	e0bfff17 	ldw	r2,-4(fp)
  204f54:	10800017 	ldw	r2,0(r2)
  204f58:	10800417 	ldw	r2,16(r2)
  204f5c:	10000626 	beq	r2,zero,204f78 <close+0x6c>
  204f60:	e0bfff17 	ldw	r2,-4(fp)
  204f64:	10800017 	ldw	r2,0(r2)
  204f68:	10800417 	ldw	r2,16(r2)
  204f6c:	e13fff17 	ldw	r4,-4(fp)
  204f70:	103ee83a 	callr	r2
  204f74:	00000106 	br	204f7c <close+0x70>
  204f78:	0005883a 	mov	r2,zero
  204f7c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  204f80:	e13ffd17 	ldw	r4,-12(fp)
  204f84:	02056080 	call	205608 <alt_release_fd>
    if (rval < 0)
  204f88:	e0bffe17 	ldw	r2,-8(fp)
  204f8c:	1000070e 	bge	r2,zero,204fac <close+0xa0>
    {
      ALT_ERRNO = -rval;
  204f90:	0204ed00 	call	204ed0 <alt_get_errno>
  204f94:	1007883a 	mov	r3,r2
  204f98:	e0bffe17 	ldw	r2,-8(fp)
  204f9c:	0085c83a 	sub	r2,zero,r2
  204fa0:	18800015 	stw	r2,0(r3)
      return -1;
  204fa4:	00bfffc4 	movi	r2,-1
  204fa8:	00000706 	br	204fc8 <close+0xbc>
    }
    return 0;
  204fac:	0005883a 	mov	r2,zero
  204fb0:	00000506 	br	204fc8 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  204fb4:	0204ed00 	call	204ed0 <alt_get_errno>
  204fb8:	1007883a 	mov	r3,r2
  204fbc:	00801444 	movi	r2,81
  204fc0:	18800015 	stw	r2,0(r3)
    return -1;
  204fc4:	00bfffc4 	movi	r2,-1
  }
}
  204fc8:	e037883a 	mov	sp,fp
  204fcc:	dfc00117 	ldw	ra,4(sp)
  204fd0:	df000017 	ldw	fp,0(sp)
  204fd4:	dec00204 	addi	sp,sp,8
  204fd8:	f800283a 	ret

00204fdc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  204fdc:	defffc04 	addi	sp,sp,-16
  204fe0:	df000315 	stw	fp,12(sp)
  204fe4:	df000304 	addi	fp,sp,12
  204fe8:	e13fff15 	stw	r4,-4(fp)
  204fec:	e17ffe15 	stw	r5,-8(fp)
  204ff0:	e1bffd15 	stw	r6,-12(fp)
  return len;
  204ff4:	e0bffd17 	ldw	r2,-12(fp)
}
  204ff8:	e037883a 	mov	sp,fp
  204ffc:	df000017 	ldw	fp,0(sp)
  205000:	dec00104 	addi	sp,sp,4
  205004:	f800283a 	ret

00205008 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  205008:	defffd04 	addi	sp,sp,-12
  20500c:	df000215 	stw	fp,8(sp)
  205010:	df000204 	addi	fp,sp,8
  205014:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  205018:	0001883a 	nop
  20501c:	e0bffe17 	ldw	r2,-8(fp)
  205020:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  205024:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  205028:	10000226 	beq	r2,zero,205034 <_exit+0x2c>
    ALT_SIM_FAIL();
  20502c:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
  205030:	00000106 	br	205038 <_exit+0x30>
    ALT_SIM_PASS();
  205034:	002af0b0 	cmpltui	zero,zero,43970
}
  205038:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  20503c:	0001883a 	nop
  205040:	003ffe06 	br	20503c <_exit+0x34>

00205044 <alt_get_errno>:
        return 0;
    default:
        return -1;
    }

#if !defined(ALT_STDIN_PRESENT) && !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
  205044:	defffe04 	addi	sp,sp,-8
  205048:	dfc00115 	stw	ra,4(sp)
  20504c:	df000015 	stw	fp,0(sp)
  205050:	d839883a 	mov	fp,sp
    /* Generate a link time warning, should this function ever be called. */
  205054:	d0a00817 	ldw	r2,-32736(gp)
  205058:	10000326 	beq	r2,zero,205068 <alt_get_errno+0x24>
  20505c:	d0a00817 	ldw	r2,-32736(gp)
  205060:	103ee83a 	callr	r2
  205064:	00000106 	br	20506c <alt_get_errno+0x28>
  205068:	d0a61a04 	addi	r2,gp,-26520
    ALT_STUB_WARNING(fstat);
  20506c:	e037883a 	mov	sp,fp
  205070:	dfc00117 	ldw	ra,4(sp)
  205074:	df000017 	ldw	fp,0(sp)
  205078:	dec00204 	addi	sp,sp,8
  20507c:	f800283a 	ret

00205080 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
  205080:	defffb04 	addi	sp,sp,-20
  205084:	dfc00415 	stw	ra,16(sp)
  205088:	df000315 	stw	fp,12(sp)
  20508c:	df000304 	addi	fp,sp,12
  205090:	e13ffe15 	stw	r4,-8(fp)
  205094:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  205098:	e0bffe17 	ldw	r2,-8(fp)
  20509c:	10000616 	blt	r2,zero,2050b8 <fstat+0x38>
  2050a0:	e0bffe17 	ldw	r2,-8(fp)
  2050a4:	10c00324 	muli	r3,r2,12
  2050a8:	00800874 	movhi	r2,33
  2050ac:	10a0e004 	addi	r2,r2,-31872
  2050b0:	1885883a 	add	r2,r3,r2
  2050b4:	00000106 	br	2050bc <fstat+0x3c>
  2050b8:	0005883a 	mov	r2,zero
  2050bc:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
  2050c0:	e0bfff17 	ldw	r2,-4(fp)
  2050c4:	10001026 	beq	r2,zero,205108 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
  2050c8:	e0bfff17 	ldw	r2,-4(fp)
  2050cc:	10800017 	ldw	r2,0(r2)
  2050d0:	10800817 	ldw	r2,32(r2)
  2050d4:	10000726 	beq	r2,zero,2050f4 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
  2050d8:	e0bfff17 	ldw	r2,-4(fp)
  2050dc:	10800017 	ldw	r2,0(r2)
  2050e0:	10800817 	ldw	r2,32(r2)
  2050e4:	e17ffd17 	ldw	r5,-12(fp)
  2050e8:	e13fff17 	ldw	r4,-4(fp)
  2050ec:	103ee83a 	callr	r2
  2050f0:	00000a06 	br	20511c <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
  2050f4:	e0bffd17 	ldw	r2,-12(fp)
  2050f8:	00c80004 	movi	r3,8192
  2050fc:	10c00115 	stw	r3,4(r2)
      return 0;
  205100:	0005883a 	mov	r2,zero
  205104:	00000506 	br	20511c <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  205108:	02050440 	call	205044 <alt_get_errno>
  20510c:	1007883a 	mov	r3,r2
  205110:	00801444 	movi	r2,81
  205114:	18800015 	stw	r2,0(r3)
    return -1;
  205118:	00bfffc4 	movi	r2,-1
  }
}
  20511c:	e037883a 	mov	sp,fp
  205120:	dfc00117 	ldw	ra,4(sp)
  205124:	df000017 	ldw	fp,0(sp)
  205128:	dec00204 	addi	sp,sp,8
  20512c:	f800283a 	ret

00205130 <alt_get_errno>:
 * refers to a terminal device or not. If it is a terminal device then the
 * return value is one, otherwise it is zero.  
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
  205130:	defffe04 	addi	sp,sp,-8
  205134:	dfc00115 	stw	ra,4(sp)
  205138:	df000015 	stw	fp,0(sp)
  20513c:	d839883a 	mov	fp,sp
int ALT_ISATTY (int file)
  205140:	d0a00817 	ldw	r2,-32736(gp)
  205144:	10000326 	beq	r2,zero,205154 <alt_get_errno+0x24>
  205148:	d0a00817 	ldw	r2,-32736(gp)
  20514c:	103ee83a 	callr	r2
  205150:	00000106 	br	205158 <alt_get_errno+0x28>
  205154:	d0a61a04 	addi	r2,gp,-26520
{
  205158:	e037883a 	mov	sp,fp
  20515c:	dfc00117 	ldw	ra,4(sp)
  205160:	df000017 	ldw	fp,0(sp)
  205164:	dec00204 	addi	sp,sp,8
  205168:	f800283a 	ret

0020516c <isatty>:
  20516c:	deffea04 	addi	sp,sp,-88
  205170:	dfc01515 	stw	ra,84(sp)
  205174:	df001415 	stw	fp,80(sp)
  205178:	df001404 	addi	fp,sp,80
  20517c:	e13fec15 	stw	r4,-80(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  205180:	e0bfec17 	ldw	r2,-80(fp)
  205184:	10000616 	blt	r2,zero,2051a0 <isatty+0x34>
  205188:	e0bfec17 	ldw	r2,-80(fp)
  20518c:	10c00324 	muli	r3,r2,12
  205190:	00800874 	movhi	r2,33
  205194:	10a0e004 	addi	r2,r2,-31872
  205198:	1885883a 	add	r2,r3,r2
  20519c:	00000106 	br	2051a4 <isatty+0x38>
  2051a0:	0005883a 	mov	r2,zero
  2051a4:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
  2051a8:	e0bfff17 	ldw	r2,-4(fp)
  2051ac:	10000e26 	beq	r2,zero,2051e8 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
  2051b0:	e0bfff17 	ldw	r2,-4(fp)
  2051b4:	10800017 	ldw	r2,0(r2)
  2051b8:	10800817 	ldw	r2,32(r2)
  2051bc:	1000021e 	bne	r2,zero,2051c8 <isatty+0x5c>
    {
      return 1;
  2051c0:	00800044 	movi	r2,1
  2051c4:	00000d06 	br	2051fc <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
  2051c8:	e0bfed04 	addi	r2,fp,-76
  2051cc:	100b883a 	mov	r5,r2
  2051d0:	e13fec17 	ldw	r4,-80(fp)
  2051d4:	02050800 	call	205080 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
  2051d8:	e0bfee17 	ldw	r2,-72(fp)
  2051dc:	10880020 	cmpeqi	r2,r2,8192
  2051e0:	10803fcc 	andi	r2,r2,255
  2051e4:	00000506 	br	2051fc <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  2051e8:	02051300 	call	205130 <alt_get_errno>
  2051ec:	1007883a 	mov	r3,r2
  2051f0:	00801444 	movi	r2,81
  2051f4:	18800015 	stw	r2,0(r3)
    return 0;
  2051f8:	0005883a 	mov	r2,zero
  }
}
  2051fc:	e037883a 	mov	sp,fp
  205200:	dfc00117 	ldw	ra,4(sp)
  205204:	df000017 	ldw	fp,0(sp)
  205208:	dec00204 	addi	sp,sp,8
  20520c:	f800283a 	ret

00205210 <alt_load_section>:
 */  

void alt_load (void)
{
  /* 
   * Copy the .rwdata section. 
  205210:	defffc04 	addi	sp,sp,-16
  205214:	df000315 	stw	fp,12(sp)
  205218:	df000304 	addi	fp,sp,12
  20521c:	e13fff15 	stw	r4,-4(fp)
  205220:	e17ffe15 	stw	r5,-8(fp)
  205224:	e1bffd15 	stw	r6,-12(fp)
   */
  205228:	e0fffe17 	ldw	r3,-8(fp)
  20522c:	e0bfff17 	ldw	r2,-4(fp)
  205230:	18800c26 	beq	r3,r2,205264 <alt_load_section+0x54>

  alt_load_section (&__flash_rwdata_start, 
  205234:	00000806 	br	205258 <alt_load_section+0x48>
		               &__ram_rwdata_start,
		               &__ram_rwdata_end);
  205238:	e0ffff17 	ldw	r3,-4(fp)
  20523c:	18800104 	addi	r2,r3,4
  205240:	e0bfff15 	stw	r2,-4(fp)
  205244:	e0bffe17 	ldw	r2,-8(fp)
  205248:	11000104 	addi	r4,r2,4
  20524c:	e13ffe15 	stw	r4,-8(fp)
  205250:	18c00017 	ldw	r3,0(r3)
  205254:	10c00015 	stw	r3,0(r2)
  alt_load_section (&__flash_rwdata_start, 
  205258:	e0fffe17 	ldw	r3,-8(fp)
  20525c:	e0bffd17 	ldw	r2,-12(fp)
  205260:	18bff51e 	bne	r3,r2,205238 <alt_load_section+0x28>

  /*
   * Copy the exception handler.
  205264:	0001883a 	nop
  205268:	e037883a 	mov	sp,fp
  20526c:	df000017 	ldw	fp,0(sp)
  205270:	dec00104 	addi	sp,sp,4
  205274:	f800283a 	ret

00205278 <alt_load>:
{
  205278:	defffe04 	addi	sp,sp,-8
  20527c:	dfc00115 	stw	ra,4(sp)
  205280:	df000015 	stw	fp,0(sp)
  205284:	d839883a 	mov	fp,sp
  alt_load_section (&__flash_rwdata_start, 
  205288:	01800874 	movhi	r6,33
  20528c:	31a59604 	addi	r6,r6,-27048
  205290:	01400834 	movhi	r5,32
  205294:	295f8a04 	addi	r5,r5,32296
  205298:	01000874 	movhi	r4,33
  20529c:	21259604 	addi	r4,r4,-27048
  2052a0:	02052100 	call	205210 <alt_load_section>
   */

  alt_load_section (&__flash_exceptions_start, 
  2052a4:	01800834 	movhi	r6,32
  2052a8:	31808e04 	addi	r6,r6,568
  2052ac:	01400834 	movhi	r5,32
  2052b0:	29400804 	addi	r5,r5,32
  2052b4:	01000834 	movhi	r4,32
  2052b8:	21000804 	addi	r4,r4,32
  2052bc:	02052100 	call	205210 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  2052c0:	01800834 	movhi	r6,32
  2052c4:	319f8a04 	addi	r6,r6,32296
  2052c8:	01400834 	movhi	r5,32
  2052cc:	295f7504 	addi	r5,r5,32212
  2052d0:	01000834 	movhi	r4,32
  2052d4:	211f7504 	addi	r4,r4,32212
  2052d8:	02052100 	call	205210 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  2052dc:	0206dec0 	call	206dec <alt_dcache_flush_all>
  alt_icache_flush_all();
  2052e0:	0206fe40 	call	206fe4 <alt_icache_flush_all>
}
  2052e4:	0001883a 	nop
  2052e8:	e037883a 	mov	sp,fp
  2052ec:	dfc00117 	ldw	ra,4(sp)
  2052f0:	df000017 	ldw	fp,0(sp)
  2052f4:	dec00204 	addi	sp,sp,8
  2052f8:	f800283a 	ret

002052fc <alt_get_errno>:
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  2052fc:	defffe04 	addi	sp,sp,-8
  205300:	dfc00115 	stw	ra,4(sp)
  205304:	df000015 	stw	fp,0(sp)
  205308:	d839883a 	mov	fp,sp
  
  20530c:	d0a00817 	ldw	r2,-32736(gp)
  205310:	10000326 	beq	r2,zero,205320 <alt_get_errno+0x24>
  205314:	d0a00817 	ldw	r2,-32736(gp)
  205318:	103ee83a 	callr	r2
  20531c:	00000106 	br	205324 <alt_get_errno+0x28>
  205320:	d0a61a04 	addi	r2,gp,-26520
  if (fd) 
  205324:	e037883a 	mov	sp,fp
  205328:	dfc00117 	ldw	ra,4(sp)
  20532c:	df000017 	ldw	fp,0(sp)
  205330:	dec00204 	addi	sp,sp,8
  205334:	f800283a 	ret

00205338 <lseek>:
{
  205338:	defff904 	addi	sp,sp,-28
  20533c:	dfc00615 	stw	ra,24(sp)
  205340:	df000515 	stw	fp,20(sp)
  205344:	df000504 	addi	fp,sp,20
  205348:	e13ffd15 	stw	r4,-12(fp)
  20534c:	e17ffc15 	stw	r5,-16(fp)
  205350:	e1bffb15 	stw	r6,-20(fp)
  off_t   rc = 0; 
  205354:	e03fff15 	stw	zero,-4(fp)
  fd = (file < 0) ? NULL : &alt_fd_list[file];
  205358:	e0bffd17 	ldw	r2,-12(fp)
  20535c:	10000616 	blt	r2,zero,205378 <lseek+0x40>
  205360:	e0bffd17 	ldw	r2,-12(fp)
  205364:	10c00324 	muli	r3,r2,12
  205368:	00800874 	movhi	r2,33
  20536c:	10a0e004 	addi	r2,r2,-31872
  205370:	1885883a 	add	r2,r3,r2
  205374:	00000106 	br	20537c <lseek+0x44>
  205378:	0005883a 	mov	r2,zero
  20537c:	e0bffe15 	stw	r2,-8(fp)
  if (fd) 
  205380:	e0bffe17 	ldw	r2,-8(fp)
  205384:	10001026 	beq	r2,zero,2053c8 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
  205388:	e0bffe17 	ldw	r2,-8(fp)
  20538c:	10800017 	ldw	r2,0(r2)
  205390:	10800717 	ldw	r2,28(r2)
  205394:	10000926 	beq	r2,zero,2053bc <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
  205398:	e0bffe17 	ldw	r2,-8(fp)
  20539c:	10800017 	ldw	r2,0(r2)
  2053a0:	10800717 	ldw	r2,28(r2)
  2053a4:	e1bffb17 	ldw	r6,-20(fp)
  2053a8:	e17ffc17 	ldw	r5,-16(fp)
  2053ac:	e13ffe17 	ldw	r4,-8(fp)
  2053b0:	103ee83a 	callr	r2
  2053b4:	e0bfff15 	stw	r2,-4(fp)
  2053b8:	00000506 	br	2053d0 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
  2053bc:	00bfde84 	movi	r2,-134
  2053c0:	e0bfff15 	stw	r2,-4(fp)
  2053c4:	00000206 	br	2053d0 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
  2053c8:	00bfebc4 	movi	r2,-81
  2053cc:	e0bfff15 	stw	r2,-4(fp)
  }

  if (rc < 0)
  2053d0:	e0bfff17 	ldw	r2,-4(fp)
  2053d4:	1000070e 	bge	r2,zero,2053f4 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
  2053d8:	02052fc0 	call	2052fc <alt_get_errno>
  2053dc:	1007883a 	mov	r3,r2
  2053e0:	e0bfff17 	ldw	r2,-4(fp)
  2053e4:	0085c83a 	sub	r2,zero,r2
  2053e8:	18800015 	stw	r2,0(r3)
    rc = -1;
  2053ec:	00bfffc4 	movi	r2,-1
  2053f0:	e0bfff15 	stw	r2,-4(fp)
  }

  return rc;
  2053f4:	e0bfff17 	ldw	r2,-4(fp)
}
  2053f8:	e037883a 	mov	sp,fp
  2053fc:	dfc00117 	ldw	ra,4(sp)
  205400:	df000017 	ldw	fp,0(sp)
  205404:	dec00204 	addi	sp,sp,8
  205408:	f800283a 	ret

0020540c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  20540c:	defffd04 	addi	sp,sp,-12
  205410:	dfc00215 	stw	ra,8(sp)
  205414:	df000115 	stw	fp,4(sp)
  205418:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  20541c:	0009883a 	mov	r4,zero
  205420:	02058800 	call	205880 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  205424:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  205428:	02058bc0 	call	2058bc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  20542c:	01800834 	movhi	r6,32
  205430:	319f7e04 	addi	r6,r6,32248
  205434:	01400834 	movhi	r5,32
  205438:	295f7e04 	addi	r5,r5,32248
  20543c:	01000834 	movhi	r4,32
  205440:	211f7e04 	addi	r4,r4,32248
  205444:	02073600 	call	207360 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  205448:	0206f1c0 	call	206f1c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  20544c:	01000834 	movhi	r4,32
  205450:	211be004 	addi	r4,r4,28544
  205454:	0207b540 	call	207b54 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  205458:	d0a62117 	ldw	r2,-26492(gp)
  20545c:	d0e62217 	ldw	r3,-26488(gp)
  205460:	d1262317 	ldw	r4,-26484(gp)
  205464:	200d883a 	mov	r6,r4
  205468:	180b883a 	mov	r5,r3
  20546c:	1009883a 	mov	r4,r2
  205470:	02002840 	call	200284 <main>
  205474:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  205478:	01000044 	movi	r4,1
  20547c:	0204f0c0 	call	204f0c <close>
  exit (result);
  205480:	e13fff17 	ldw	r4,-4(fp)
  205484:	02020300 	call	202030 <exit>

00205488 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
  205488:	defffe04 	addi	sp,sp,-8
  20548c:	df000115 	stw	fp,4(sp)
  205490:	df000104 	addi	fp,sp,4
  205494:	e13fff15 	stw	r4,-4(fp)
}
  205498:	0001883a 	nop
  20549c:	e037883a 	mov	sp,fp
  2054a0:	df000017 	ldw	fp,0(sp)
  2054a4:	dec00104 	addi	sp,sp,4
  2054a8:	f800283a 	ret

002054ac <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
  2054ac:	defffe04 	addi	sp,sp,-8
  2054b0:	df000115 	stw	fp,4(sp)
  2054b4:	df000104 	addi	fp,sp,4
  2054b8:	e13fff15 	stw	r4,-4(fp)
}
  2054bc:	0001883a 	nop
  2054c0:	e037883a 	mov	sp,fp
  2054c4:	df000017 	ldw	fp,0(sp)
  2054c8:	dec00104 	addi	sp,sp,4
  2054cc:	f800283a 	ret

002054d0 <alt_get_errno>:
        return -1;
    }
}

#else /* !ALT_USE_DIRECT_DRIVERS */

  2054d0:	defffe04 	addi	sp,sp,-8
  2054d4:	dfc00115 	stw	ra,4(sp)
  2054d8:	df000015 	stw	fp,0(sp)
  2054dc:	d839883a 	mov	fp,sp
int ALT_READ (int file, void *ptr, size_t len)
  2054e0:	d0a00817 	ldw	r2,-32736(gp)
  2054e4:	10000326 	beq	r2,zero,2054f4 <alt_get_errno+0x24>
  2054e8:	d0a00817 	ldw	r2,-32736(gp)
  2054ec:	103ee83a 	callr	r2
  2054f0:	00000106 	br	2054f8 <alt_get_errno+0x28>
  2054f4:	d0a61a04 	addi	r2,gp,-26520
{
  2054f8:	e037883a 	mov	sp,fp
  2054fc:	dfc00117 	ldw	ra,4(sp)
  205500:	df000017 	ldw	fp,0(sp)
  205504:	dec00204 	addi	sp,sp,8
  205508:	f800283a 	ret

0020550c <read>:
  20550c:	defff904 	addi	sp,sp,-28
  205510:	dfc00615 	stw	ra,24(sp)
  205514:	df000515 	stw	fp,20(sp)
  205518:	df000504 	addi	fp,sp,20
  20551c:	e13ffd15 	stw	r4,-12(fp)
  205520:	e17ffc15 	stw	r5,-16(fp)
  205524:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  205528:	e0bffd17 	ldw	r2,-12(fp)
  20552c:	10000616 	blt	r2,zero,205548 <read+0x3c>
  205530:	e0bffd17 	ldw	r2,-12(fp)
  205534:	10c00324 	muli	r3,r2,12
  205538:	00800874 	movhi	r2,33
  20553c:	10a0e004 	addi	r2,r2,-31872
  205540:	1885883a 	add	r2,r3,r2
  205544:	00000106 	br	20554c <read+0x40>
  205548:	0005883a 	mov	r2,zero
  20554c:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
  205550:	e0bfff17 	ldw	r2,-4(fp)
  205554:	10002226 	beq	r2,zero,2055e0 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  205558:	e0bfff17 	ldw	r2,-4(fp)
  20555c:	10800217 	ldw	r2,8(r2)
  205560:	108000cc 	andi	r2,r2,3
  205564:	10800060 	cmpeqi	r2,r2,1
  205568:	1000181e 	bne	r2,zero,2055cc <read+0xc0>
        (fd->dev->read))
  20556c:	e0bfff17 	ldw	r2,-4(fp)
  205570:	10800017 	ldw	r2,0(r2)
  205574:	10800517 	ldw	r2,20(r2)
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  205578:	10001426 	beq	r2,zero,2055cc <read+0xc0>
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
  20557c:	e0bfff17 	ldw	r2,-4(fp)
  205580:	10800017 	ldw	r2,0(r2)
  205584:	10800517 	ldw	r2,20(r2)
  205588:	e0fffb17 	ldw	r3,-20(fp)
  20558c:	180d883a 	mov	r6,r3
  205590:	e17ffc17 	ldw	r5,-16(fp)
  205594:	e13fff17 	ldw	r4,-4(fp)
  205598:	103ee83a 	callr	r2
  20559c:	e0bffe15 	stw	r2,-8(fp)
  2055a0:	e0bffe17 	ldw	r2,-8(fp)
  2055a4:	1000070e 	bge	r2,zero,2055c4 <read+0xb8>
        {
          ALT_ERRNO = -rval;
  2055a8:	02054d00 	call	2054d0 <alt_get_errno>
  2055ac:	1007883a 	mov	r3,r2
  2055b0:	e0bffe17 	ldw	r2,-8(fp)
  2055b4:	0085c83a 	sub	r2,zero,r2
  2055b8:	18800015 	stw	r2,0(r3)
          return -1;
  2055bc:	00bfffc4 	movi	r2,-1
  2055c0:	00000c06 	br	2055f4 <read+0xe8>
        }
        return rval;
  2055c4:	e0bffe17 	ldw	r2,-8(fp)
  2055c8:	00000a06 	br	2055f4 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
  2055cc:	02054d00 	call	2054d0 <alt_get_errno>
  2055d0:	1007883a 	mov	r3,r2
  2055d4:	00800344 	movi	r2,13
  2055d8:	18800015 	stw	r2,0(r3)
  2055dc:	00000406 	br	2055f0 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
  2055e0:	02054d00 	call	2054d0 <alt_get_errno>
  2055e4:	1007883a 	mov	r3,r2
  2055e8:	00801444 	movi	r2,81
  2055ec:	18800015 	stw	r2,0(r3)
  }
  return -1;
  2055f0:	00bfffc4 	movi	r2,-1
}
  2055f4:	e037883a 	mov	sp,fp
  2055f8:	dfc00117 	ldw	ra,4(sp)
  2055fc:	df000017 	ldw	fp,0(sp)
  205600:	dec00204 	addi	sp,sp,8
  205604:	f800283a 	ret

00205608 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  205608:	defffe04 	addi	sp,sp,-8
  20560c:	df000115 	stw	fp,4(sp)
  205610:	df000104 	addi	fp,sp,4
  205614:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  205618:	e0bfff17 	ldw	r2,-4(fp)
  20561c:	108000d0 	cmplti	r2,r2,3
  205620:	10000a1e 	bne	r2,zero,20564c <alt_release_fd+0x44>
  {
    alt_fd_list[fd].fd_flags = 0;
  205624:	e0bfff17 	ldw	r2,-4(fp)
  205628:	10c00324 	muli	r3,r2,12
  20562c:	00800874 	movhi	r2,33
  205630:	1885883a 	add	r2,r3,r2
  205634:	1020e215 	stw	zero,-31864(r2)
    alt_fd_list[fd].dev      = 0;
  205638:	e0bfff17 	ldw	r2,-4(fp)
  20563c:	10c00324 	muli	r3,r2,12
  205640:	00800874 	movhi	r2,33
  205644:	1885883a 	add	r2,r3,r2
  205648:	1020e015 	stw	zero,-31872(r2)
  }
}
  20564c:	0001883a 	nop
  205650:	e037883a 	mov	sp,fp
  205654:	df000017 	ldw	fp,0(sp)
  205658:	dec00104 	addi	sp,sp,4
  20565c:	f800283a 	ret

00205660 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
  205660:	defff904 	addi	sp,sp,-28
  205664:	df000615 	stw	fp,24(sp)
  205668:	df000604 	addi	fp,sp,24
  20566c:	e13ffa15 	stw	r4,-24(fp)
  NIOS2_READ_STATUS (context);
  205670:	0005303a 	rdctl	r2,status
  205674:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  205678:	e0fffd17 	ldw	r3,-12(fp)
  20567c:	00bfff84 	movi	r2,-2
  205680:	1884703a 	and	r2,r3,r2
  205684:	1001703a 	wrctl	status,r2
  return context;
  205688:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
  20568c:	e0bfff15 	stw	r2,-4(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
  205690:	d0a00917 	ldw	r2,-32732(gp)
  205694:	10c000c4 	addi	r3,r2,3
  205698:	00bfff04 	movi	r2,-4
  20569c:	1884703a 	and	r2,r3,r2
  2056a0:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
  2056a4:	d0e00917 	ldw	r3,-32732(gp)
  2056a8:	e0bffa17 	ldw	r2,-24(fp)
  2056ac:	1887883a 	add	r3,r3,r2
  2056b0:	008008f4 	movhi	r2,35
  2056b4:	10880004 	addi	r2,r2,8192
  2056b8:	10c0072e 	bgeu	r2,r3,2056d8 <sbrk+0x78>
  2056bc:	e0bfff17 	ldw	r2,-4(fp)
  2056c0:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  2056c4:	e0bffc17 	ldw	r2,-16(fp)
  2056c8:	1001703a 	wrctl	status,r2
}
  2056cc:	0001883a 	nop
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  2056d0:	00bfffc4 	movi	r2,-1
  2056d4:	00000c06 	br	205708 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
  2056d8:	d0a00917 	ldw	r2,-32732(gp)
  2056dc:	e0bffe15 	stw	r2,-8(fp)
  heap_end += incr; 
  2056e0:	d0e00917 	ldw	r3,-32732(gp)
  2056e4:	e0bffa17 	ldw	r2,-24(fp)
  2056e8:	1885883a 	add	r2,r3,r2
  2056ec:	d0a00915 	stw	r2,-32732(gp)
  2056f0:	e0bfff17 	ldw	r2,-4(fp)
  2056f4:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
  2056f8:	e0bffb17 	ldw	r2,-20(fp)
  2056fc:	1001703a 	wrctl	status,r2
}
  205700:	0001883a 	nop

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
  205704:	e0bffe17 	ldw	r2,-8(fp)
} 
  205708:	e037883a 	mov	sp,fp
  20570c:	df000017 	ldw	fp,0(sp)
  205710:	dec00104 	addi	sp,sp,4
  205714:	f800283a 	ret

00205718 <alt_get_errno>:
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
  205718:	defffe04 	addi	sp,sp,-8
  20571c:	dfc00115 	stw	ra,4(sp)
  205720:	df000015 	stw	fp,0(sp)
  205724:	d839883a 	mov	fp,sp
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
  205728:	d0a00817 	ldw	r2,-32736(gp)
  20572c:	10000326 	beq	r2,zero,20573c <alt_get_errno+0x24>
  205730:	d0a00817 	ldw	r2,-32736(gp)
  205734:	103ee83a 	callr	r2
  205738:	00000106 	br	205740 <alt_get_errno+0x28>
  20573c:	d0a61a04 	addi	r2,gp,-26520
#endif /* ALT_STDERR_PRESENT */
  205740:	e037883a 	mov	sp,fp
  205744:	dfc00117 	ldw	ra,4(sp)
  205748:	df000017 	ldw	fp,0(sp)
  20574c:	dec00204 	addi	sp,sp,8
  205750:	f800283a 	ret

00205754 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  205754:	defff904 	addi	sp,sp,-28
  205758:	dfc00615 	stw	ra,24(sp)
  20575c:	df000515 	stw	fp,20(sp)
  205760:	df000504 	addi	fp,sp,20
  205764:	e13ffd15 	stw	r4,-12(fp)
  205768:	e17ffc15 	stw	r5,-16(fp)
  20576c:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  205770:	e0bffd17 	ldw	r2,-12(fp)
  205774:	10000616 	blt	r2,zero,205790 <write+0x3c>
  205778:	e0bffd17 	ldw	r2,-12(fp)
  20577c:	10c00324 	muli	r3,r2,12
  205780:	00800874 	movhi	r2,33
  205784:	10a0e004 	addi	r2,r2,-31872
  205788:	1885883a 	add	r2,r3,r2
  20578c:	00000106 	br	205794 <write+0x40>
  205790:	0005883a 	mov	r2,zero
  205794:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
  205798:	e0bfff17 	ldw	r2,-4(fp)
  20579c:	10002126 	beq	r2,zero,205824 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  2057a0:	e0bfff17 	ldw	r2,-4(fp)
  2057a4:	10800217 	ldw	r2,8(r2)
  2057a8:	108000cc 	andi	r2,r2,3
  2057ac:	10001826 	beq	r2,zero,205810 <write+0xbc>
  2057b0:	e0bfff17 	ldw	r2,-4(fp)
  2057b4:	10800017 	ldw	r2,0(r2)
  2057b8:	10800617 	ldw	r2,24(r2)
  2057bc:	10001426 	beq	r2,zero,205810 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  2057c0:	e0bfff17 	ldw	r2,-4(fp)
  2057c4:	10800017 	ldw	r2,0(r2)
  2057c8:	10800617 	ldw	r2,24(r2)
  2057cc:	e0fffb17 	ldw	r3,-20(fp)
  2057d0:	180d883a 	mov	r6,r3
  2057d4:	e17ffc17 	ldw	r5,-16(fp)
  2057d8:	e13fff17 	ldw	r4,-4(fp)
  2057dc:	103ee83a 	callr	r2
  2057e0:	e0bffe15 	stw	r2,-8(fp)
  2057e4:	e0bffe17 	ldw	r2,-8(fp)
  2057e8:	1000070e 	bge	r2,zero,205808 <write+0xb4>
      {
        ALT_ERRNO = -rval;
  2057ec:	02057180 	call	205718 <alt_get_errno>
  2057f0:	1007883a 	mov	r3,r2
  2057f4:	e0bffe17 	ldw	r2,-8(fp)
  2057f8:	0085c83a 	sub	r2,zero,r2
  2057fc:	18800015 	stw	r2,0(r3)
        return -1;
  205800:	00bfffc4 	movi	r2,-1
  205804:	00000c06 	br	205838 <write+0xe4>
      }
      return rval;
  205808:	e0bffe17 	ldw	r2,-8(fp)
  20580c:	00000a06 	br	205838 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
  205810:	02057180 	call	205718 <alt_get_errno>
  205814:	1007883a 	mov	r3,r2
  205818:	00800344 	movi	r2,13
  20581c:	18800015 	stw	r2,0(r3)
  205820:	00000406 	br	205834 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  205824:	02057180 	call	205718 <alt_get_errno>
  205828:	1007883a 	mov	r3,r2
  20582c:	00801444 	movi	r2,81
  205830:	18800015 	stw	r2,0(r3)
  }
  return -1;
  205834:	00bfffc4 	movi	r2,-1
}
  205838:	e037883a 	mov	sp,fp
  20583c:	dfc00117 	ldw	ra,4(sp)
  205840:	df000017 	ldw	fp,0(sp)
  205844:	dec00204 	addi	sp,sp,8
  205848:	f800283a 	ret

0020584c <alt_dev_reg>:
  20584c:	defffd04 	addi	sp,sp,-12
  205850:	dfc00215 	stw	ra,8(sp)
  205854:	df000115 	stw	fp,4(sp)
  205858:	df000104 	addi	fp,sp,4
  20585c:	e13fff15 	stw	r4,-4(fp)
  205860:	d1600504 	addi	r5,gp,-32748
  205864:	e13fff17 	ldw	r4,-4(fp)
  205868:	0206e740 	call	206e74 <alt_dev_llist_insert>
  20586c:	e037883a 	mov	sp,fp
  205870:	dfc00117 	ldw	ra,4(sp)
  205874:	df000017 	ldw	fp,0(sp)
  205878:	dec00204 	addi	sp,sp,8
  20587c:	f800283a 	ret

00205880 <alt_irq_init>:
{
  205880:	defffd04 	addi	sp,sp,-12
  205884:	dfc00215 	stw	ra,8(sp)
  205888:	df000115 	stw	fp,4(sp)
  20588c:	df000104 	addi	fp,sp,4
  205890:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( HYPERVISOR, hypervisor);
  205894:	02077f40 	call	2077f4 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  205898:	00800044 	movi	r2,1
  20589c:	1001703a 	wrctl	status,r2
}
  2058a0:	0001883a 	nop
}
  2058a4:	0001883a 	nop
  2058a8:	e037883a 	mov	sp,fp
  2058ac:	dfc00117 	ldw	ra,4(sp)
  2058b0:	df000017 	ldw	fp,0(sp)
  2058b4:	dec00204 	addi	sp,sp,8
  2058b8:	f800283a 	ret

002058bc <alt_sys_init>:
{
  2058bc:	defffe04 	addi	sp,sp,-8
  2058c0:	dfc00115 	stw	ra,4(sp)
  2058c4:	df000015 	stw	fp,0(sp)
  2058c8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
  2058cc:	01800044 	movi	r6,1
  2058d0:	000b883a 	mov	r5,zero
  2058d4:	01000874 	movhi	r4,33
  2058d8:	21214a04 	addi	r4,r4,-31448
  2058dc:	0205a880 	call	205a88 <altera_avalon_jtag_uart_init>
  2058e0:	01000874 	movhi	r4,33
  2058e4:	21214004 	addi	r4,r4,-31488
  2058e8:	020584c0 	call	20584c <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_RS, uart_rs);
  2058ec:	000d883a 	mov	r6,zero
  2058f0:	000b883a 	mov	r5,zero
  2058f4:	01000874 	movhi	r4,33
  2058f8:	21256204 	addi	r4,r4,-27256
  2058fc:	02064b80 	call	2064b8 <altera_avalon_uart_init>
  205900:	01000874 	movhi	r4,33
  205904:	21255804 	addi	r4,r4,-27296
  205908:	020584c0 	call	20584c <alt_dev_reg>
}
  20590c:	0001883a 	nop
  205910:	e037883a 	mov	sp,fp
  205914:	dfc00117 	ldw	ra,4(sp)
  205918:	df000017 	ldw	fp,0(sp)
  20591c:	dec00204 	addi	sp,sp,8
  205920:	f800283a 	ret

00205924 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  205924:	defffa04 	addi	sp,sp,-24
  205928:	dfc00515 	stw	ra,20(sp)
  20592c:	df000415 	stw	fp,16(sp)
  205930:	df000404 	addi	fp,sp,16
  205934:	e13ffe15 	stw	r4,-8(fp)
  205938:	e17ffd15 	stw	r5,-12(fp)
  20593c:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  205940:	e0bffe17 	ldw	r2,-8(fp)
  205944:	10800017 	ldw	r2,0(r2)
  205948:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  20594c:	e0bfff17 	ldw	r2,-4(fp)
  205950:	10c00a04 	addi	r3,r2,40
  205954:	e0bffe17 	ldw	r2,-8(fp)
  205958:	10800217 	ldw	r2,8(r2)
  20595c:	100f883a 	mov	r7,r2
  205960:	e1bffc17 	ldw	r6,-16(fp)
  205964:	e17ffd17 	ldw	r5,-12(fp)
  205968:	1809883a 	mov	r4,r3
  20596c:	0205f600 	call	205f60 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  205970:	e037883a 	mov	sp,fp
  205974:	dfc00117 	ldw	ra,4(sp)
  205978:	df000017 	ldw	fp,0(sp)
  20597c:	dec00204 	addi	sp,sp,8
  205980:	f800283a 	ret

00205984 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  205984:	defffa04 	addi	sp,sp,-24
  205988:	dfc00515 	stw	ra,20(sp)
  20598c:	df000415 	stw	fp,16(sp)
  205990:	df000404 	addi	fp,sp,16
  205994:	e13ffe15 	stw	r4,-8(fp)
  205998:	e17ffd15 	stw	r5,-12(fp)
  20599c:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  2059a0:	e0bffe17 	ldw	r2,-8(fp)
  2059a4:	10800017 	ldw	r2,0(r2)
  2059a8:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  2059ac:	e0bfff17 	ldw	r2,-4(fp)
  2059b0:	10c00a04 	addi	r3,r2,40
  2059b4:	e0bffe17 	ldw	r2,-8(fp)
  2059b8:	10800217 	ldw	r2,8(r2)
  2059bc:	100f883a 	mov	r7,r2
  2059c0:	e1bffc17 	ldw	r6,-16(fp)
  2059c4:	e17ffd17 	ldw	r5,-12(fp)
  2059c8:	1809883a 	mov	r4,r3
  2059cc:	02061800 	call	206180 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  2059d0:	e037883a 	mov	sp,fp
  2059d4:	dfc00117 	ldw	ra,4(sp)
  2059d8:	df000017 	ldw	fp,0(sp)
  2059dc:	dec00204 	addi	sp,sp,8
  2059e0:	f800283a 	ret

002059e4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  2059e4:	defffc04 	addi	sp,sp,-16
  2059e8:	dfc00315 	stw	ra,12(sp)
  2059ec:	df000215 	stw	fp,8(sp)
  2059f0:	df000204 	addi	fp,sp,8
  2059f4:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  2059f8:	e0bffe17 	ldw	r2,-8(fp)
  2059fc:	10800017 	ldw	r2,0(r2)
  205a00:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  205a04:	e0bfff17 	ldw	r2,-4(fp)
  205a08:	10c00a04 	addi	r3,r2,40
  205a0c:	e0bffe17 	ldw	r2,-8(fp)
  205a10:	10800217 	ldw	r2,8(r2)
  205a14:	100b883a 	mov	r5,r2
  205a18:	1809883a 	mov	r4,r3
  205a1c:	0205e040 	call	205e04 <altera_avalon_jtag_uart_close>
}
  205a20:	e037883a 	mov	sp,fp
  205a24:	dfc00117 	ldw	ra,4(sp)
  205a28:	df000017 	ldw	fp,0(sp)
  205a2c:	dec00204 	addi	sp,sp,8
  205a30:	f800283a 	ret

00205a34 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  205a34:	defffa04 	addi	sp,sp,-24
  205a38:	dfc00515 	stw	ra,20(sp)
  205a3c:	df000415 	stw	fp,16(sp)
  205a40:	df000404 	addi	fp,sp,16
  205a44:	e13ffe15 	stw	r4,-8(fp)
  205a48:	e17ffd15 	stw	r5,-12(fp)
  205a4c:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  205a50:	e0bffe17 	ldw	r2,-8(fp)
  205a54:	10800017 	ldw	r2,0(r2)
  205a58:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  205a5c:	e0bfff17 	ldw	r2,-4(fp)
  205a60:	10800a04 	addi	r2,r2,40
  205a64:	e1bffc17 	ldw	r6,-16(fp)
  205a68:	e17ffd17 	ldw	r5,-12(fp)
  205a6c:	1009883a 	mov	r4,r2
  205a70:	0205e6c0 	call	205e6c <altera_avalon_jtag_uart_ioctl>
}
  205a74:	e037883a 	mov	sp,fp
  205a78:	dfc00117 	ldw	ra,4(sp)
  205a7c:	df000017 	ldw	fp,0(sp)
  205a80:	dec00204 	addi	sp,sp,8
  205a84:	f800283a 	ret

00205a88 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  205a88:	defffa04 	addi	sp,sp,-24
  205a8c:	dfc00515 	stw	ra,20(sp)
  205a90:	df000415 	stw	fp,16(sp)
  205a94:	df000404 	addi	fp,sp,16
  205a98:	e13fff15 	stw	r4,-4(fp)
  205a9c:	e17ffe15 	stw	r5,-8(fp)
  205aa0:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  205aa4:	e0bfff17 	ldw	r2,-4(fp)
  205aa8:	00c00044 	movi	r3,1
  205aac:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  205ab0:	e0bfff17 	ldw	r2,-4(fp)
  205ab4:	10800017 	ldw	r2,0(r2)
  205ab8:	10800104 	addi	r2,r2,4
  205abc:	1007883a 	mov	r3,r2
  205ac0:	e0bfff17 	ldw	r2,-4(fp)
  205ac4:	10800817 	ldw	r2,32(r2)
  205ac8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  205acc:	e0bffe17 	ldw	r2,-8(fp)
  205ad0:	e0fffd17 	ldw	r3,-12(fp)
  205ad4:	d8000015 	stw	zero,0(sp)
  205ad8:	e1ffff17 	ldw	r7,-4(fp)
  205adc:	01800834 	movhi	r6,32
  205ae0:	3196d204 	addi	r6,r6,23368
  205ae4:	180b883a 	mov	r5,r3
  205ae8:	1009883a 	mov	r4,r2
  205aec:	02070180 	call	207018 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  205af0:	e0bfff17 	ldw	r2,-4(fp)
  205af4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  205af8:	e0bfff17 	ldw	r2,-4(fp)
  205afc:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  205b00:	d0e62517 	ldw	r3,-26476(gp)
  205b04:	e1ffff17 	ldw	r7,-4(fp)
  205b08:	01800834 	movhi	r6,32
  205b0c:	31975704 	addi	r6,r6,23900
  205b10:	180b883a 	mov	r5,r3
  205b14:	1009883a 	mov	r4,r2
  205b18:	0206c8c0 	call	206c8c <alt_alarm_start>
  205b1c:	1000040e 	bge	r2,zero,205b30 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  205b20:	e0ffff17 	ldw	r3,-4(fp)
  205b24:	00a00034 	movhi	r2,32768
  205b28:	10bfffc4 	addi	r2,r2,-1
  205b2c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  205b30:	0001883a 	nop
  205b34:	e037883a 	mov	sp,fp
  205b38:	dfc00117 	ldw	ra,4(sp)
  205b3c:	df000017 	ldw	fp,0(sp)
  205b40:	dec00204 	addi	sp,sp,8
  205b44:	f800283a 	ret

00205b48 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  205b48:	defff704 	addi	sp,sp,-36
  205b4c:	df000815 	stw	fp,32(sp)
  205b50:	df000804 	addi	fp,sp,32
  205b54:	e13ff815 	stw	r4,-32(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  205b58:	e0bff817 	ldw	r2,-32(fp)
  205b5c:	e0bffc15 	stw	r2,-16(fp)
  unsigned int base = sp->base;
  205b60:	e0bffc17 	ldw	r2,-16(fp)
  205b64:	10800017 	ldw	r2,0(r2)
  205b68:	e0bffb15 	stw	r2,-20(fp)
  unsigned int postflag=0;
  205b6c:	e03fff15 	stw	zero,-4(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  205b70:	e0bffb17 	ldw	r2,-20(fp)
  205b74:	10800104 	addi	r2,r2,4
  205b78:	10800037 	ldwio	r2,0(r2)
  205b7c:	e0bffa15 	stw	r2,-24(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  205b80:	e0bffa17 	ldw	r2,-24(fp)
  205b84:	1080c00c 	andi	r2,r2,768
  205b88:	10006e26 	beq	r2,zero,205d44 <altera_avalon_jtag_uart_irq+0x1fc>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  205b8c:	e0bffa17 	ldw	r2,-24(fp)
  205b90:	1080400c 	andi	r2,r2,256
  205b94:	10003526 	beq	r2,zero,205c6c <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  205b98:	00800074 	movhi	r2,1
  205b9c:	e0bffe15 	stw	r2,-8(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  205ba0:	e0bffc17 	ldw	r2,-16(fp)
  205ba4:	10800a17 	ldw	r2,40(r2)
  205ba8:	10800044 	addi	r2,r2,1
  205bac:	1081ffcc 	andi	r2,r2,2047
  205bb0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
  205bb4:	e0bffc17 	ldw	r2,-16(fp)
  205bb8:	10800b17 	ldw	r2,44(r2)
  205bbc:	e0fff917 	ldw	r3,-28(fp)
  205bc0:	18801526 	beq	r3,r2,205c18 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  205bc4:	e0bffb17 	ldw	r2,-20(fp)
  205bc8:	10800037 	ldwio	r2,0(r2)
  205bcc:	e0bffe15 	stw	r2,-8(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  205bd0:	e0bffe17 	ldw	r2,-8(fp)
  205bd4:	10a0000c 	andi	r2,r2,32768
  205bd8:	10001126 	beq	r2,zero,205c20 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  205bdc:	e0bffc17 	ldw	r2,-16(fp)
  205be0:	10800a17 	ldw	r2,40(r2)
  205be4:	e0fffe17 	ldw	r3,-8(fp)
  205be8:	1809883a 	mov	r4,r3
  205bec:	e0fffc17 	ldw	r3,-16(fp)
  205bf0:	1885883a 	add	r2,r3,r2
  205bf4:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  205bf8:	e0bffc17 	ldw	r2,-16(fp)
  205bfc:	10800a17 	ldw	r2,40(r2)
  205c00:	10800044 	addi	r2,r2,1
  205c04:	10c1ffcc 	andi	r3,r2,2047
  205c08:	e0bffc17 	ldw	r2,-16(fp)
  205c0c:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  205c10:	0001883a 	nop
      {
  205c14:	003fe206 	br	205ba0 <altera_avalon_jtag_uart_irq+0x58>
          break;
  205c18:	0001883a 	nop
  205c1c:	00000106 	br	205c24 <altera_avalon_jtag_uart_irq+0xdc>
          break;
  205c20:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, ALT_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  205c24:	e0bffe17 	ldw	r2,-8(fp)
  205c28:	00ffffd4 	movui	r3,65535
  205c2c:	18800f2e 	bgeu	r3,r2,205c6c <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  205c30:	e0bffc17 	ldw	r2,-16(fp)
  205c34:	10c00817 	ldw	r3,32(r2)
  205c38:	00bfff84 	movi	r2,-2
  205c3c:	1886703a 	and	r3,r3,r2
  205c40:	e0bffc17 	ldw	r2,-16(fp)
  205c44:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  205c48:	e0bffb17 	ldw	r2,-20(fp)
  205c4c:	10800104 	addi	r2,r2,4
  205c50:	1007883a 	mov	r3,r2
  205c54:	e0bffc17 	ldw	r2,-16(fp)
  205c58:	10800817 	ldw	r2,32(r2)
  205c5c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  205c60:	e0bffb17 	ldw	r2,-20(fp)
  205c64:	10800104 	addi	r2,r2,4
  205c68:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  205c6c:	e0bffa17 	ldw	r2,-24(fp)
  205c70:	1080800c 	andi	r2,r2,512
  205c74:	103fbe26 	beq	r2,zero,205b70 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  205c78:	e0bffa17 	ldw	r2,-24(fp)
  205c7c:	1004d43a 	srli	r2,r2,16
  205c80:	e0bffd15 	stw	r2,-12(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  205c84:	00001506 	br	205cdc <altera_avalon_jtag_uart_irq+0x194>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  205c88:	e0bffb17 	ldw	r2,-20(fp)
  205c8c:	e0fffc17 	ldw	r3,-16(fp)
  205c90:	18c00d17 	ldw	r3,52(r3)
  205c94:	e13ffc17 	ldw	r4,-16(fp)
  205c98:	20c7883a 	add	r3,r4,r3
  205c9c:	18c20e03 	ldbu	r3,2104(r3)
  205ca0:	18c03fcc 	andi	r3,r3,255
  205ca4:	18c0201c 	xori	r3,r3,128
  205ca8:	18ffe004 	addi	r3,r3,-128
  205cac:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  205cb0:	e0bffc17 	ldw	r2,-16(fp)
  205cb4:	10800d17 	ldw	r2,52(r2)
  205cb8:	10800044 	addi	r2,r2,1
  205cbc:	10c1ffcc 	andi	r3,r2,2047
  205cc0:	e0bffc17 	ldw	r2,-16(fp)
  205cc4:	10c00d15 	stw	r3,52(r2)
        
        /* indicate that the ALT_FLAG_POST routine must be called */
        postflag=1;
  205cc8:	00800044 	movi	r2,1
  205ccc:	e0bfff15 	stw	r2,-4(fp)

        space--;
  205cd0:	e0bffd17 	ldw	r2,-12(fp)
  205cd4:	10bfffc4 	addi	r2,r2,-1
  205cd8:	e0bffd15 	stw	r2,-12(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
  205cdc:	e0bffd17 	ldw	r2,-12(fp)
  205ce0:	10000526 	beq	r2,zero,205cf8 <altera_avalon_jtag_uart_irq+0x1b0>
  205ce4:	e0bffc17 	ldw	r2,-16(fp)
  205ce8:	10c00d17 	ldw	r3,52(r2)
  205cec:	e0bffc17 	ldw	r2,-16(fp)
  205cf0:	10800c17 	ldw	r2,48(r2)
  205cf4:	18bfe41e 	bne	r3,r2,205c88 <altera_avalon_jtag_uart_irq+0x140>
      {
        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, ALT_FLAG_SET);
      }

      if (space > 0)
  205cf8:	e0bffd17 	ldw	r2,-12(fp)
  205cfc:	103f9c26 	beq	r2,zero,205b70 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  205d00:	e0bffc17 	ldw	r2,-16(fp)
  205d04:	10c00817 	ldw	r3,32(r2)
  205d08:	00bfff44 	movi	r2,-3
  205d0c:	1886703a 	and	r3,r3,r2
  205d10:	e0bffc17 	ldw	r2,-16(fp)
  205d14:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  205d18:	e0bffc17 	ldw	r2,-16(fp)
  205d1c:	10800017 	ldw	r2,0(r2)
  205d20:	10800104 	addi	r2,r2,4
  205d24:	1007883a 	mov	r3,r2
  205d28:	e0bffc17 	ldw	r2,-16(fp)
  205d2c:	10800817 	ldw	r2,32(r2)
  205d30:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  205d34:	e0bffb17 	ldw	r2,-20(fp)
  205d38:	10800104 	addi	r2,r2,4
  205d3c:	10800037 	ldwio	r2,0(r2)
  {
  205d40:	003f8b06 	br	205b70 <altera_avalon_jtag_uart_irq+0x28>
      break;
  205d44:	0001883a 	nop
      }
    }
  }
}
  205d48:	0001883a 	nop
  205d4c:	e037883a 	mov	sp,fp
  205d50:	df000017 	ldw	fp,0(sp)
  205d54:	dec00104 	addi	sp,sp,4
  205d58:	f800283a 	ret

00205d5c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  205d5c:	defffc04 	addi	sp,sp,-16
  205d60:	df000315 	stw	fp,12(sp)
  205d64:	df000304 	addi	fp,sp,12
  205d68:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  205d6c:	e0bffd17 	ldw	r2,-12(fp)
  205d70:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  205d74:	e0bfff17 	ldw	r2,-4(fp)
  205d78:	10800017 	ldw	r2,0(r2)
  205d7c:	10800104 	addi	r2,r2,4
  205d80:	10800037 	ldwio	r2,0(r2)
  205d84:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  205d88:	e0bffe17 	ldw	r2,-8(fp)
  205d8c:	1081000c 	andi	r2,r2,1024
  205d90:	10000b26 	beq	r2,zero,205dc0 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  205d94:	e0bfff17 	ldw	r2,-4(fp)
  205d98:	10800017 	ldw	r2,0(r2)
  205d9c:	10800104 	addi	r2,r2,4
  205da0:	1007883a 	mov	r3,r2
  205da4:	e0bfff17 	ldw	r2,-4(fp)
  205da8:	10800817 	ldw	r2,32(r2)
  205dac:	10810014 	ori	r2,r2,1024
  205db0:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  205db4:	e0bfff17 	ldw	r2,-4(fp)
  205db8:	10000915 	stw	zero,36(r2)
  205dbc:	00000c06 	br	205df0 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  205dc0:	e0bfff17 	ldw	r2,-4(fp)
  205dc4:	10c00917 	ldw	r3,36(r2)
  205dc8:	00a00034 	movhi	r2,32768
  205dcc:	10bfff04 	addi	r2,r2,-4
  205dd0:	10c00736 	bltu	r2,r3,205df0 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
  205dd4:	e0bfff17 	ldw	r2,-4(fp)
  205dd8:	10800917 	ldw	r2,36(r2)
  205ddc:	10c00044 	addi	r3,r2,1
  205de0:	e0bfff17 	ldw	r2,-4(fp)
  205de4:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
  205de8:	e0bfff17 	ldw	r2,-4(fp)
  205dec:	10800917 	ldw	r2,36(r2)
  205df0:	d0a62517 	ldw	r2,-26476(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, ALT_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  205df4:	e037883a 	mov	sp,fp
  205df8:	df000017 	ldw	fp,0(sp)
  205dfc:	dec00104 	addi	sp,sp,4
  205e00:	f800283a 	ret

00205e04 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  205e04:	defffd04 	addi	sp,sp,-12
  205e08:	df000215 	stw	fp,8(sp)
  205e0c:	df000204 	addi	fp,sp,8
  205e10:	e13fff15 	stw	r4,-4(fp)
  205e14:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  205e18:	00000506 	br	205e30 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  205e1c:	e0bffe17 	ldw	r2,-8(fp)
  205e20:	1090000c 	andi	r2,r2,16384
  205e24:	10000226 	beq	r2,zero,205e30 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  205e28:	00bffd44 	movi	r2,-11
  205e2c:	00000b06 	br	205e5c <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  205e30:	e0bfff17 	ldw	r2,-4(fp)
  205e34:	10c00d17 	ldw	r3,52(r2)
  205e38:	e0bfff17 	ldw	r2,-4(fp)
  205e3c:	10800c17 	ldw	r2,48(r2)
  205e40:	18800526 	beq	r3,r2,205e58 <altera_avalon_jtag_uart_close+0x54>
  205e44:	e0bfff17 	ldw	r2,-4(fp)
  205e48:	10c00917 	ldw	r3,36(r2)
  205e4c:	e0bfff17 	ldw	r2,-4(fp)
  205e50:	10800117 	ldw	r2,4(r2)
  205e54:	18bff136 	bltu	r3,r2,205e1c <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
  205e58:	0005883a 	mov	r2,zero
}
  205e5c:	e037883a 	mov	sp,fp
  205e60:	df000017 	ldw	fp,0(sp)
  205e64:	dec00104 	addi	sp,sp,4
  205e68:	f800283a 	ret

00205e6c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  205e6c:	defffa04 	addi	sp,sp,-24
  205e70:	df000515 	stw	fp,20(sp)
  205e74:	df000504 	addi	fp,sp,20
  205e78:	e13ffd15 	stw	r4,-12(fp)
  205e7c:	e17ffc15 	stw	r5,-16(fp)
  205e80:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
  205e84:	00bff9c4 	movi	r2,-25
  205e88:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
  205e8c:	e0bffc17 	ldw	r2,-16(fp)
  205e90:	109a8060 	cmpeqi	r2,r2,27137
  205e94:	1000041e 	bne	r2,zero,205ea8 <altera_avalon_jtag_uart_ioctl+0x3c>
  205e98:	e0bffc17 	ldw	r2,-16(fp)
  205e9c:	109a80a0 	cmpeqi	r2,r2,27138
  205ea0:	1000181e 	bne	r2,zero,205f04 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
  205ea4:	00002906 	br	205f4c <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
  205ea8:	e0bffd17 	ldw	r2,-12(fp)
  205eac:	10c00117 	ldw	r3,4(r2)
  205eb0:	00a00034 	movhi	r2,32768
  205eb4:	10bfffc4 	addi	r2,r2,-1
  205eb8:	18802126 	beq	r3,r2,205f40 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
  205ebc:	e0bffb17 	ldw	r2,-20(fp)
  205ec0:	10800017 	ldw	r2,0(r2)
  205ec4:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  205ec8:	e0bffe17 	ldw	r2,-8(fp)
  205ecc:	10800090 	cmplti	r2,r2,2
  205ed0:	1000061e 	bne	r2,zero,205eec <altera_avalon_jtag_uart_ioctl+0x80>
  205ed4:	e0fffe17 	ldw	r3,-8(fp)
  205ed8:	00a00034 	movhi	r2,32768
  205edc:	10bfffc4 	addi	r2,r2,-1
  205ee0:	18800226 	beq	r3,r2,205eec <altera_avalon_jtag_uart_ioctl+0x80>
  205ee4:	e0bffe17 	ldw	r2,-8(fp)
  205ee8:	00000206 	br	205ef4 <altera_avalon_jtag_uart_ioctl+0x88>
  205eec:	00a00034 	movhi	r2,32768
  205ef0:	10bfff84 	addi	r2,r2,-2
  205ef4:	e0fffd17 	ldw	r3,-12(fp)
  205ef8:	18800115 	stw	r2,4(r3)
      rc = 0;
  205efc:	e03fff15 	stw	zero,-4(fp)
    break;
  205f00:	00000f06 	br	205f40 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
  205f04:	e0bffd17 	ldw	r2,-12(fp)
  205f08:	10c00117 	ldw	r3,4(r2)
  205f0c:	00a00034 	movhi	r2,32768
  205f10:	10bfffc4 	addi	r2,r2,-1
  205f14:	18800c26 	beq	r3,r2,205f48 <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  205f18:	e0bffd17 	ldw	r2,-12(fp)
  205f1c:	10c00917 	ldw	r3,36(r2)
  205f20:	e0bffd17 	ldw	r2,-12(fp)
  205f24:	10800117 	ldw	r2,4(r2)
  205f28:	1885803a 	cmpltu	r2,r3,r2
  205f2c:	10c03fcc 	andi	r3,r2,255
  205f30:	e0bffb17 	ldw	r2,-20(fp)
  205f34:	10c00015 	stw	r3,0(r2)
      rc = 0;
  205f38:	e03fff15 	stw	zero,-4(fp)
    break;
  205f3c:	00000206 	br	205f48 <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
  205f40:	0001883a 	nop
  205f44:	00000106 	br	205f4c <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
  205f48:	0001883a 	nop
  }

  return rc;
  205f4c:	e0bfff17 	ldw	r2,-4(fp)
}
  205f50:	e037883a 	mov	sp,fp
  205f54:	df000017 	ldw	fp,0(sp)
  205f58:	dec00104 	addi	sp,sp,4
  205f5c:	f800283a 	ret

00205f60 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  205f60:	defff304 	addi	sp,sp,-52
  205f64:	dfc00c15 	stw	ra,48(sp)
  205f68:	df000b15 	stw	fp,44(sp)
  205f6c:	df000b04 	addi	fp,sp,44
  205f70:	e13ff815 	stw	r4,-32(fp)
  205f74:	e17ff715 	stw	r5,-36(fp)
  205f78:	e1bff615 	stw	r6,-40(fp)
  205f7c:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
  205f80:	e0bff717 	ldw	r2,-36(fp)
  205f84:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  205f88:	00004706 	br	2060a8 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  205f8c:	e0bff817 	ldw	r2,-32(fp)
  205f90:	10800a17 	ldw	r2,40(r2)
  205f94:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
  205f98:	e0bff817 	ldw	r2,-32(fp)
  205f9c:	10800b17 	ldw	r2,44(r2)
  205fa0:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
  205fa4:	e0fffd17 	ldw	r3,-12(fp)
  205fa8:	e0bffc17 	ldw	r2,-16(fp)
  205fac:	18800536 	bltu	r3,r2,205fc4 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  205fb0:	e0fffd17 	ldw	r3,-12(fp)
  205fb4:	e0bffc17 	ldw	r2,-16(fp)
  205fb8:	1885c83a 	sub	r2,r3,r2
  205fbc:	e0bffe15 	stw	r2,-8(fp)
  205fc0:	00000406 	br	205fd4 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  205fc4:	00c20004 	movi	r3,2048
  205fc8:	e0bffc17 	ldw	r2,-16(fp)
  205fcc:	1885c83a 	sub	r2,r3,r2
  205fd0:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
  205fd4:	e0bffe17 	ldw	r2,-8(fp)
  205fd8:	10001e26 	beq	r2,zero,206054 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  205fdc:	e0fff617 	ldw	r3,-40(fp)
  205fe0:	e0bffe17 	ldw	r2,-8(fp)
  205fe4:	1880022e 	bgeu	r3,r2,205ff0 <altera_avalon_jtag_uart_read+0x90>
        n = space;
  205fe8:	e0bff617 	ldw	r2,-40(fp)
  205fec:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  205ff0:	e0bff817 	ldw	r2,-32(fp)
  205ff4:	10c00e04 	addi	r3,r2,56
  205ff8:	e0bffc17 	ldw	r2,-16(fp)
  205ffc:	1885883a 	add	r2,r3,r2
  206000:	e1bffe17 	ldw	r6,-8(fp)
  206004:	100b883a 	mov	r5,r2
  206008:	e13fff17 	ldw	r4,-4(fp)
  20600c:	02018100 	call	201810 <memcpy>
      ptr   += n;
  206010:	e0ffff17 	ldw	r3,-4(fp)
  206014:	e0bffe17 	ldw	r2,-8(fp)
  206018:	1885883a 	add	r2,r3,r2
  20601c:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
  206020:	e0fff617 	ldw	r3,-40(fp)
  206024:	e0bffe17 	ldw	r2,-8(fp)
  206028:	1885c83a 	sub	r2,r3,r2
  20602c:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  206030:	e0fffc17 	ldw	r3,-16(fp)
  206034:	e0bffe17 	ldw	r2,-8(fp)
  206038:	1885883a 	add	r2,r3,r2
  20603c:	10c1ffcc 	andi	r3,r2,2047
  206040:	e0bff817 	ldw	r2,-32(fp)
  206044:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  206048:	e0bff617 	ldw	r2,-40(fp)
  20604c:	00bfcf16 	blt	zero,r2,205f8c <altera_avalon_jtag_uart_read+0x2c>
  206050:	00000106 	br	206058 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
  206054:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
  206058:	e0ffff17 	ldw	r3,-4(fp)
  20605c:	e0bff717 	ldw	r2,-36(fp)
  206060:	1880141e 	bne	r3,r2,2060b4 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  206064:	e0bff517 	ldw	r2,-44(fp)
  206068:	1090000c 	andi	r2,r2,16384
  20606c:	1000131e 	bne	r2,zero,2060bc <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  206070:	0001883a 	nop
  206074:	e0bff817 	ldw	r2,-32(fp)
  206078:	10800a17 	ldw	r2,40(r2)
  20607c:	e0fffd17 	ldw	r3,-12(fp)
  206080:	1880051e 	bne	r3,r2,206098 <altera_avalon_jtag_uart_read+0x138>
  206084:	e0bff817 	ldw	r2,-32(fp)
  206088:	10c00917 	ldw	r3,36(r2)
  20608c:	e0bff817 	ldw	r2,-32(fp)
  206090:	10800117 	ldw	r2,4(r2)
  206094:	18bff736 	bltu	r3,r2,206074 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  206098:	e0bff817 	ldw	r2,-32(fp)
  20609c:	10800a17 	ldw	r2,40(r2)
  2060a0:	e0fffd17 	ldw	r3,-12(fp)
  2060a4:	18800726 	beq	r3,r2,2060c4 <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
  2060a8:	e0bff617 	ldw	r2,-40(fp)
  2060ac:	00bfb716 	blt	zero,r2,205f8c <altera_avalon_jtag_uart_read+0x2c>
  2060b0:	00000506 	br	2060c8 <altera_avalon_jtag_uart_read+0x168>
      break;
  2060b4:	0001883a 	nop
  2060b8:	00000306 	br	2060c8 <altera_avalon_jtag_uart_read+0x168>
      break;
  2060bc:	0001883a 	nop
  2060c0:	00000106 	br	2060c8 <altera_avalon_jtag_uart_read+0x168>
      break;
  2060c4:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  2060c8:	e0ffff17 	ldw	r3,-4(fp)
  2060cc:	e0bff717 	ldw	r2,-36(fp)
  2060d0:	18801926 	beq	r3,r2,206138 <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
  2060d4:	0005303a 	rdctl	r2,status
  2060d8:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2060dc:	e0fff917 	ldw	r3,-28(fp)
  2060e0:	00bfff84 	movi	r2,-2
  2060e4:	1884703a 	and	r2,r3,r2
  2060e8:	1001703a 	wrctl	status,r2
  return context;
  2060ec:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  2060f0:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  2060f4:	e0bff817 	ldw	r2,-32(fp)
  2060f8:	10800817 	ldw	r2,32(r2)
  2060fc:	10c00054 	ori	r3,r2,1
  206100:	e0bff817 	ldw	r2,-32(fp)
  206104:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  206108:	e0bff817 	ldw	r2,-32(fp)
  20610c:	10800017 	ldw	r2,0(r2)
  206110:	10800104 	addi	r2,r2,4
  206114:	1007883a 	mov	r3,r2
  206118:	e0bff817 	ldw	r2,-32(fp)
  20611c:	10800817 	ldw	r2,32(r2)
  206120:	18800035 	stwio	r2,0(r3)
  206124:	e0bffb17 	ldw	r2,-20(fp)
  206128:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
  20612c:	e0bffa17 	ldw	r2,-24(fp)
  206130:	1001703a 	wrctl	status,r2
}
  206134:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  206138:	e0ffff17 	ldw	r3,-4(fp)
  20613c:	e0bff717 	ldw	r2,-36(fp)
  206140:	18800426 	beq	r3,r2,206154 <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
  206144:	e0ffff17 	ldw	r3,-4(fp)
  206148:	e0bff717 	ldw	r2,-36(fp)
  20614c:	1885c83a 	sub	r2,r3,r2
  206150:	00000606 	br	20616c <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
  206154:	e0bff517 	ldw	r2,-44(fp)
  206158:	1090000c 	andi	r2,r2,16384
  20615c:	10000226 	beq	r2,zero,206168 <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
  206160:	00bffd44 	movi	r2,-11
  206164:	00000106 	br	20616c <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
  206168:	00bffec4 	movi	r2,-5
}
  20616c:	e037883a 	mov	sp,fp
  206170:	dfc00117 	ldw	ra,4(sp)
  206174:	df000017 	ldw	fp,0(sp)
  206178:	dec00204 	addi	sp,sp,8
  20617c:	f800283a 	ret

00206180 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  206180:	defff304 	addi	sp,sp,-52
  206184:	dfc00c15 	stw	ra,48(sp)
  206188:	df000b15 	stw	fp,44(sp)
  20618c:	df000b04 	addi	fp,sp,44
  206190:	e13ff815 	stw	r4,-32(fp)
  206194:	e17ff715 	stw	r5,-36(fp)
  206198:	e1bff615 	stw	r6,-40(fp)
  20619c:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  2061a0:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  2061a4:	e0bff717 	ldw	r2,-36(fp)
  2061a8:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  2061ac:	00003706 	br	20628c <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  2061b0:	e0bff817 	ldw	r2,-32(fp)
  2061b4:	10800c17 	ldw	r2,48(r2)
  2061b8:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
  2061bc:	e0bff817 	ldw	r2,-32(fp)
  2061c0:	10800d17 	ldw	r2,52(r2)
  2061c4:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
  2061c8:	e0fffc17 	ldw	r3,-16(fp)
  2061cc:	e0bfff17 	ldw	r2,-4(fp)
  2061d0:	1880062e 	bgeu	r3,r2,2061ec <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  2061d4:	e0ffff17 	ldw	r3,-4(fp)
  2061d8:	e0bffc17 	ldw	r2,-16(fp)
  2061dc:	1885c83a 	sub	r2,r3,r2
  2061e0:	10bfffc4 	addi	r2,r2,-1
  2061e4:	e0bffe15 	stw	r2,-8(fp)
  2061e8:	00000b06 	br	206218 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  2061ec:	e0bfff17 	ldw	r2,-4(fp)
  2061f0:	10000526 	beq	r2,zero,206208 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  2061f4:	00c20004 	movi	r3,2048
  2061f8:	e0bffc17 	ldw	r2,-16(fp)
  2061fc:	1885c83a 	sub	r2,r3,r2
  206200:	e0bffe15 	stw	r2,-8(fp)
  206204:	00000406 	br	206218 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  206208:	00c1ffc4 	movi	r3,2047
  20620c:	e0bffc17 	ldw	r2,-16(fp)
  206210:	1885c83a 	sub	r2,r3,r2
  206214:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
  206218:	e0bffe17 	ldw	r2,-8(fp)
  20621c:	10001e26 	beq	r2,zero,206298 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  206220:	e0fff617 	ldw	r3,-40(fp)
  206224:	e0bffe17 	ldw	r2,-8(fp)
  206228:	1880022e 	bgeu	r3,r2,206234 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  20622c:	e0bff617 	ldw	r2,-40(fp)
  206230:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  206234:	e0bff817 	ldw	r2,-32(fp)
  206238:	10c20e04 	addi	r3,r2,2104
  20623c:	e0bffc17 	ldw	r2,-16(fp)
  206240:	1885883a 	add	r2,r3,r2
  206244:	e1bffe17 	ldw	r6,-8(fp)
  206248:	e17ff717 	ldw	r5,-36(fp)
  20624c:	1009883a 	mov	r4,r2
  206250:	02018100 	call	201810 <memcpy>
      ptr   += n;
  206254:	e0fff717 	ldw	r3,-36(fp)
  206258:	e0bffe17 	ldw	r2,-8(fp)
  20625c:	1885883a 	add	r2,r3,r2
  206260:	e0bff715 	stw	r2,-36(fp)
      count -= n;
  206264:	e0fff617 	ldw	r3,-40(fp)
  206268:	e0bffe17 	ldw	r2,-8(fp)
  20626c:	1885c83a 	sub	r2,r3,r2
  206270:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  206274:	e0fffc17 	ldw	r3,-16(fp)
  206278:	e0bffe17 	ldw	r2,-8(fp)
  20627c:	1885883a 	add	r2,r3,r2
  206280:	10c1ffcc 	andi	r3,r2,2047
  206284:	e0bff817 	ldw	r2,-32(fp)
  206288:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
  20628c:	e0bff617 	ldw	r2,-40(fp)
  206290:	00bfc716 	blt	zero,r2,2061b0 <altera_avalon_jtag_uart_write+0x30>
  206294:	00000106 	br	20629c <altera_avalon_jtag_uart_write+0x11c>
        break;
  206298:	0001883a 	nop
  NIOS2_READ_STATUS (context);
  20629c:	0005303a 	rdctl	r2,status
  2062a0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2062a4:	e0fff917 	ldw	r3,-28(fp)
  2062a8:	00bfff84 	movi	r2,-2
  2062ac:	1884703a 	and	r2,r3,r2
  2062b0:	1001703a 	wrctl	status,r2
  return context;
  2062b4:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  2062b8:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  2062bc:	e0bff817 	ldw	r2,-32(fp)
  2062c0:	10800817 	ldw	r2,32(r2)
  2062c4:	10c00094 	ori	r3,r2,2
  2062c8:	e0bff817 	ldw	r2,-32(fp)
  2062cc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  2062d0:	e0bff817 	ldw	r2,-32(fp)
  2062d4:	10800017 	ldw	r2,0(r2)
  2062d8:	10800104 	addi	r2,r2,4
  2062dc:	1007883a 	mov	r3,r2
  2062e0:	e0bff817 	ldw	r2,-32(fp)
  2062e4:	10800817 	ldw	r2,32(r2)
  2062e8:	18800035 	stwio	r2,0(r3)
  2062ec:	e0bffb17 	ldw	r2,-20(fp)
  2062f0:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
  2062f4:	e0bffa17 	ldw	r2,-24(fp)
  2062f8:	1001703a 	wrctl	status,r2
}
  2062fc:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  206300:	e0bff617 	ldw	r2,-40(fp)
  206304:	0080100e 	bge	zero,r2,206348 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
  206308:	e0bff517 	ldw	r2,-44(fp)
  20630c:	1090000c 	andi	r2,r2,16384
  206310:	1000101e 	bne	r2,zero,206354 <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  206314:	0001883a 	nop
  206318:	e0bff817 	ldw	r2,-32(fp)
  20631c:	10800d17 	ldw	r2,52(r2)
  206320:	e0ffff17 	ldw	r3,-4(fp)
  206324:	1880051e 	bne	r3,r2,20633c <altera_avalon_jtag_uart_write+0x1bc>
  206328:	e0bff817 	ldw	r2,-32(fp)
  20632c:	10c00917 	ldw	r3,36(r2)
  206330:	e0bff817 	ldw	r2,-32(fp)
  206334:	10800117 	ldw	r2,4(r2)
  206338:	18bff736 	bltu	r3,r2,206318 <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  20633c:	e0bff817 	ldw	r2,-32(fp)
  206340:	10800917 	ldw	r2,36(r2)
  206344:	1000051e 	bne	r2,zero,20635c <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
  206348:	e0bff617 	ldw	r2,-40(fp)
  20634c:	00bfcf16 	blt	zero,r2,20628c <altera_avalon_jtag_uart_write+0x10c>
  206350:	00000306 	br	206360 <altera_avalon_jtag_uart_write+0x1e0>
        break;
  206354:	0001883a 	nop
  206358:	00000106 	br	206360 <altera_avalon_jtag_uart_write+0x1e0>
         break;
  20635c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  206360:	e0fff717 	ldw	r3,-36(fp)
  206364:	e0bffd17 	ldw	r2,-12(fp)
  206368:	18800426 	beq	r3,r2,20637c <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
  20636c:	e0fff717 	ldw	r3,-36(fp)
  206370:	e0bffd17 	ldw	r2,-12(fp)
  206374:	1885c83a 	sub	r2,r3,r2
  206378:	00000606 	br	206394 <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
  20637c:	e0bff517 	ldw	r2,-44(fp)
  206380:	1090000c 	andi	r2,r2,16384
  206384:	10000226 	beq	r2,zero,206390 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
  206388:	00bffd44 	movi	r2,-11
  20638c:	00000106 	br	206394 <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  206390:	00bffec4 	movi	r2,-5
}
  206394:	e037883a 	mov	sp,fp
  206398:	dfc00117 	ldw	ra,4(sp)
  20639c:	df000017 	ldw	fp,0(sp)
  2063a0:	dec00204 	addi	sp,sp,8
  2063a4:	f800283a 	ret

002063a8 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  2063a8:	defffa04 	addi	sp,sp,-24
  2063ac:	dfc00515 	stw	ra,20(sp)
  2063b0:	df000415 	stw	fp,16(sp)
  2063b4:	df000404 	addi	fp,sp,16
  2063b8:	e13ffe15 	stw	r4,-8(fp)
  2063bc:	e17ffd15 	stw	r5,-12(fp)
  2063c0:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  2063c4:	e0bffe17 	ldw	r2,-8(fp)
  2063c8:	10800017 	ldw	r2,0(r2)
  2063cc:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  2063d0:	e0bfff17 	ldw	r2,-4(fp)
  2063d4:	10c00a04 	addi	r3,r2,40
  2063d8:	e0bffe17 	ldw	r2,-8(fp)
  2063dc:	10800217 	ldw	r2,8(r2)
  2063e0:	100f883a 	mov	r7,r2
  2063e4:	e1bffc17 	ldw	r6,-16(fp)
  2063e8:	e17ffd17 	ldw	r5,-12(fp)
  2063ec:	1809883a 	mov	r4,r3
  2063f0:	02068b40 	call	2068b4 <altera_avalon_uart_read>
      fd->fd_flags);
}
  2063f4:	e037883a 	mov	sp,fp
  2063f8:	dfc00117 	ldw	ra,4(sp)
  2063fc:	df000017 	ldw	fp,0(sp)
  206400:	dec00204 	addi	sp,sp,8
  206404:	f800283a 	ret

00206408 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  206408:	defffa04 	addi	sp,sp,-24
  20640c:	dfc00515 	stw	ra,20(sp)
  206410:	df000415 	stw	fp,16(sp)
  206414:	df000404 	addi	fp,sp,16
  206418:	e13ffe15 	stw	r4,-8(fp)
  20641c:	e17ffd15 	stw	r5,-12(fp)
  206420:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  206424:	e0bffe17 	ldw	r2,-8(fp)
  206428:	10800017 	ldw	r2,0(r2)
  20642c:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  206430:	e0bfff17 	ldw	r2,-4(fp)
  206434:	10c00a04 	addi	r3,r2,40
  206438:	e0bffe17 	ldw	r2,-8(fp)
  20643c:	10800217 	ldw	r2,8(r2)
  206440:	100f883a 	mov	r7,r2
  206444:	e1bffc17 	ldw	r6,-16(fp)
  206448:	e17ffd17 	ldw	r5,-12(fp)
  20644c:	1809883a 	mov	r4,r3
  206450:	0206ad80 	call	206ad8 <altera_avalon_uart_write>
      fd->fd_flags);
}
  206454:	e037883a 	mov	sp,fp
  206458:	dfc00117 	ldw	ra,4(sp)
  20645c:	df000017 	ldw	fp,0(sp)
  206460:	dec00204 	addi	sp,sp,8
  206464:	f800283a 	ret

00206468 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  206468:	defffc04 	addi	sp,sp,-16
  20646c:	dfc00315 	stw	ra,12(sp)
  206470:	df000215 	stw	fp,8(sp)
  206474:	df000204 	addi	fp,sp,8
  206478:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  20647c:	e0bffe17 	ldw	r2,-8(fp)
  206480:	10800017 	ldw	r2,0(r2)
  206484:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  206488:	e0bfff17 	ldw	r2,-4(fp)
  20648c:	10c00a04 	addi	r3,r2,40
  206490:	e0bffe17 	ldw	r2,-8(fp)
  206494:	10800217 	ldw	r2,8(r2)
  206498:	100b883a 	mov	r5,r2
  20649c:	1809883a 	mov	r4,r3
  2064a0:	02068240 	call	206824 <altera_avalon_uart_close>
}
  2064a4:	e037883a 	mov	sp,fp
  2064a8:	dfc00117 	ldw	ra,4(sp)
  2064ac:	df000017 	ldw	fp,0(sp)
  2064b0:	dec00204 	addi	sp,sp,8
  2064b4:	f800283a 	ret

002064b8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  2064b8:	defff804 	addi	sp,sp,-32
  2064bc:	dfc00715 	stw	ra,28(sp)
  2064c0:	df000615 	stw	fp,24(sp)
  2064c4:	df000604 	addi	fp,sp,24
  2064c8:	e13ffd15 	stw	r4,-12(fp)
  2064cc:	e17ffc15 	stw	r5,-16(fp)
  2064d0:	e1bffb15 	stw	r6,-20(fp)
  void* base = sp->base;
  2064d4:	e0bffd17 	ldw	r2,-12(fp)
  2064d8:	10800017 	ldw	r2,0(r2)
  2064dc:	e0bfff15 	stw	r2,-4(fp)
  2064e0:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  2064e4:	1000041e 	bne	r2,zero,2064f8 <altera_avalon_uart_init+0x40>
  2064e8:	0005883a 	mov	r2,zero
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  2064ec:	1000021e 	bne	r2,zero,2064f8 <altera_avalon_uart_init+0x40>
  2064f0:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  2064f4:	10000226 	beq	r2,zero,206500 <altera_avalon_uart_init+0x48>
  2064f8:	00800044 	movi	r2,1
  2064fc:	00000106 	br	206504 <altera_avalon_uart_init+0x4c>
  206500:	0005883a 	mov	r2,zero
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  206504:	e0bffe15 	stw	r2,-8(fp)
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  206508:	e0bffe17 	ldw	r2,-8(fp)
  20650c:	10000f1e 	bne	r2,zero,20654c <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  206510:	e0bffd17 	ldw	r2,-12(fp)
  206514:	00c32004 	movi	r3,3200
  206518:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  20651c:	e0bfff17 	ldw	r2,-4(fp)
  206520:	10800304 	addi	r2,r2,12
  206524:	e0fffd17 	ldw	r3,-12(fp)
  206528:	18c00117 	ldw	r3,4(r3)
  20652c:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  206530:	d8000015 	stw	zero,0(sp)
  206534:	e1fffd17 	ldw	r7,-12(fp)
  206538:	01800834 	movhi	r6,32
  20653c:	31995904 	addi	r6,r6,25956
  206540:	e17ffb17 	ldw	r5,-20(fp)
  206544:	e13ffc17 	ldw	r4,-16(fp)
  206548:	02070180 	call	207018 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  20654c:	0001883a 	nop
  206550:	e037883a 	mov	sp,fp
  206554:	dfc00117 	ldw	ra,4(sp)
  206558:	df000017 	ldw	fp,0(sp)
  20655c:	dec00204 	addi	sp,sp,8
  206560:	f800283a 	ret

00206564 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  206564:	defffa04 	addi	sp,sp,-24
  206568:	dfc00515 	stw	ra,20(sp)
  20656c:	df000415 	stw	fp,16(sp)
  206570:	df000404 	addi	fp,sp,16
  206574:	e13ffc15 	stw	r4,-16(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  206578:	e0bffc17 	ldw	r2,-16(fp)
  20657c:	e0bfff15 	stw	r2,-4(fp)
  void* base               = sp->base;
  206580:	e0bfff17 	ldw	r2,-4(fp)
  206584:	10800017 	ldw	r2,0(r2)
  206588:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  20658c:	e0bffe17 	ldw	r2,-8(fp)
  206590:	10800204 	addi	r2,r2,8
  206594:	10800037 	ldwio	r2,0(r2)
  206598:	e0bffd15 	stw	r2,-12(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  20659c:	e0bffe17 	ldw	r2,-8(fp)
  2065a0:	10800204 	addi	r2,r2,8
  2065a4:	0007883a 	mov	r3,zero
  2065a8:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  2065ac:	e0bffe17 	ldw	r2,-8(fp)
  2065b0:	10800204 	addi	r2,r2,8
  2065b4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  2065b8:	e0bffd17 	ldw	r2,-12(fp)
  2065bc:	1080200c 	andi	r2,r2,128
  2065c0:	10000326 	beq	r2,zero,2065d0 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  2065c4:	e17ffd17 	ldw	r5,-12(fp)
  2065c8:	e13fff17 	ldw	r4,-4(fp)
  2065cc:	02066000 	call	206600 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  2065d0:	e0bffd17 	ldw	r2,-12(fp)
  2065d4:	1081100c 	andi	r2,r2,1088
  2065d8:	10000326 	beq	r2,zero,2065e8 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  2065dc:	e17ffd17 	ldw	r5,-12(fp)
  2065e0:	e13fff17 	ldw	r4,-4(fp)
  2065e4:	02066e00 	call	2066e0 <altera_avalon_uart_txirq>
  }
  

}
  2065e8:	0001883a 	nop
  2065ec:	e037883a 	mov	sp,fp
  2065f0:	dfc00117 	ldw	ra,4(sp)
  2065f4:	df000017 	ldw	fp,0(sp)
  2065f8:	dec00204 	addi	sp,sp,8
  2065fc:	f800283a 	ret

00206600 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  206600:	defffc04 	addi	sp,sp,-16
  206604:	df000315 	stw	fp,12(sp)
  206608:	df000304 	addi	fp,sp,12
  20660c:	e13ffe15 	stw	r4,-8(fp)
  206610:	e17ffd15 	stw	r5,-12(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  206614:	e0bffd17 	ldw	r2,-12(fp)
  206618:	108000cc 	andi	r2,r2,3
  20661c:	10002b1e 	bne	r2,zero,2066cc <altera_avalon_uart_rxirq+0xcc>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  206620:	e0bffe17 	ldw	r2,-8(fp)
  206624:	10800317 	ldw	r2,12(r2)
  206628:	e0bffe17 	ldw	r2,-8(fp)
  20662c:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  206630:	e0bffe17 	ldw	r2,-8(fp)
  206634:	10800317 	ldw	r2,12(r2)
  206638:	10800044 	addi	r2,r2,1
  20663c:	10800fcc 	andi	r2,r2,63
  206640:	e0bfff15 	stw	r2,-4(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  206644:	e0bffe17 	ldw	r2,-8(fp)
  206648:	10800017 	ldw	r2,0(r2)
  20664c:	10c00037 	ldwio	r3,0(r2)
  206650:	e0bffe17 	ldw	r2,-8(fp)
  206654:	10800317 	ldw	r2,12(r2)
  206658:	1809883a 	mov	r4,r3
  20665c:	e0fffe17 	ldw	r3,-8(fp)
  206660:	1885883a 	add	r2,r3,r2
  206664:	11000705 	stb	r4,28(r2)

  sp->rx_end = next;
  206668:	e0bffe17 	ldw	r2,-8(fp)
  20666c:	e0ffff17 	ldw	r3,-4(fp)
  206670:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  206674:	e0bffe17 	ldw	r2,-8(fp)
  206678:	10800317 	ldw	r2,12(r2)
  20667c:	10800044 	addi	r2,r2,1
  206680:	10800fcc 	andi	r2,r2,63
  206684:	e0bfff15 	stw	r2,-4(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  206688:	e0bffe17 	ldw	r2,-8(fp)
  20668c:	10800217 	ldw	r2,8(r2)
  206690:	e0ffff17 	ldw	r3,-4(fp)
  206694:	18800e1e 	bne	r3,r2,2066d0 <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  206698:	e0bffe17 	ldw	r2,-8(fp)
  20669c:	10c00117 	ldw	r3,4(r2)
  2066a0:	00bfdfc4 	movi	r2,-129
  2066a4:	1886703a 	and	r3,r3,r2
  2066a8:	e0bffe17 	ldw	r2,-8(fp)
  2066ac:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  2066b0:	e0bffe17 	ldw	r2,-8(fp)
  2066b4:	10800017 	ldw	r2,0(r2)
  2066b8:	10800304 	addi	r2,r2,12
  2066bc:	e0fffe17 	ldw	r3,-8(fp)
  2066c0:	18c00117 	ldw	r3,4(r3)
  2066c4:	10c00035 	stwio	r3,0(r2)
  2066c8:	00000106 	br	2066d0 <altera_avalon_uart_rxirq+0xd0>
    return;
  2066cc:	0001883a 	nop
  }   
}
  2066d0:	e037883a 	mov	sp,fp
  2066d4:	df000017 	ldw	fp,0(sp)
  2066d8:	dec00104 	addi	sp,sp,4
  2066dc:	f800283a 	ret

002066e0 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  2066e0:	defffd04 	addi	sp,sp,-12
  2066e4:	df000215 	stw	fp,8(sp)
  2066e8:	df000204 	addi	fp,sp,8
  2066ec:	e13fff15 	stw	r4,-4(fp)
  2066f0:	e17ffe15 	stw	r5,-8(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  2066f4:	e0bfff17 	ldw	r2,-4(fp)
  2066f8:	10c00417 	ldw	r3,16(r2)
  2066fc:	e0bfff17 	ldw	r2,-4(fp)
  206700:	10800517 	ldw	r2,20(r2)
  206704:	18803126 	beq	r3,r2,2067cc <altera_avalon_uart_txirq+0xec>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  206708:	e0bfff17 	ldw	r2,-4(fp)
  20670c:	10800617 	ldw	r2,24(r2)
  206710:	1080008c 	andi	r2,r2,2
  206714:	10000326 	beq	r2,zero,206724 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  206718:	e0bffe17 	ldw	r2,-8(fp)
  20671c:	1082000c 	andi	r2,r2,2048
    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  206720:	10001c26 	beq	r2,zero,206794 <altera_avalon_uart_txirq+0xb4>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  206724:	e0bfff17 	ldw	r2,-4(fp)
  206728:	10800417 	ldw	r2,16(r2)
  20672c:	e0bfff17 	ldw	r2,-4(fp)
  206730:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  206734:	e0bfff17 	ldw	r2,-4(fp)
  206738:	10800017 	ldw	r2,0(r2)
  20673c:	10800104 	addi	r2,r2,4
  206740:	e0ffff17 	ldw	r3,-4(fp)
  206744:	18c00417 	ldw	r3,16(r3)
  206748:	e13fff17 	ldw	r4,-4(fp)
  20674c:	20c7883a 	add	r3,r4,r3
  206750:	18c01703 	ldbu	r3,92(r3)
  206754:	18c03fcc 	andi	r3,r3,255
  206758:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  20675c:	e0bfff17 	ldw	r2,-4(fp)
  206760:	10800417 	ldw	r2,16(r2)
  206764:	10800044 	addi	r2,r2,1
  206768:	e0ffff17 	ldw	r3,-4(fp)
  20676c:	18800415 	stw	r2,16(r3)
  206770:	10c00fcc 	andi	r3,r2,63
  206774:	e0bfff17 	ldw	r2,-4(fp)
  206778:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  20677c:	e0bfff17 	ldw	r2,-4(fp)
  206780:	10800117 	ldw	r2,4(r2)
  206784:	10c01014 	ori	r3,r2,64
  206788:	e0bfff17 	ldw	r2,-4(fp)
  20678c:	10c00115 	stw	r3,4(r2)
  206790:	00000e06 	br	2067cc <altera_avalon_uart_txirq+0xec>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  206794:	e0bfff17 	ldw	r2,-4(fp)
  206798:	10800017 	ldw	r2,0(r2)
  20679c:	10800204 	addi	r2,r2,8
  2067a0:	10800037 	ldwio	r2,0(r2)
  2067a4:	e0bffe15 	stw	r2,-8(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  2067a8:	e0bffe17 	ldw	r2,-8(fp)
  2067ac:	1082000c 	andi	r2,r2,2048
  2067b0:	1000061e 	bne	r2,zero,2067cc <altera_avalon_uart_txirq+0xec>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  2067b4:	e0bfff17 	ldw	r2,-4(fp)
  2067b8:	10c00117 	ldw	r3,4(r2)
  2067bc:	00bfefc4 	movi	r2,-65
  2067c0:	1886703a 	and	r3,r3,r2
  2067c4:	e0bfff17 	ldw	r2,-4(fp)
  2067c8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  2067cc:	e0bfff17 	ldw	r2,-4(fp)
  2067d0:	10c00417 	ldw	r3,16(r2)
  2067d4:	e0bfff17 	ldw	r2,-4(fp)
  2067d8:	10800517 	ldw	r2,20(r2)
  2067dc:	1880061e 	bne	r3,r2,2067f8 <altera_avalon_uart_txirq+0x118>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  2067e0:	e0bfff17 	ldw	r2,-4(fp)
  2067e4:	10c00117 	ldw	r3,4(r2)
  2067e8:	00beefc4 	movi	r2,-1089
  2067ec:	1886703a 	and	r3,r3,r2
  2067f0:	e0bfff17 	ldw	r2,-4(fp)
  2067f4:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  2067f8:	e0bfff17 	ldw	r2,-4(fp)
  2067fc:	10800017 	ldw	r2,0(r2)
  206800:	10800304 	addi	r2,r2,12
  206804:	e0ffff17 	ldw	r3,-4(fp)
  206808:	18c00117 	ldw	r3,4(r3)
  20680c:	10c00035 	stwio	r3,0(r2)
}
  206810:	0001883a 	nop
  206814:	e037883a 	mov	sp,fp
  206818:	df000017 	ldw	fp,0(sp)
  20681c:	dec00104 	addi	sp,sp,4
  206820:	f800283a 	ret

00206824 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  206824:	defffd04 	addi	sp,sp,-12
  206828:	df000215 	stw	fp,8(sp)
  20682c:	df000204 	addi	fp,sp,8
  206830:	e13fff15 	stw	r4,-4(fp)
  206834:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  206838:	00000506 	br	206850 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  20683c:	e0bffe17 	ldw	r2,-8(fp)
  206840:	1090000c 	andi	r2,r2,16384
  206844:	10000226 	beq	r2,zero,206850 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  206848:	00bffd44 	movi	r2,-11
  20684c:	00000606 	br	206868 <altera_avalon_uart_close+0x44>
  while (sp->tx_start != sp->tx_end) {
  206850:	e0bfff17 	ldw	r2,-4(fp)
  206854:	10c00417 	ldw	r3,16(r2)
  206858:	e0bfff17 	ldw	r2,-4(fp)
  20685c:	10800517 	ldw	r2,20(r2)
  206860:	18bff61e 	bne	r3,r2,20683c <altera_avalon_uart_close+0x18>
    }
  }

  return 0;
  206864:	0005883a 	mov	r2,zero
}
  206868:	e037883a 	mov	sp,fp
  20686c:	df000017 	ldw	fp,0(sp)
  206870:	dec00104 	addi	sp,sp,4
  206874:	f800283a 	ret

00206878 <alt_get_errno>:
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);

    /* clear any error flags */

    IOWR_ALTERA_AVALON_UART_STATUS(sp->base, 0);

  206878:	defffe04 	addi	sp,sp,-8
  20687c:	dfc00115 	stw	ra,4(sp)
  206880:	df000015 	stw	fp,0(sp)
  206884:	d839883a 	mov	fp,sp
    if (status & ALTERA_AVALON_UART_CONTROL_RRDY_MSK)
  206888:	d0a00817 	ldw	r2,-32736(gp)
  20688c:	10000326 	beq	r2,zero,20689c <alt_get_errno+0x24>
  206890:	d0a00817 	ldw	r2,-32736(gp)
  206894:	103ee83a 	callr	r2
  206898:	00000106 	br	2068a0 <alt_get_errno+0x28>
  20689c:	d0a61a04 	addi	r2,gp,-26520
    {
  2068a0:	e037883a 	mov	sp,fp
  2068a4:	dfc00117 	ldw	ra,4(sp)
  2068a8:	df000017 	ldw	fp,0(sp)
  2068ac:	dec00204 	addi	sp,sp,8
  2068b0:	f800283a 	ret

002068b4 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  2068b4:	defff204 	addi	sp,sp,-56
  2068b8:	dfc00d15 	stw	ra,52(sp)
  2068bc:	df000c15 	stw	fp,48(sp)
  2068c0:	df000c04 	addi	fp,sp,48
  2068c4:	e13ff715 	stw	r4,-36(fp)
  2068c8:	e17ff615 	stw	r5,-40(fp)
  2068cc:	e1bff515 	stw	r6,-44(fp)
  2068d0:	e1fff415 	stw	r7,-48(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
  2068d4:	e03fffc5 	stb	zero,-1(fp)
  int             count = 0;
  2068d8:	e03ffe15 	stw	zero,-8(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  2068dc:	e0bff417 	ldw	r2,-48(fp)
  2068e0:	1090000c 	andi	r2,r2,16384
  2068e4:	1005003a 	cmpeq	r2,r2,zero
  2068e8:	10803fcc 	andi	r2,r2,255
  2068ec:	e0bffd15 	stw	r2,-12(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  2068f0:	00001306 	br	206940 <altera_avalon_uart_read+0x8c>
    {
      count++;
  2068f4:	e0bffe17 	ldw	r2,-8(fp)
  2068f8:	10800044 	addi	r2,r2,1
  2068fc:	e0bffe15 	stw	r2,-8(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  206900:	e0bff717 	ldw	r2,-36(fp)
  206904:	10800217 	ldw	r2,8(r2)
  206908:	e0fff717 	ldw	r3,-36(fp)
  20690c:	1885883a 	add	r2,r3,r2
  206910:	11000703 	ldbu	r4,28(r2)
  206914:	e0bff617 	ldw	r2,-40(fp)
  206918:	10c00044 	addi	r3,r2,1
  20691c:	e0fff615 	stw	r3,-40(fp)
  206920:	2007883a 	mov	r3,r4
  206924:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
  206928:	e0bff717 	ldw	r2,-36(fp)
  20692c:	10800217 	ldw	r2,8(r2)
  206930:	10800044 	addi	r2,r2,1
  206934:	10c00fcc 	andi	r3,r2,63
  206938:	e0bff717 	ldw	r2,-36(fp)
  20693c:	10c00215 	stw	r3,8(r2)
    while ((count < len) && (sp->rx_start != sp->rx_end))
  206940:	e0fffe17 	ldw	r3,-8(fp)
  206944:	e0bff517 	ldw	r2,-44(fp)
  206948:	1880050e 	bge	r3,r2,206960 <altera_avalon_uart_read+0xac>
  20694c:	e0bff717 	ldw	r2,-36(fp)
  206950:	10c00217 	ldw	r3,8(r2)
  206954:	e0bff717 	ldw	r2,-36(fp)
  206958:	10800317 	ldw	r2,12(r2)
  20695c:	18bfe51e 	bne	r3,r2,2068f4 <altera_avalon_uart_read+0x40>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  206960:	e0bffe17 	ldw	r2,-8(fp)
  206964:	1000271e 	bne	r2,zero,206a04 <altera_avalon_uart_read+0x150>
  206968:	e0bff717 	ldw	r2,-36(fp)
  20696c:	10c00217 	ldw	r3,8(r2)
  206970:	e0bff717 	ldw	r2,-36(fp)
  206974:	10800317 	ldw	r2,12(r2)
  206978:	1880221e 	bne	r3,r2,206a04 <altera_avalon_uart_read+0x150>
    {
      if (!block)
  20697c:	e0bffd17 	ldw	r2,-12(fp)
  206980:	1000071e 	bne	r2,zero,2069a0 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  206984:	02068780 	call	206878 <alt_get_errno>
  206988:	1007883a 	mov	r3,r2
  20698c:	008002c4 	movi	r2,11
  206990:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
  206994:	00800044 	movi	r2,1
  206998:	e0bfffc5 	stb	r2,-1(fp)
        break;
  20699c:	00001d06 	br	206a14 <altera_avalon_uart_read+0x160>
  NIOS2_READ_STATUS (context);
  2069a0:	0005303a 	rdctl	r2,status
  2069a4:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2069a8:	e0fffa17 	ldw	r3,-24(fp)
  2069ac:	00bfff84 	movi	r2,-2
  2069b0:	1884703a 	and	r2,r3,r2
  2069b4:	1001703a 	wrctl	status,r2
  return context;
  2069b8:	e0bffa17 	ldw	r2,-24(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  2069bc:	e0bffc15 	stw	r2,-16(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  2069c0:	e0bff717 	ldw	r2,-36(fp)
  2069c4:	10800117 	ldw	r2,4(r2)
  2069c8:	10c02014 	ori	r3,r2,128
  2069cc:	e0bff717 	ldw	r2,-36(fp)
  2069d0:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  2069d4:	e0bff717 	ldw	r2,-36(fp)
  2069d8:	10800017 	ldw	r2,0(r2)
  2069dc:	10800304 	addi	r2,r2,12
  2069e0:	e0fff717 	ldw	r3,-36(fp)
  2069e4:	18c00117 	ldw	r3,4(r3)
  2069e8:	10c00035 	stwio	r3,0(r2)
  2069ec:	e0bffc17 	ldw	r2,-16(fp)
  2069f0:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
  2069f4:	e0bffb17 	ldw	r2,-20(fp)
  2069f8:	1001703a 	wrctl	status,r2
}
  2069fc:	0001883a 	nop
  206a00:	0001883a 	nop
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  206a04:	e0bffe17 	ldw	r2,-8(fp)
  206a08:	1000021e 	bne	r2,zero,206a14 <altera_avalon_uart_read+0x160>
  206a0c:	e0bff517 	ldw	r2,-44(fp)
  206a10:	103fcb1e 	bne	r2,zero,206940 <altera_avalon_uart_read+0x8c>
  NIOS2_READ_STATUS (context);
  206a14:	0005303a 	rdctl	r2,status
  206a18:	e0bff815 	stw	r2,-32(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  206a1c:	e0fff817 	ldw	r3,-32(fp)
  206a20:	00bfff84 	movi	r2,-2
  206a24:	1884703a 	and	r2,r3,r2
  206a28:	1001703a 	wrctl	status,r2
  return context;
  206a2c:	e0bff817 	ldw	r2,-32(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  206a30:	e0bffc15 	stw	r2,-16(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  206a34:	e0bff717 	ldw	r2,-36(fp)
  206a38:	10800117 	ldw	r2,4(r2)
  206a3c:	10c02014 	ori	r3,r2,128
  206a40:	e0bff717 	ldw	r2,-36(fp)
  206a44:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  206a48:	e0bff717 	ldw	r2,-36(fp)
  206a4c:	10800017 	ldw	r2,0(r2)
  206a50:	10800304 	addi	r2,r2,12
  206a54:	e0fff717 	ldw	r3,-36(fp)
  206a58:	18c00117 	ldw	r3,4(r3)
  206a5c:	10c00035 	stwio	r3,0(r2)
  206a60:	e0bffc17 	ldw	r2,-16(fp)
  206a64:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context);
  206a68:	e0bff917 	ldw	r2,-28(fp)
  206a6c:	1001703a 	wrctl	status,r2
}
  206a70:	0001883a 	nop
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  206a74:	e0bfffc3 	ldbu	r2,-1(fp)
  206a78:	10000226 	beq	r2,zero,206a84 <altera_avalon_uart_read+0x1d0>
    return -EWOULDBLOCK;
  206a7c:	00bffd44 	movi	r2,-11
  206a80:	00000106 	br	206a88 <altera_avalon_uart_read+0x1d4>
  }
  else {
    return count;
  206a84:	e0bffe17 	ldw	r2,-8(fp)
  }
}
  206a88:	e037883a 	mov	sp,fp
  206a8c:	dfc00117 	ldw	ra,4(sp)
  206a90:	df000017 	ldw	fp,0(sp)
  206a94:	dec00204 	addi	sp,sp,8
  206a98:	f800283a 	ret

00206a9c <alt_get_errno>:

  block = !(flags & O_NONBLOCK);
  count = len;

  do
  {
  206a9c:	defffe04 	addi	sp,sp,-8
  206aa0:	dfc00115 	stw	ra,4(sp)
  206aa4:	df000015 	stw	fp,0(sp)
  206aa8:	d839883a 	mov	fp,sp
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
  206aac:	d0a00817 	ldw	r2,-32736(gp)
  206ab0:	10000326 	beq	r2,zero,206ac0 <alt_get_errno+0x24>
  206ab4:	d0a00817 	ldw	r2,-32736(gp)
  206ab8:	103ee83a 	callr	r2
  206abc:	00000106 	br	206ac4 <alt_get_errno+0x28>
  206ac0:	d0a61a04 	addi	r2,gp,-26520
   
  206ac4:	e037883a 	mov	sp,fp
  206ac8:	dfc00117 	ldw	ra,4(sp)
  206acc:	df000017 	ldw	fp,0(sp)
  206ad0:	dec00204 	addi	sp,sp,8
  206ad4:	f800283a 	ret

00206ad8 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  206ad8:	defff204 	addi	sp,sp,-56
  206adc:	dfc00d15 	stw	ra,52(sp)
  206ae0:	df000c15 	stw	fp,48(sp)
  206ae4:	df000c04 	addi	fp,sp,48
  206ae8:	e13ff715 	stw	r4,-36(fp)
  206aec:	e17ff615 	stw	r5,-40(fp)
  206af0:	e1bff515 	stw	r6,-44(fp)
  206af4:	e1fff415 	stw	r7,-48(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  206af8:	e0bff517 	ldw	r2,-44(fp)
  206afc:	e0bfff15 	stw	r2,-4(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  206b00:	e0bff417 	ldw	r2,-48(fp)
  206b04:	1090000c 	andi	r2,r2,16384
  206b08:	e0bffe15 	stw	r2,-8(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  206b0c:	00003d06 	br	206c04 <altera_avalon_uart_write+0x12c>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  206b10:	e0bff717 	ldw	r2,-36(fp)
  206b14:	10800517 	ldw	r2,20(r2)
  206b18:	10800044 	addi	r2,r2,1
  206b1c:	10800fcc 	andi	r2,r2,63
  206b20:	e0bffd15 	stw	r2,-12(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  206b24:	e0bff717 	ldw	r2,-36(fp)
  206b28:	10800417 	ldw	r2,16(r2)
  206b2c:	e0fffd17 	ldw	r3,-12(fp)
  206b30:	1880241e 	bne	r3,r2,206bc4 <altera_avalon_uart_write+0xec>
    {
      if (no_block)
  206b34:	e0bffe17 	ldw	r2,-8(fp)
  206b38:	10000526 	beq	r2,zero,206b50 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  206b3c:	0206a9c0 	call	206a9c <alt_get_errno>
  206b40:	1007883a 	mov	r3,r2
  206b44:	008002c4 	movi	r2,11
  206b48:	18800015 	stw	r2,0(r3)
        break;
  206b4c:	00002f06 	br	206c0c <altera_avalon_uart_write+0x134>
  NIOS2_READ_STATUS (context);
  206b50:	0005303a 	rdctl	r2,status
  206b54:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  206b58:	e0fffa17 	ldw	r3,-24(fp)
  206b5c:	00bfff84 	movi	r2,-2
  206b60:	1884703a 	and	r2,r3,r2
  206b64:	1001703a 	wrctl	status,r2
  return context;
  206b68:	e0bffa17 	ldw	r2,-24(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  206b6c:	e0bffc15 	stw	r2,-16(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  206b70:	e0bff717 	ldw	r2,-36(fp)
  206b74:	10800117 	ldw	r2,4(r2)
  206b78:	10c11014 	ori	r3,r2,1088
  206b7c:	e0bff717 	ldw	r2,-36(fp)
  206b80:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  206b84:	e0bff717 	ldw	r2,-36(fp)
  206b88:	10800017 	ldw	r2,0(r2)
  206b8c:	10800304 	addi	r2,r2,12
  206b90:	e0fff717 	ldw	r3,-36(fp)
  206b94:	18c00117 	ldw	r3,4(r3)
  206b98:	10c00035 	stwio	r3,0(r2)
  206b9c:	e0bffc17 	ldw	r2,-16(fp)
  206ba0:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
  206ba4:	e0bffb17 	ldw	r2,-20(fp)
  206ba8:	1001703a 	wrctl	status,r2
}
  206bac:	0001883a 	nop
  206bb0:	0001883a 	nop
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  206bb4:	e0bff717 	ldw	r2,-36(fp)
  206bb8:	10800417 	ldw	r2,16(r2)
  206bbc:	e0fffd17 	ldw	r3,-12(fp)
  206bc0:	18bffb26 	beq	r3,r2,206bb0 <altera_avalon_uart_write+0xd8>
      }
    }

    count--;
  206bc4:	e0bfff17 	ldw	r2,-4(fp)
  206bc8:	10bfffc4 	addi	r2,r2,-1
  206bcc:	e0bfff15 	stw	r2,-4(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  206bd0:	e0bff617 	ldw	r2,-40(fp)
  206bd4:	10c00044 	addi	r3,r2,1
  206bd8:	e0fff615 	stw	r3,-40(fp)
  206bdc:	10c00003 	ldbu	r3,0(r2)
  206be0:	e0bff717 	ldw	r2,-36(fp)
  206be4:	10800517 	ldw	r2,20(r2)
  206be8:	1809883a 	mov	r4,r3
  206bec:	e0fff717 	ldw	r3,-36(fp)
  206bf0:	1885883a 	add	r2,r3,r2
  206bf4:	11001705 	stb	r4,92(r2)
    sp->tx_end = next;
  206bf8:	e0bff717 	ldw	r2,-36(fp)
  206bfc:	e0fffd17 	ldw	r3,-12(fp)
  206c00:	10c00515 	stw	r3,20(r2)
  while (count)
  206c04:	e0bfff17 	ldw	r2,-4(fp)
  206c08:	103fc11e 	bne	r2,zero,206b10 <altera_avalon_uart_write+0x38>
  NIOS2_READ_STATUS (context);
  206c0c:	0005303a 	rdctl	r2,status
  206c10:	e0bff815 	stw	r2,-32(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  206c14:	e0fff817 	ldw	r3,-32(fp)
  206c18:	00bfff84 	movi	r2,-2
  206c1c:	1884703a 	and	r2,r3,r2
  206c20:	1001703a 	wrctl	status,r2
  return context;
  206c24:	e0bff817 	ldw	r2,-32(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  206c28:	e0bffc15 	stw	r2,-16(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  206c2c:	e0bff717 	ldw	r2,-36(fp)
  206c30:	10800117 	ldw	r2,4(r2)
  206c34:	10c11014 	ori	r3,r2,1088
  206c38:	e0bff717 	ldw	r2,-36(fp)
  206c3c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  206c40:	e0bff717 	ldw	r2,-36(fp)
  206c44:	10800017 	ldw	r2,0(r2)
  206c48:	10800304 	addi	r2,r2,12
  206c4c:	e0fff717 	ldw	r3,-36(fp)
  206c50:	18c00117 	ldw	r3,4(r3)
  206c54:	10c00035 	stwio	r3,0(r2)
  206c58:	e0bffc17 	ldw	r2,-16(fp)
  206c5c:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context);
  206c60:	e0bff917 	ldw	r2,-28(fp)
  206c64:	1001703a 	wrctl	status,r2
}
  206c68:	0001883a 	nop
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  206c6c:	e0fff517 	ldw	r3,-44(fp)
  206c70:	e0bfff17 	ldw	r2,-4(fp)
  206c74:	1885c83a 	sub	r2,r3,r2
}
  206c78:	e037883a 	mov	sp,fp
  206c7c:	dfc00117 	ldw	ra,4(sp)
  206c80:	df000017 	ldw	fp,0(sp)
  206c84:	dec00204 	addi	sp,sp,8
  206c88:	f800283a 	ret

00206c8c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  206c8c:	defff404 	addi	sp,sp,-48
  206c90:	df000b15 	stw	fp,44(sp)
  206c94:	df000b04 	addi	fp,sp,44
  206c98:	e13ff815 	stw	r4,-32(fp)
  206c9c:	e17ff715 	stw	r5,-36(fp)
  206ca0:	e1bff615 	stw	r6,-40(fp)
  206ca4:	e1fff515 	stw	r7,-44(fp)
  alt_irq_context irq_context;
  alt_u64 current_nticks = 0;
  206ca8:	e03ffe15 	stw	zero,-8(fp)
  206cac:	e03fff15 	stw	zero,-4(fp)
  206cb0:	d0a62517 	ldw	r2,-26476(gp)
  
  if (alt_ticks_per_second ())
  206cb4:	10004826 	beq	r2,zero,206dd8 <alt_alarm_start+0x14c>
  {
    if (alarm)
  206cb8:	e0bff817 	ldw	r2,-32(fp)
  206cbc:	10004426 	beq	r2,zero,206dd0 <alt_alarm_start+0x144>
    {
      alarm->callback = callback;
  206cc0:	e0bff817 	ldw	r2,-32(fp)
  206cc4:	e0fff617 	ldw	r3,-40(fp)
  206cc8:	10c00415 	stw	r3,16(r2)
      alarm->context  = context;
  206ccc:	e0bff817 	ldw	r2,-32(fp)
  206cd0:	e0fff517 	ldw	r3,-44(fp)
  206cd4:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
  206cd8:	0005303a 	rdctl	r2,status
  206cdc:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  206ce0:	e0fff917 	ldw	r3,-28(fp)
  206ce4:	00bfff84 	movi	r2,-2
  206ce8:	1884703a 	and	r2,r3,r2
  206cec:	1001703a 	wrctl	status,r2
  return context;
  206cf0:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
  206cf4:	e0bffd15 	stw	r2,-12(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u64 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  206cf8:	d0a62617 	ldw	r2,-26472(gp)
  206cfc:	d0e62717 	ldw	r3,-26468(gp)
      
      current_nticks = alt_nticks();
  206d00:	e0bffe15 	stw	r2,-8(fp)
  206d04:	e0ffff15 	stw	r3,-4(fp)
      
      alarm->time = (alt_u64)nticks + current_nticks + 1; 
  206d08:	e0bff717 	ldw	r2,-36(fp)
  206d0c:	1011883a 	mov	r8,r2
  206d10:	0013883a 	mov	r9,zero
  206d14:	e13ffe17 	ldw	r4,-8(fp)
  206d18:	e17fff17 	ldw	r5,-4(fp)
  206d1c:	4105883a 	add	r2,r8,r4
  206d20:	120d803a 	cmpltu	r6,r2,r8
  206d24:	4947883a 	add	r3,r9,r5
  206d28:	30c9883a 	add	r4,r6,r3
  206d2c:	2007883a 	mov	r3,r4
  206d30:	1009883a 	mov	r4,r2
  206d34:	180b883a 	mov	r5,r3
  206d38:	01800044 	movi	r6,1
  206d3c:	000f883a 	mov	r7,zero
  206d40:	2185883a 	add	r2,r4,r6
  206d44:	1111803a 	cmpltu	r8,r2,r4
  206d48:	29c7883a 	add	r3,r5,r7
  206d4c:	40c9883a 	add	r4,r8,r3
  206d50:	2007883a 	mov	r3,r4
  206d54:	1009883a 	mov	r4,r2
  206d58:	180b883a 	mov	r5,r3
  206d5c:	e0bff817 	ldw	r2,-32(fp)
  206d60:	11000215 	stw	r4,8(r2)
  206d64:	11400315 	stw	r5,12(r2)
          
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  206d68:	e0bff817 	ldw	r2,-32(fp)
  206d6c:	d0e00b04 	addi	r3,gp,-32724
  206d70:	e0fffb15 	stw	r3,-20(fp)
  206d74:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  206d78:	e0bffa17 	ldw	r2,-24(fp)
  206d7c:	e0fffb17 	ldw	r3,-20(fp)
  206d80:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  206d84:	e0bffb17 	ldw	r2,-20(fp)
  206d88:	10c00017 	ldw	r3,0(r2)
  206d8c:	e0bffa17 	ldw	r2,-24(fp)
  206d90:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  206d94:	e0bffb17 	ldw	r2,-20(fp)
  206d98:	10800017 	ldw	r2,0(r2)
  206d9c:	e0fffa17 	ldw	r3,-24(fp)
  206da0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  206da4:	e0bffb17 	ldw	r2,-20(fp)
  206da8:	e0fffa17 	ldw	r3,-24(fp)
  206dac:	10c00015 	stw	r3,0(r2)
}
  206db0:	0001883a 	nop
  206db4:	e0bffd17 	ldw	r2,-12(fp)
  206db8:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  206dbc:	e0bffc17 	ldw	r2,-16(fp)
  206dc0:	1001703a 	wrctl	status,r2
}
  206dc4:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
  206dc8:	0005883a 	mov	r2,zero
  206dcc:	00000306 	br	206ddc <alt_alarm_start+0x150>
    }
    else
    {
      return -EINVAL;
  206dd0:	00bffa84 	movi	r2,-22
  206dd4:	00000106 	br	206ddc <alt_alarm_start+0x150>
    }
  }
  else
  {
    return -ENOTSUP;
  206dd8:	00bfde84 	movi	r2,-134
  }
}
  206ddc:	e037883a 	mov	sp,fp
  206de0:	df000017 	ldw	fp,0(sp)
  206de4:	dec00104 	addi	sp,sp,4
  206de8:	f800283a 	ret

00206dec <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  206dec:	defffe04 	addi	sp,sp,-8
  206df0:	df000115 	stw	fp,4(sp)
  206df4:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  206df8:	e03fff15 	stw	zero,-4(fp)
  206dfc:	00000506 	br	206e14 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  206e00:	e0bfff17 	ldw	r2,-4(fp)
  206e04:	1000003b 	flushd	0(r2)
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  206e08:	e0bfff17 	ldw	r2,-4(fp)
  206e0c:	10800804 	addi	r2,r2,32
  206e10:	e0bfff15 	stw	r2,-4(fp)
  206e14:	e0bfff17 	ldw	r2,-4(fp)
  206e18:	10820030 	cmpltui	r2,r2,2048
  206e1c:	103ff81e 	bne	r2,zero,206e00 <alt_dcache_flush_all+0x14>
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  206e20:	0001883a 	nop
  206e24:	0001883a 	nop
  206e28:	e037883a 	mov	sp,fp
  206e2c:	df000017 	ldw	fp,0(sp)
  206e30:	dec00104 	addi	sp,sp,4
  206e34:	f800283a 	ret

00206e38 <alt_get_errno>:
  206e38:	defffe04 	addi	sp,sp,-8
  206e3c:	dfc00115 	stw	ra,4(sp)
  206e40:	df000015 	stw	fp,0(sp)
  206e44:	d839883a 	mov	fp,sp
  206e48:	d0a00817 	ldw	r2,-32736(gp)
  206e4c:	10000326 	beq	r2,zero,206e5c <alt_get_errno+0x24>
  206e50:	d0a00817 	ldw	r2,-32736(gp)
  206e54:	103ee83a 	callr	r2
  206e58:	00000106 	br	206e60 <alt_get_errno+0x28>
  206e5c:	d0a61a04 	addi	r2,gp,-26520
  206e60:	e037883a 	mov	sp,fp
  206e64:	dfc00117 	ldw	ra,4(sp)
  206e68:	df000017 	ldw	fp,0(sp)
  206e6c:	dec00204 	addi	sp,sp,8
  206e70:	f800283a 	ret

00206e74 <alt_dev_llist_insert>:
{
  206e74:	defffa04 	addi	sp,sp,-24
  206e78:	dfc00515 	stw	ra,20(sp)
  206e7c:	df000415 	stw	fp,16(sp)
  206e80:	df000404 	addi	fp,sp,16
  206e84:	e13ffd15 	stw	r4,-12(fp)
  206e88:	e17ffc15 	stw	r5,-16(fp)
  if (!dev || !dev->name)
  206e8c:	e0bffd17 	ldw	r2,-12(fp)
  206e90:	10000326 	beq	r2,zero,206ea0 <alt_dev_llist_insert+0x2c>
  206e94:	e0bffd17 	ldw	r2,-12(fp)
  206e98:	10800217 	ldw	r2,8(r2)
  206e9c:	1000061e 	bne	r2,zero,206eb8 <alt_dev_llist_insert+0x44>
    ALT_ERRNO = EINVAL;
  206ea0:	0206e380 	call	206e38 <alt_get_errno>
  206ea4:	1007883a 	mov	r3,r2
  206ea8:	00800584 	movi	r2,22
  206eac:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  206eb0:	00bffa84 	movi	r2,-22
  206eb4:	00001406 	br	206f08 <alt_dev_llist_insert+0x94>
  alt_llist_insert(list, &dev->llist);
  206eb8:	e0bffd17 	ldw	r2,-12(fp)
  206ebc:	e0fffc17 	ldw	r3,-16(fp)
  206ec0:	e0ffff15 	stw	r3,-4(fp)
  206ec4:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
  206ec8:	e0bffe17 	ldw	r2,-8(fp)
  206ecc:	e0ffff17 	ldw	r3,-4(fp)
  206ed0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  206ed4:	e0bfff17 	ldw	r2,-4(fp)
  206ed8:	10c00017 	ldw	r3,0(r2)
  206edc:	e0bffe17 	ldw	r2,-8(fp)
  206ee0:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
  206ee4:	e0bfff17 	ldw	r2,-4(fp)
  206ee8:	10800017 	ldw	r2,0(r2)
  206eec:	e0fffe17 	ldw	r3,-8(fp)
  206ef0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  206ef4:	e0bfff17 	ldw	r2,-4(fp)
  206ef8:	e0fffe17 	ldw	r3,-8(fp)
  206efc:	10c00015 	stw	r3,0(r2)
}
  206f00:	0001883a 	nop
  return 0;  
  206f04:	0005883a 	mov	r2,zero
}
  206f08:	e037883a 	mov	sp,fp
  206f0c:	dfc00117 	ldw	ra,4(sp)
  206f10:	df000017 	ldw	fp,0(sp)
  206f14:	dec00204 	addi	sp,sp,8
  206f18:	f800283a 	ret

00206f1c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  206f1c:	defffd04 	addi	sp,sp,-12
  206f20:	dfc00215 	stw	ra,8(sp)
  206f24:	df000115 	stw	fp,4(sp)
  206f28:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  206f2c:	00800834 	movhi	r2,32
  206f30:	109f7404 	addi	r2,r2,32208
  206f34:	e0bfff15 	stw	r2,-4(fp)
  206f38:	00000606 	br	206f54 <_do_ctors+0x38>
        (*ctor) (); 
  206f3c:	e0bfff17 	ldw	r2,-4(fp)
  206f40:	10800017 	ldw	r2,0(r2)
  206f44:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  206f48:	e0bfff17 	ldw	r2,-4(fp)
  206f4c:	10bfff04 	addi	r2,r2,-4
  206f50:	e0bfff15 	stw	r2,-4(fp)
  206f54:	e0ffff17 	ldw	r3,-4(fp)
  206f58:	00800834 	movhi	r2,32
  206f5c:	109f7504 	addi	r2,r2,32212
  206f60:	18bff62e 	bgeu	r3,r2,206f3c <_do_ctors+0x20>
}
  206f64:	0001883a 	nop
  206f68:	0001883a 	nop
  206f6c:	e037883a 	mov	sp,fp
  206f70:	dfc00117 	ldw	ra,4(sp)
  206f74:	df000017 	ldw	fp,0(sp)
  206f78:	dec00204 	addi	sp,sp,8
  206f7c:	f800283a 	ret

00206f80 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  206f80:	defffd04 	addi	sp,sp,-12
  206f84:	dfc00215 	stw	ra,8(sp)
  206f88:	df000115 	stw	fp,4(sp)
  206f8c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  206f90:	00800834 	movhi	r2,32
  206f94:	109f7404 	addi	r2,r2,32208
  206f98:	e0bfff15 	stw	r2,-4(fp)
  206f9c:	00000606 	br	206fb8 <_do_dtors+0x38>
        (*dtor) (); 
  206fa0:	e0bfff17 	ldw	r2,-4(fp)
  206fa4:	10800017 	ldw	r2,0(r2)
  206fa8:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  206fac:	e0bfff17 	ldw	r2,-4(fp)
  206fb0:	10bfff04 	addi	r2,r2,-4
  206fb4:	e0bfff15 	stw	r2,-4(fp)
  206fb8:	e0ffff17 	ldw	r3,-4(fp)
  206fbc:	00800834 	movhi	r2,32
  206fc0:	109f7504 	addi	r2,r2,32212
  206fc4:	18bff62e 	bgeu	r3,r2,206fa0 <_do_dtors+0x20>
}
  206fc8:	0001883a 	nop
  206fcc:	0001883a 	nop
  206fd0:	e037883a 	mov	sp,fp
  206fd4:	dfc00117 	ldw	ra,4(sp)
  206fd8:	df000017 	ldw	fp,0(sp)
  206fdc:	dec00204 	addi	sp,sp,8
  206fe0:	f800283a 	ret

00206fe4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  206fe4:	defffe04 	addi	sp,sp,-8
  206fe8:	dfc00115 	stw	ra,4(sp)
  206fec:	df000015 	stw	fp,0(sp)
  206ff0:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  206ff4:	01440004 	movi	r5,4096
  206ff8:	0009883a 	mov	r4,zero
  206ffc:	0207a500 	call	207a50 <alt_icache_flush>
#endif
}
  207000:	0001883a 	nop
  207004:	e037883a 	mov	sp,fp
  207008:	dfc00117 	ldw	ra,4(sp)
  20700c:	df000017 	ldw	fp,0(sp)
  207010:	dec00204 	addi	sp,sp,8
  207014:	f800283a 	ret

00207018 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  207018:	defff904 	addi	sp,sp,-28
  20701c:	dfc00615 	stw	ra,24(sp)
  207020:	df000515 	stw	fp,20(sp)
  207024:	df000504 	addi	fp,sp,20
  207028:	e13fff15 	stw	r4,-4(fp)
  20702c:	e17ffe15 	stw	r5,-8(fp)
  207030:	e1bffd15 	stw	r6,-12(fp)
  207034:	e1fffc15 	stw	r7,-16(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  207038:	e0800217 	ldw	r2,8(fp)
  20703c:	d8800015 	stw	r2,0(sp)
  207040:	e1fffc17 	ldw	r7,-16(fp)
  207044:	e1bffd17 	ldw	r6,-12(fp)
  207048:	e17ffe17 	ldw	r5,-8(fp)
  20704c:	e13fff17 	ldw	r4,-4(fp)
  207050:	02071c80 	call	2071c8 <alt_iic_isr_register>
}  
  207054:	e037883a 	mov	sp,fp
  207058:	dfc00117 	ldw	ra,4(sp)
  20705c:	df000017 	ldw	fp,0(sp)
  207060:	dec00204 	addi	sp,sp,8
  207064:	f800283a 	ret

00207068 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  207068:	defff904 	addi	sp,sp,-28
  20706c:	df000615 	stw	fp,24(sp)
  207070:	df000604 	addi	fp,sp,24
  207074:	e13ffb15 	stw	r4,-20(fp)
  207078:	e17ffa15 	stw	r5,-24(fp)
  20707c:	e0bffa17 	ldw	r2,-24(fp)
  207080:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
  207084:	0005303a 	rdctl	r2,status
  207088:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20708c:	e0fffe17 	ldw	r3,-8(fp)
  207090:	00bfff84 	movi	r2,-2
  207094:	1884703a 	and	r2,r3,r2
  207098:	1001703a 	wrctl	status,r2
  return context;
  20709c:	e0bffe17 	ldw	r2,-8(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  2070a0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
  2070a4:	00c00044 	movi	r3,1
  2070a8:	e0bfff17 	ldw	r2,-4(fp)
  2070ac:	1884983a 	sll	r2,r3,r2
  2070b0:	1007883a 	mov	r3,r2
  2070b4:	d0a62417 	ldw	r2,-26480(gp)
  2070b8:	1884b03a 	or	r2,r3,r2
  2070bc:	d0a62415 	stw	r2,-26480(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  2070c0:	d0a62417 	ldw	r2,-26480(gp)
  2070c4:	100170fa 	wrctl	ienable,r2
  2070c8:	e0bffd17 	ldw	r2,-12(fp)
  2070cc:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  2070d0:	e0bffc17 	ldw	r2,-16(fp)
  2070d4:	1001703a 	wrctl	status,r2
}
  2070d8:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
  2070dc:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  2070e0:	e037883a 	mov	sp,fp
  2070e4:	df000017 	ldw	fp,0(sp)
  2070e8:	dec00104 	addi	sp,sp,4
  2070ec:	f800283a 	ret

002070f0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  2070f0:	defff904 	addi	sp,sp,-28
  2070f4:	df000615 	stw	fp,24(sp)
  2070f8:	df000604 	addi	fp,sp,24
  2070fc:	e13ffb15 	stw	r4,-20(fp)
  207100:	e17ffa15 	stw	r5,-24(fp)
  207104:	e0bffa17 	ldw	r2,-24(fp)
  207108:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
  20710c:	0005303a 	rdctl	r2,status
  207110:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  207114:	e0fffe17 	ldw	r3,-8(fp)
  207118:	00bfff84 	movi	r2,-2
  20711c:	1884703a 	and	r2,r3,r2
  207120:	1001703a 	wrctl	status,r2
  return context;
  207124:	e0bffe17 	ldw	r2,-8(fp)
  status = alt_irq_disable_all ();
  207128:	e0bffd15 	stw	r2,-12(fp)
  alt_irq_active &= ~(1 << id);
  20712c:	00c00044 	movi	r3,1
  207130:	e0bfff17 	ldw	r2,-4(fp)
  207134:	1884983a 	sll	r2,r3,r2
  207138:	0084303a 	nor	r2,zero,r2
  20713c:	1007883a 	mov	r3,r2
  207140:	d0a62417 	ldw	r2,-26480(gp)
  207144:	1884703a 	and	r2,r3,r2
  207148:	d0a62415 	stw	r2,-26480(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  20714c:	d0a62417 	ldw	r2,-26480(gp)
  207150:	100170fa 	wrctl	ienable,r2
  207154:	e0bffd17 	ldw	r2,-12(fp)
  207158:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  20715c:	e0bffc17 	ldw	r2,-16(fp)
  207160:	1001703a 	wrctl	status,r2
}
  207164:	0001883a 	nop
  return 0;
  207168:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  20716c:	e037883a 	mov	sp,fp
  207170:	df000017 	ldw	fp,0(sp)
  207174:	dec00104 	addi	sp,sp,4
  207178:	f800283a 	ret

0020717c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  20717c:	defffc04 	addi	sp,sp,-16
  207180:	df000315 	stw	fp,12(sp)
  207184:	df000304 	addi	fp,sp,12
  207188:	e13ffe15 	stw	r4,-8(fp)
  20718c:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  207190:	000530fa 	rdctl	r2,ienable
  207194:	e0bfff15 	stw	r2,-4(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  207198:	00c00044 	movi	r3,1
  20719c:	e0bffd17 	ldw	r2,-12(fp)
  2071a0:	1884983a 	sll	r2,r3,r2
  2071a4:	1007883a 	mov	r3,r2
  2071a8:	e0bfff17 	ldw	r2,-4(fp)
  2071ac:	1884703a 	and	r2,r3,r2
  2071b0:	1004c03a 	cmpne	r2,r2,zero
  2071b4:	10803fcc 	andi	r2,r2,255
}
  2071b8:	e037883a 	mov	sp,fp
  2071bc:	df000017 	ldw	fp,0(sp)
  2071c0:	dec00104 	addi	sp,sp,4
  2071c4:	f800283a 	ret

002071c8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  2071c8:	defff504 	addi	sp,sp,-44
  2071cc:	dfc00a15 	stw	ra,40(sp)
  2071d0:	df000915 	stw	fp,36(sp)
  2071d4:	df000904 	addi	fp,sp,36
  2071d8:	e13ffa15 	stw	r4,-24(fp)
  2071dc:	e17ff915 	stw	r5,-28(fp)
  2071e0:	e1bff815 	stw	r6,-32(fp)
  2071e4:	e1fff715 	stw	r7,-36(fp)
  int rc = -EINVAL;  
  2071e8:	00bffa84 	movi	r2,-22
  2071ec:	e0bfff15 	stw	r2,-4(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  2071f0:	e0bff917 	ldw	r2,-28(fp)
  2071f4:	e0bffe15 	stw	r2,-8(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  2071f8:	e0bffe17 	ldw	r2,-8(fp)
  2071fc:	10800808 	cmpgei	r2,r2,32
  207200:	1000251e 	bne	r2,zero,207298 <alt_iic_isr_register+0xd0>
  NIOS2_READ_STATUS (context);
  207204:	0005303a 	rdctl	r2,status
  207208:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20720c:	e0fffc17 	ldw	r3,-16(fp)
  207210:	00bfff84 	movi	r2,-2
  207214:	1884703a 	and	r2,r3,r2
  207218:	1001703a 	wrctl	status,r2
  return context;
  20721c:	e0bffc17 	ldw	r2,-16(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  207220:	e0bffd15 	stw	r2,-12(fp)

    alt_irq[id].handler = isr;
  207224:	e0bffe17 	ldw	r2,-8(fp)
  207228:	100890fa 	slli	r4,r2,3
  20722c:	e0fff817 	ldw	r3,-32(fp)
  207230:	00800874 	movhi	r2,33
  207234:	2085883a 	add	r2,r4,r2
  207238:	10ec0a15 	stw	r3,-20440(r2)
    alt_irq[id].context = isr_context;
  20723c:	e0bffe17 	ldw	r2,-8(fp)
  207240:	100890fa 	slli	r4,r2,3
  207244:	e0fff717 	ldw	r3,-36(fp)
  207248:	00800874 	movhi	r2,33
  20724c:	2085883a 	add	r2,r4,r2
  207250:	10ec0b15 	stw	r3,-20436(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  207254:	e0bff817 	ldw	r2,-32(fp)
  207258:	10000526 	beq	r2,zero,207270 <alt_iic_isr_register+0xa8>
  20725c:	e0bffe17 	ldw	r2,-8(fp)
  207260:	100b883a 	mov	r5,r2
  207264:	e13ffa17 	ldw	r4,-24(fp)
  207268:	02070680 	call	207068 <alt_ic_irq_enable>
  20726c:	00000406 	br	207280 <alt_iic_isr_register+0xb8>
  207270:	e0bffe17 	ldw	r2,-8(fp)
  207274:	100b883a 	mov	r5,r2
  207278:	e13ffa17 	ldw	r4,-24(fp)
  20727c:	02070f00 	call	2070f0 <alt_ic_irq_disable>
  207280:	e0bfff15 	stw	r2,-4(fp)
  207284:	e0bffd17 	ldw	r2,-12(fp)
  207288:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
  20728c:	e0bffb17 	ldw	r2,-20(fp)
  207290:	1001703a 	wrctl	status,r2
}
  207294:	0001883a 	nop

    alt_irq_enable_all(status);
  }

  return rc; 
  207298:	e0bfff17 	ldw	r2,-4(fp)
}
  20729c:	e037883a 	mov	sp,fp
  2072a0:	dfc00117 	ldw	ra,4(sp)
  2072a4:	df000017 	ldw	fp,0(sp)
  2072a8:	dec00204 	addi	sp,sp,8
  2072ac:	f800283a 	ret

002072b0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  2072b0:	defff904 	addi	sp,sp,-28
  2072b4:	dfc00615 	stw	ra,24(sp)
  2072b8:	df000515 	stw	fp,20(sp)
  2072bc:	df000504 	addi	fp,sp,20
  2072c0:	e13ffe15 	stw	r4,-8(fp)
  2072c4:	e17ffd15 	stw	r5,-12(fp)
  2072c8:	e1bffc15 	stw	r6,-16(fp)
  2072cc:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
  2072d0:	e1bffb17 	ldw	r6,-20(fp)
  2072d4:	e17ffc17 	ldw	r5,-16(fp)
  2072d8:	e13ffd17 	ldw	r4,-12(fp)
  2072dc:	02074d00 	call	2074d0 <open>
  2072e0:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
  2072e4:	e0bfff17 	ldw	r2,-4(fp)
  2072e8:	10001716 	blt	r2,zero,207348 <alt_open_fd+0x98>
  {
    fd->dev      = alt_fd_list[old].dev;
  2072ec:	e0bfff17 	ldw	r2,-4(fp)
  2072f0:	10c00324 	muli	r3,r2,12
  2072f4:	00800874 	movhi	r2,33
  2072f8:	1885883a 	add	r2,r3,r2
  2072fc:	10e0e017 	ldw	r3,-31872(r2)
  207300:	e0bffe17 	ldw	r2,-8(fp)
  207304:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  207308:	e0bfff17 	ldw	r2,-4(fp)
  20730c:	10c00324 	muli	r3,r2,12
  207310:	00800874 	movhi	r2,33
  207314:	1885883a 	add	r2,r3,r2
  207318:	10e0e117 	ldw	r3,-31868(r2)
  20731c:	e0bffe17 	ldw	r2,-8(fp)
  207320:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  207324:	e0bfff17 	ldw	r2,-4(fp)
  207328:	10c00324 	muli	r3,r2,12
  20732c:	00800874 	movhi	r2,33
  207330:	1885883a 	add	r2,r3,r2
  207334:	10e0e217 	ldw	r3,-31864(r2)
  207338:	e0bffe17 	ldw	r2,-8(fp)
  20733c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  207340:	e13fff17 	ldw	r4,-4(fp)
  207344:	02056080 	call	205608 <alt_release_fd>
  }
} 
  207348:	0001883a 	nop
  20734c:	e037883a 	mov	sp,fp
  207350:	dfc00117 	ldw	ra,4(sp)
  207354:	df000017 	ldw	fp,0(sp)
  207358:	dec00204 	addi	sp,sp,8
  20735c:	f800283a 	ret

00207360 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  207360:	defffb04 	addi	sp,sp,-20
  207364:	dfc00415 	stw	ra,16(sp)
  207368:	df000315 	stw	fp,12(sp)
  20736c:	df000304 	addi	fp,sp,12
  207370:	e13fff15 	stw	r4,-4(fp)
  207374:	e17ffe15 	stw	r5,-8(fp)
  207378:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  20737c:	01c07fc4 	movi	r7,511
  207380:	01800044 	movi	r6,1
  207384:	e17fff17 	ldw	r5,-4(fp)
  207388:	01000874 	movhi	r4,33
  20738c:	2120e304 	addi	r4,r4,-31860
  207390:	02072b00 	call	2072b0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  207394:	01c07fc4 	movi	r7,511
  207398:	000d883a 	mov	r6,zero
  20739c:	e17ffe17 	ldw	r5,-8(fp)
  2073a0:	01000874 	movhi	r4,33
  2073a4:	2120e004 	addi	r4,r4,-31872
  2073a8:	02072b00 	call	2072b0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  2073ac:	01c07fc4 	movi	r7,511
  2073b0:	01800044 	movi	r6,1
  2073b4:	e17ffd17 	ldw	r5,-12(fp)
  2073b8:	01000874 	movhi	r4,33
  2073bc:	2120e604 	addi	r4,r4,-31848
  2073c0:	02072b00 	call	2072b0 <alt_open_fd>
}  
  2073c4:	0001883a 	nop
  2073c8:	e037883a 	mov	sp,fp
  2073cc:	dfc00117 	ldw	ra,4(sp)
  2073d0:	df000017 	ldw	fp,0(sp)
  2073d4:	dec00204 	addi	sp,sp,8
  2073d8:	f800283a 	ret

002073dc <alt_get_errno>:
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  2073dc:	defffe04 	addi	sp,sp,-8
  2073e0:	dfc00115 	stw	ra,4(sp)
  2073e4:	df000015 	stw	fp,0(sp)
  2073e8:	d839883a 	mov	fp,sp
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  2073ec:	d0a00817 	ldw	r2,-32736(gp)
  2073f0:	10000326 	beq	r2,zero,207400 <alt_get_errno+0x24>
  2073f4:	d0a00817 	ldw	r2,-32736(gp)
  2073f8:	103ee83a 	callr	r2
  2073fc:	00000106 	br	207404 <alt_get_errno+0x28>
  207400:	d0a61a04 	addi	r2,gp,-26520
        (&alt_fd_list[i] != fd))
  207404:	e037883a 	mov	sp,fp
  207408:	dfc00117 	ldw	ra,4(sp)
  20740c:	df000017 	ldw	fp,0(sp)
  207410:	dec00204 	addi	sp,sp,8
  207414:	f800283a 	ret

00207418 <alt_file_locked>:
{
  207418:	defffd04 	addi	sp,sp,-12
  20741c:	df000215 	stw	fp,8(sp)
  207420:	df000204 	addi	fp,sp,8
  207424:	e13ffe15 	stw	r4,-8(fp)
  fd->fd_flags |= ALT_FD_DEV;
  207428:	e0bffe17 	ldw	r2,-8(fp)
  20742c:	10800217 	ldw	r2,8(r2)
  207430:	10d00034 	orhi	r3,r2,16384
  207434:	e0bffe17 	ldw	r2,-8(fp)
  207438:	10c00215 	stw	r3,8(r2)
  for (i = 0; i <= alt_max_fd; i++)
  20743c:	e03fff15 	stw	zero,-4(fp)
  207440:	00001a06 	br	2074ac <alt_file_locked+0x94>
    if ((alt_fd_list[i].dev == fd->dev) &&
  207444:	e0bfff17 	ldw	r2,-4(fp)
  207448:	10c00324 	muli	r3,r2,12
  20744c:	00800874 	movhi	r2,33
  207450:	1885883a 	add	r2,r3,r2
  207454:	10e0e017 	ldw	r3,-31872(r2)
  207458:	e0bffe17 	ldw	r2,-8(fp)
  20745c:	10800017 	ldw	r2,0(r2)
  207460:	18800f1e 	bne	r3,r2,2074a0 <alt_file_locked+0x88>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  207464:	e0bfff17 	ldw	r2,-4(fp)
  207468:	10c00324 	muli	r3,r2,12
  20746c:	00800874 	movhi	r2,33
  207470:	1885883a 	add	r2,r3,r2
  207474:	10a0e217 	ldw	r2,-31864(r2)
    if ((alt_fd_list[i].dev == fd->dev) &&
  207478:	1000090e 	bge	r2,zero,2074a0 <alt_file_locked+0x88>
        (&alt_fd_list[i] != fd))
  20747c:	e0bfff17 	ldw	r2,-4(fp)
  207480:	10c00324 	muli	r3,r2,12
  207484:	00800874 	movhi	r2,33
  207488:	10a0e004 	addi	r2,r2,-31872
  20748c:	1885883a 	add	r2,r3,r2
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  207490:	e0fffe17 	ldw	r3,-8(fp)
  207494:	18800226 	beq	r3,r2,2074a0 <alt_file_locked+0x88>
    {
      return -EACCES;
  207498:	00bffcc4 	movi	r2,-13
  20749c:	00000806 	br	2074c0 <alt_file_locked+0xa8>
  for (i = 0; i <= alt_max_fd; i++)
  2074a0:	e0bfff17 	ldw	r2,-4(fp)
  2074a4:	10800044 	addi	r2,r2,1
  2074a8:	e0bfff15 	stw	r2,-4(fp)
  2074ac:	d0a00717 	ldw	r2,-32740(gp)
  2074b0:	1007883a 	mov	r3,r2
  2074b4:	e0bfff17 	ldw	r2,-4(fp)
  2074b8:	18bfe22e 	bgeu	r3,r2,207444 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  2074bc:	0005883a 	mov	r2,zero
}
  2074c0:	e037883a 	mov	sp,fp
  2074c4:	df000017 	ldw	fp,0(sp)
  2074c8:	dec00104 	addi	sp,sp,4
  2074cc:	f800283a 	ret

002074d0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  2074d0:	defff604 	addi	sp,sp,-40
  2074d4:	dfc00915 	stw	ra,36(sp)
  2074d8:	df000815 	stw	fp,32(sp)
  2074dc:	df000804 	addi	fp,sp,32
  2074e0:	e13ffa15 	stw	r4,-24(fp)
  2074e4:	e17ff915 	stw	r5,-28(fp)
  2074e8:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  2074ec:	00bfffc4 	movi	r2,-1
  2074f0:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
  2074f4:	00bffb44 	movi	r2,-19
  2074f8:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
  2074fc:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  207500:	d1600504 	addi	r5,gp,-32748
  207504:	e13ffa17 	ldw	r4,-24(fp)
  207508:	02078180 	call	207818 <alt_find_dev>
  20750c:	e0bfff15 	stw	r2,-4(fp)
  207510:	e0bfff17 	ldw	r2,-4(fp)
  207514:	1000051e 	bne	r2,zero,20752c <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  207518:	e13ffa17 	ldw	r4,-24(fp)
  20751c:	02078a80 	call	2078a8 <alt_find_file>
  207520:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
  207524:	00800044 	movi	r2,1
  207528:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  20752c:	e0bfff17 	ldw	r2,-4(fp)
  207530:	10002926 	beq	r2,zero,2075d8 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
  207534:	e13fff17 	ldw	r4,-4(fp)
  207538:	02079b00 	call	2079b0 <alt_get_fd>
  20753c:	e0bffe15 	stw	r2,-8(fp)
  207540:	e0bffe17 	ldw	r2,-8(fp)
  207544:	1000030e 	bge	r2,zero,207554 <open+0x84>
    {
      status = index;
  207548:	e0bffe17 	ldw	r2,-8(fp)
  20754c:	e0bffd15 	stw	r2,-12(fp)
  207550:	00002306 	br	2075e0 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
  207554:	e0bffe17 	ldw	r2,-8(fp)
  207558:	10c00324 	muli	r3,r2,12
  20755c:	00800874 	movhi	r2,33
  207560:	10a0e004 	addi	r2,r2,-31872
  207564:	1885883a 	add	r2,r3,r2
  207568:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  20756c:	e0fff917 	ldw	r3,-28(fp)
  207570:	00900034 	movhi	r2,16384
  207574:	10bfffc4 	addi	r2,r2,-1
  207578:	1886703a 	and	r3,r3,r2
  20757c:	e0bffb17 	ldw	r2,-20(fp)
  207580:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  207584:	e0bffc17 	ldw	r2,-16(fp)
  207588:	1000051e 	bne	r2,zero,2075a0 <open+0xd0>
  20758c:	e13ffb17 	ldw	r4,-20(fp)
  207590:	02074180 	call	207418 <alt_file_locked>
  207594:	e0bffd15 	stw	r2,-12(fp)
  207598:	e0bffd17 	ldw	r2,-12(fp)
  20759c:	10001016 	blt	r2,zero,2075e0 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  2075a0:	e0bfff17 	ldw	r2,-4(fp)
  2075a4:	10800317 	ldw	r2,12(r2)
  2075a8:	10000826 	beq	r2,zero,2075cc <open+0xfc>
  2075ac:	e0bfff17 	ldw	r2,-4(fp)
  2075b0:	10800317 	ldw	r2,12(r2)
  2075b4:	e1fff817 	ldw	r7,-32(fp)
  2075b8:	e1bff917 	ldw	r6,-28(fp)
  2075bc:	e17ffa17 	ldw	r5,-24(fp)
  2075c0:	e13ffb17 	ldw	r4,-20(fp)
  2075c4:	103ee83a 	callr	r2
  2075c8:	00000106 	br	2075d0 <open+0x100>
  2075cc:	0005883a 	mov	r2,zero
  2075d0:	e0bffd15 	stw	r2,-12(fp)
  2075d4:	00000206 	br	2075e0 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
  2075d8:	00bffb44 	movi	r2,-19
  2075dc:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  2075e0:	e0bffd17 	ldw	r2,-12(fp)
  2075e4:	1000090e 	bge	r2,zero,20760c <open+0x13c>
  {
    alt_release_fd (index);  
  2075e8:	e13ffe17 	ldw	r4,-8(fp)
  2075ec:	02056080 	call	205608 <alt_release_fd>
    ALT_ERRNO = -status;
  2075f0:	02073dc0 	call	2073dc <alt_get_errno>
  2075f4:	1007883a 	mov	r3,r2
  2075f8:	e0bffd17 	ldw	r2,-12(fp)
  2075fc:	0085c83a 	sub	r2,zero,r2
  207600:	18800015 	stw	r2,0(r3)
    return -1;
  207604:	00bfffc4 	movi	r2,-1
  207608:	00000106 	br	207610 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
  20760c:	e0bffe17 	ldw	r2,-8(fp)
}
  207610:	e037883a 	mov	sp,fp
  207614:	dfc00117 	ldw	ra,4(sp)
  207618:	df000017 	ldw	fp,0(sp)
  20761c:	dec00204 	addi	sp,sp,8
  207620:	f800283a 	ret

00207624 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  207624:	defffa04 	addi	sp,sp,-24
  207628:	df000515 	stw	fp,20(sp)
  20762c:	df000504 	addi	fp,sp,20
  207630:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
  207634:	0005303a 	rdctl	r2,status
  207638:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20763c:	e0fffc17 	ldw	r3,-16(fp)
  207640:	00bfff84 	movi	r2,-2
  207644:	1884703a 	and	r2,r3,r2
  207648:	1001703a 	wrctl	status,r2
  return context;
  20764c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  207650:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
  207654:	e0bffb17 	ldw	r2,-20(fp)
  207658:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  20765c:	e0bffd17 	ldw	r2,-12(fp)
  207660:	10800017 	ldw	r2,0(r2)
  207664:	e0fffd17 	ldw	r3,-12(fp)
  207668:	18c00117 	ldw	r3,4(r3)
  20766c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  207670:	e0bffd17 	ldw	r2,-12(fp)
  207674:	10800117 	ldw	r2,4(r2)
  207678:	e0fffd17 	ldw	r3,-12(fp)
  20767c:	18c00017 	ldw	r3,0(r3)
  207680:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  207684:	e0bffd17 	ldw	r2,-12(fp)
  207688:	e0fffd17 	ldw	r3,-12(fp)
  20768c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  207690:	e0bffd17 	ldw	r2,-12(fp)
  207694:	e0fffd17 	ldw	r3,-12(fp)
  207698:	10c00015 	stw	r3,0(r2)
} 
  20769c:	0001883a 	nop
  2076a0:	e0bfff17 	ldw	r2,-4(fp)
  2076a4:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
  2076a8:	e0bffe17 	ldw	r2,-8(fp)
  2076ac:	1001703a 	wrctl	status,r2
}
  2076b0:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
  2076b4:	0001883a 	nop
  2076b8:	e037883a 	mov	sp,fp
  2076bc:	df000017 	ldw	fp,0(sp)
  2076c0:	dec00104 	addi	sp,sp,4
  2076c4:	f800283a 	ret

002076c8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  2076c8:	defff904 	addi	sp,sp,-28
  2076cc:	dfc00615 	stw	ra,24(sp)
  2076d0:	df000515 	stw	fp,20(sp)
  2076d4:	dc400415 	stw	r17,16(sp)
  2076d8:	dc000315 	stw	r16,12(sp)
  2076dc:	df000504 	addi	fp,sp,20
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  2076e0:	d0a00b17 	ldw	r2,-32724(gp)
  2076e4:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  2076e8:	d1262617 	ldw	r4,-26472(gp)
  2076ec:	d1662717 	ldw	r5,-26468(gp)
  2076f0:	01800044 	movi	r6,1
  2076f4:	000f883a 	mov	r7,zero
  2076f8:	2185883a 	add	r2,r4,r6
  2076fc:	1111803a 	cmpltu	r8,r2,r4
  207700:	29c7883a 	add	r3,r5,r7
  207704:	40c9883a 	add	r4,r8,r3
  207708:	2007883a 	mov	r3,r4
  20770c:	1009883a 	mov	r4,r2
  207710:	180b883a 	mov	r5,r3
  207714:	d1262615 	stw	r4,-26472(gp)
  207718:	d1662715 	stw	r5,-26468(gp)
 
  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  20771c:	00002906 	br	2077c4 <alt_tick+0xfc>
  {
    next = (alt_alarm*) alarm->llist.next;
  207720:	e0bffd17 	ldw	r2,-12(fp)
  207724:	10800017 	ldw	r2,0(r2)
  207728:	e0bffc15 	stw	r2,-16(fp)
    
    /* if the alarm period has expired, make the callback */    
    if (alarm->time <= _alt_nticks)
  20772c:	e13ffd17 	ldw	r4,-12(fp)
  207730:	20800217 	ldw	r2,8(r4)
  207734:	20c00317 	ldw	r3,12(r4)
  207738:	d1262617 	ldw	r4,-26472(gp)
  20773c:	d1662717 	ldw	r5,-26468(gp)
  207740:	28c01e36 	bltu	r5,r3,2077bc <alt_tick+0xf4>
  207744:	1940011e 	bne	r3,r5,20774c <alt_tick+0x84>
  207748:	20801c36 	bltu	r4,r2,2077bc <alt_tick+0xf4>
    {
      next_callback = alarm->callback (alarm->context);
  20774c:	e0bffd17 	ldw	r2,-12(fp)
  207750:	10800417 	ldw	r2,16(r2)
  207754:	e0fffd17 	ldw	r3,-12(fp)
  207758:	18c00517 	ldw	r3,20(r3)
  20775c:	1809883a 	mov	r4,r3
  207760:	103ee83a 	callr	r2
  207764:	e0bffb15 	stw	r2,-20(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  207768:	e0bffb17 	ldw	r2,-20(fp)
  20776c:	1000031e 	bne	r2,zero,20777c <alt_tick+0xb4>
      {
        alt_alarm_stop (alarm);
  207770:	e13ffd17 	ldw	r4,-12(fp)
  207774:	02076240 	call	207624 <alt_alarm_stop>
  207778:	00001006 	br	2077bc <alt_tick+0xf4>
      }
      else
      {
        alarm->time += next_callback;
  20777c:	e0bffd17 	ldw	r2,-12(fp)
  207780:	11000217 	ldw	r4,8(r2)
  207784:	11400317 	ldw	r5,12(r2)
  207788:	e0bffb17 	ldw	r2,-20(fp)
  20778c:	1021883a 	mov	r16,r2
  207790:	0023883a 	mov	r17,zero
  207794:	2405883a 	add	r2,r4,r16
  207798:	110d803a 	cmpltu	r6,r2,r4
  20779c:	2c47883a 	add	r3,r5,r17
  2077a0:	30c9883a 	add	r4,r6,r3
  2077a4:	2007883a 	mov	r3,r4
  2077a8:	1009883a 	mov	r4,r2
  2077ac:	180b883a 	mov	r5,r3
  2077b0:	e0bffd17 	ldw	r2,-12(fp)
  2077b4:	11000215 	stw	r4,8(r2)
  2077b8:	11400315 	stw	r5,12(r2)
      }
    }
    alarm = next;
  2077bc:	e0bffc17 	ldw	r2,-16(fp)
  2077c0:	e0bffd15 	stw	r2,-12(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
  2077c4:	e0fffd17 	ldw	r3,-12(fp)
  2077c8:	d0a00b04 	addi	r2,gp,-32724
  2077cc:	18bfd41e 	bne	r3,r2,207720 <alt_tick+0x58>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  2077d0:	0001883a 	nop
}
  2077d4:	0001883a 	nop
  2077d8:	e6fffe04 	addi	sp,fp,-8
  2077dc:	dfc00317 	ldw	ra,12(sp)
  2077e0:	df000217 	ldw	fp,8(sp)
  2077e4:	dc400117 	ldw	r17,4(sp)
  2077e8:	dc000017 	ldw	r16,0(sp)
  2077ec:	dec00404 	addi	sp,sp,16
  2077f0:	f800283a 	ret

002077f4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  2077f4:	deffff04 	addi	sp,sp,-4
  2077f8:	df000015 	stw	fp,0(sp)
  2077fc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  207800:	000170fa 	wrctl	ienable,zero
}
  207804:	0001883a 	nop
  207808:	e037883a 	mov	sp,fp
  20780c:	df000017 	ldw	fp,0(sp)
  207810:	dec00104 	addi	sp,sp,4
  207814:	f800283a 	ret

00207818 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  207818:	defffa04 	addi	sp,sp,-24
  20781c:	dfc00515 	stw	ra,20(sp)
  207820:	df000415 	stw	fp,16(sp)
  207824:	df000404 	addi	fp,sp,16
  207828:	e13ffd15 	stw	r4,-12(fp)
  20782c:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
  207830:	e0bffc17 	ldw	r2,-16(fp)
  207834:	10800017 	ldw	r2,0(r2)
  207838:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  20783c:	e13ffd17 	ldw	r4,-12(fp)
  207840:	02004080 	call	200408 <strlen>
  207844:	10800044 	addi	r2,r2,1
  207848:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  20784c:	00000d06 	br	207884 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  207850:	e0bfff17 	ldw	r2,-4(fp)
  207854:	10800217 	ldw	r2,8(r2)
  207858:	e0fffe17 	ldw	r3,-8(fp)
  20785c:	180d883a 	mov	r6,r3
  207860:	e17ffd17 	ldw	r5,-12(fp)
  207864:	1009883a 	mov	r4,r2
  207868:	0207b900 	call	207b90 <memcmp>
  20786c:	1000021e 	bne	r2,zero,207878 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  207870:	e0bfff17 	ldw	r2,-4(fp)
  207874:	00000706 	br	207894 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  207878:	e0bfff17 	ldw	r2,-4(fp)
  20787c:	10800017 	ldw	r2,0(r2)
  207880:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
  207884:	e0ffff17 	ldw	r3,-4(fp)
  207888:	e0bffc17 	ldw	r2,-16(fp)
  20788c:	18bff01e 	bne	r3,r2,207850 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
  207890:	0005883a 	mov	r2,zero
}
  207894:	e037883a 	mov	sp,fp
  207898:	dfc00117 	ldw	ra,4(sp)
  20789c:	df000017 	ldw	fp,0(sp)
  2078a0:	dec00204 	addi	sp,sp,8
  2078a4:	f800283a 	ret

002078a8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  2078a8:	defffb04 	addi	sp,sp,-20
  2078ac:	dfc00415 	stw	ra,16(sp)
  2078b0:	df000315 	stw	fp,12(sp)
  2078b4:	df000304 	addi	fp,sp,12
  2078b8:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  2078bc:	d0a00317 	ldw	r2,-32756(gp)
  2078c0:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  2078c4:	00003106 	br	20798c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
  2078c8:	e0bfff17 	ldw	r2,-4(fp)
  2078cc:	10800217 	ldw	r2,8(r2)
  2078d0:	1009883a 	mov	r4,r2
  2078d4:	02004080 	call	200408 <strlen>
  2078d8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  2078dc:	e0bfff17 	ldw	r2,-4(fp)
  2078e0:	10c00217 	ldw	r3,8(r2)
  2078e4:	e0bffe17 	ldw	r2,-8(fp)
  2078e8:	10bfffc4 	addi	r2,r2,-1
  2078ec:	1885883a 	add	r2,r3,r2
  2078f0:	10800003 	ldbu	r2,0(r2)
  2078f4:	10803fcc 	andi	r2,r2,255
  2078f8:	1080201c 	xori	r2,r2,128
  2078fc:	10bfe004 	addi	r2,r2,-128
  207900:	10800bd8 	cmpnei	r2,r2,47
  207904:	1000031e 	bne	r2,zero,207914 <alt_find_file+0x6c>
    {
      len -= 1;
  207908:	e0bffe17 	ldw	r2,-8(fp)
  20790c:	10bfffc4 	addi	r2,r2,-1
  207910:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  207914:	e0bffe17 	ldw	r2,-8(fp)
  207918:	e0fffd17 	ldw	r3,-12(fp)
  20791c:	1885883a 	add	r2,r3,r2
  207920:	10800003 	ldbu	r2,0(r2)
  207924:	10803fcc 	andi	r2,r2,255
  207928:	1080201c 	xori	r2,r2,128
  20792c:	10bfe004 	addi	r2,r2,-128
  207930:	10800be0 	cmpeqi	r2,r2,47
  207934:	1000081e 	bne	r2,zero,207958 <alt_find_file+0xb0>
  207938:	e0bffe17 	ldw	r2,-8(fp)
  20793c:	e0fffd17 	ldw	r3,-12(fp)
  207940:	1885883a 	add	r2,r3,r2
  207944:	10800003 	ldbu	r2,0(r2)
  207948:	10803fcc 	andi	r2,r2,255
  20794c:	1080201c 	xori	r2,r2,128
  207950:	10bfe004 	addi	r2,r2,-128
  207954:	10000a1e 	bne	r2,zero,207980 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
  207958:	e0bfff17 	ldw	r2,-4(fp)
  20795c:	10800217 	ldw	r2,8(r2)
  207960:	e0fffe17 	ldw	r3,-8(fp)
  207964:	180d883a 	mov	r6,r3
  207968:	e17ffd17 	ldw	r5,-12(fp)
  20796c:	1009883a 	mov	r4,r2
  207970:	0207b900 	call	207b90 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
  207974:	1000021e 	bne	r2,zero,207980 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
  207978:	e0bfff17 	ldw	r2,-4(fp)
  20797c:	00000706 	br	20799c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
  207980:	e0bfff17 	ldw	r2,-4(fp)
  207984:	10800017 	ldw	r2,0(r2)
  207988:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
  20798c:	e0ffff17 	ldw	r3,-4(fp)
  207990:	d0a00304 	addi	r2,gp,-32756
  207994:	18bfcc1e 	bne	r3,r2,2078c8 <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
  207998:	0005883a 	mov	r2,zero
}
  20799c:	e037883a 	mov	sp,fp
  2079a0:	dfc00117 	ldw	ra,4(sp)
  2079a4:	df000017 	ldw	fp,0(sp)
  2079a8:	dec00204 	addi	sp,sp,8
  2079ac:	f800283a 	ret

002079b0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  2079b0:	defffc04 	addi	sp,sp,-16
  2079b4:	df000315 	stw	fp,12(sp)
  2079b8:	df000304 	addi	fp,sp,12
  2079bc:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
  2079c0:	00bffa04 	movi	r2,-24
  2079c4:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  2079c8:	e03fff15 	stw	zero,-4(fp)
  2079cc:	00001706 	br	207a2c <alt_get_fd+0x7c>
  {
    if (!alt_fd_list[i].dev)
  2079d0:	e0bfff17 	ldw	r2,-4(fp)
  2079d4:	10c00324 	muli	r3,r2,12
  2079d8:	00800874 	movhi	r2,33
  2079dc:	1885883a 	add	r2,r3,r2
  2079e0:	10a0e017 	ldw	r2,-31872(r2)
  2079e4:	10000e1e 	bne	r2,zero,207a20 <alt_get_fd+0x70>
    {
      alt_fd_list[i].dev = dev;
  2079e8:	e0bfff17 	ldw	r2,-4(fp)
  2079ec:	11000324 	muli	r4,r2,12
  2079f0:	e0fffd17 	ldw	r3,-12(fp)
  2079f4:	00800874 	movhi	r2,33
  2079f8:	2085883a 	add	r2,r4,r2
  2079fc:	10e0e015 	stw	r3,-31872(r2)
      if (i > alt_max_fd)
  207a00:	d0e00717 	ldw	r3,-32740(gp)
  207a04:	e0bfff17 	ldw	r2,-4(fp)
  207a08:	1880020e 	bge	r3,r2,207a14 <alt_get_fd+0x64>
      {
        alt_max_fd = i;
  207a0c:	e0bfff17 	ldw	r2,-4(fp)
  207a10:	d0a00715 	stw	r2,-32740(gp)
      }
      rc = i;
  207a14:	e0bfff17 	ldw	r2,-4(fp)
  207a18:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  207a1c:	00000706 	br	207a3c <alt_get_fd+0x8c>
  for (i = 0; i < ALT_MAX_FD; i++)
  207a20:	e0bfff17 	ldw	r2,-4(fp)
  207a24:	10800044 	addi	r2,r2,1
  207a28:	e0bfff15 	stw	r2,-4(fp)
  207a2c:	e0bfff17 	ldw	r2,-4(fp)
  207a30:	10800810 	cmplti	r2,r2,32
  207a34:	103fe61e 	bne	r2,zero,2079d0 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
  207a38:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  207a3c:	e0bffe17 	ldw	r2,-8(fp)
}
  207a40:	e037883a 	mov	sp,fp
  207a44:	df000017 	ldw	fp,0(sp)
  207a48:	dec00104 	addi	sp,sp,4
  207a4c:	f800283a 	ret

00207a50 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  207a50:	defffb04 	addi	sp,sp,-20
  207a54:	df000415 	stw	fp,16(sp)
  207a58:	df000404 	addi	fp,sp,16
  207a5c:	e13ffd15 	stw	r4,-12(fp)
  207a60:	e17ffc15 	stw	r5,-16(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  207a64:	e0bffc17 	ldw	r2,-16(fp)
  207a68:	10840070 	cmpltui	r2,r2,4097
  207a6c:	1000021e 	bne	r2,zero,207a78 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  207a70:	00840004 	movi	r2,4096
  207a74:	e0bffc15 	stw	r2,-16(fp)
  }

  end = ((char*) start) + len;
  207a78:	e0fffd17 	ldw	r3,-12(fp)
  207a7c:	e0bffc17 	ldw	r2,-16(fp)
  207a80:	1885883a 	add	r2,r3,r2
  207a84:	e0bffe15 	stw	r2,-8(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  207a88:	e0bffd17 	ldw	r2,-12(fp)
  207a8c:	e0bfff15 	stw	r2,-4(fp)
  207a90:	00000506 	br	207aa8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  207a94:	e0bfff17 	ldw	r2,-4(fp)
  207a98:	1000603a 	flushi	r2
  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  207a9c:	e0bfff17 	ldw	r2,-4(fp)
  207aa0:	10800804 	addi	r2,r2,32
  207aa4:	e0bfff15 	stw	r2,-4(fp)
  207aa8:	e0ffff17 	ldw	r3,-4(fp)
  207aac:	e0bffe17 	ldw	r2,-8(fp)
  207ab0:	18bff836 	bltu	r3,r2,207a94 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  207ab4:	e0bffd17 	ldw	r2,-12(fp)
  207ab8:	108007cc 	andi	r2,r2,31
  207abc:	10000226 	beq	r2,zero,207ac8 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  207ac0:	e0bfff17 	ldw	r2,-4(fp)
  207ac4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  207ac8:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  207acc:	0001883a 	nop
  207ad0:	e037883a 	mov	sp,fp
  207ad4:	df000017 	ldw	fp,0(sp)
  207ad8:	dec00104 	addi	sp,sp,4
  207adc:	f800283a 	ret

00207ae0 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  207ae0:	defffe04 	addi	sp,sp,-8
  207ae4:	df000115 	stw	fp,4(sp)
  207ae8:	df000104 	addi	fp,sp,4
  207aec:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  207af0:	e0bfff17 	ldw	r2,-4(fp)
  207af4:	10bffe84 	addi	r2,r2,-6
  207af8:	10c00428 	cmpgeui	r3,r2,16
  207afc:	18c03fcc 	andi	r3,r3,255
  207b00:	18000f1e 	bne	r3,zero,207b40 <alt_exception_cause_generated_bad_addr+0x60>
  207b04:	00c00044 	movi	r3,1
  207b08:	1884983a 	sll	r2,r3,r2
  207b0c:	10e2c8cc 	andi	r3,r2,35619
  207b10:	1806c03a 	cmpne	r3,r3,zero
  207b14:	18c03fcc 	andi	r3,r3,255
  207b18:	1800051e 	bne	r3,zero,207b30 <alt_exception_cause_generated_bad_addr+0x50>
  207b1c:	1084100c 	andi	r2,r2,4160
  207b20:	1004c03a 	cmpne	r2,r2,zero
  207b24:	10803fcc 	andi	r2,r2,255
  207b28:	1000031e 	bne	r2,zero,207b38 <alt_exception_cause_generated_bad_addr+0x58>
  207b2c:	00000406 	br	207b40 <alt_exception_cause_generated_bad_addr+0x60>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  207b30:	00800044 	movi	r2,1
  207b34:	00000306 	br	207b44 <alt_exception_cause_generated_bad_addr+0x64>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  207b38:	0005883a 	mov	r2,zero
  207b3c:	00000106 	br	207b44 <alt_exception_cause_generated_bad_addr+0x64>

  default:
    return 0;
  207b40:	0005883a 	mov	r2,zero
  }
}
  207b44:	e037883a 	mov	sp,fp
  207b48:	df000017 	ldw	fp,0(sp)
  207b4c:	dec00104 	addi	sp,sp,4
  207b50:	f800283a 	ret

00207b54 <atexit>:
 * Register a function to be performed at exit.
 */

int
atexit (void (*fn) (void))
{
  207b54:	defffd04 	addi	sp,sp,-12
  207b58:	dfc00215 	stw	ra,8(sp)
  207b5c:	df000115 	stw	fp,4(sp)
  207b60:	df000104 	addi	fp,sp,4
  207b64:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
  207b68:	000f883a 	mov	r7,zero
  207b6c:	000d883a 	mov	r6,zero
  207b70:	e17fff17 	ldw	r5,-4(fp)
  207b74:	0009883a 	mov	r4,zero
  207b78:	0207cc40 	call	207cc4 <__register_exitproc>
}
  207b7c:	e037883a 	mov	sp,fp
  207b80:	dfc00117 	ldw	ra,4(sp)
  207b84:	df000017 	ldw	fp,0(sp)
  207b88:	dec00204 	addi	sp,sp,8
  207b8c:	f800283a 	ret

00207b90 <memcmp>:

int
memcmp (const void *m1,
	const void *m2,
	size_t n)
{
  207b90:	defff804 	addi	sp,sp,-32
  207b94:	df000715 	stw	fp,28(sp)
  207b98:	df000704 	addi	fp,sp,28
  207b9c:	e13ffb15 	stw	r4,-20(fp)
  207ba0:	e17ffa15 	stw	r5,-24(fp)
  207ba4:	e1bff915 	stw	r6,-28(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
  207ba8:	e0bffb17 	ldw	r2,-20(fp)
  207bac:	e0bfff15 	stw	r2,-4(fp)
  unsigned char *s2 = (unsigned char *) m2;
  207bb0:	e0bffa17 	ldw	r2,-24(fp)
  207bb4:	e0bffe15 	stw	r2,-8(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
  207bb8:	e0bff917 	ldw	r2,-28(fp)
  207bbc:	10800130 	cmpltui	r2,r2,4
  207bc0:	1000371e 	bne	r2,zero,207ca0 <memcmp+0x110>
  207bc4:	e0ffff17 	ldw	r3,-4(fp)
  207bc8:	e0bffe17 	ldw	r2,-8(fp)
  207bcc:	1884b03a 	or	r2,r3,r2
  207bd0:	108000cc 	andi	r2,r2,3
  207bd4:	1000321e 	bne	r2,zero,207ca0 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
  207bd8:	e0bfff17 	ldw	r2,-4(fp)
  207bdc:	e0bffd15 	stw	r2,-12(fp)
      a2 = (unsigned long*) s2;
  207be0:	e0bffe17 	ldw	r2,-8(fp)
  207be4:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
  207be8:	00000e06 	br	207c24 <memcmp+0x94>
        {
          if (*a1 != *a2) 
  207bec:	e0bffd17 	ldw	r2,-12(fp)
  207bf0:	10c00017 	ldw	r3,0(r2)
  207bf4:	e0bffc17 	ldw	r2,-16(fp)
  207bf8:	10800017 	ldw	r2,0(r2)
  207bfc:	18800d1e 	bne	r3,r2,207c34 <memcmp+0xa4>
   	    break;
          a1++;
  207c00:	e0bffd17 	ldw	r2,-12(fp)
  207c04:	10800104 	addi	r2,r2,4
  207c08:	e0bffd15 	stw	r2,-12(fp)
          a2++;
  207c0c:	e0bffc17 	ldw	r2,-16(fp)
  207c10:	10800104 	addi	r2,r2,4
  207c14:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
  207c18:	e0bff917 	ldw	r2,-28(fp)
  207c1c:	10bfff04 	addi	r2,r2,-4
  207c20:	e0bff915 	stw	r2,-28(fp)
      while (n >= LBLOCKSIZE)
  207c24:	e0bff917 	ldw	r2,-28(fp)
  207c28:	10800128 	cmpgeui	r2,r2,4
  207c2c:	103fef1e 	bne	r2,zero,207bec <memcmp+0x5c>
  207c30:	00000106 	br	207c38 <memcmp+0xa8>
   	    break;
  207c34:	0001883a 	nop
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
  207c38:	e0bffd17 	ldw	r2,-12(fp)
  207c3c:	e0bfff15 	stw	r2,-4(fp)
      s2 = (unsigned char*)a2;
  207c40:	e0bffc17 	ldw	r2,-16(fp)
  207c44:	e0bffe15 	stw	r2,-8(fp)
    }

  while (n--)
  207c48:	00001506 	br	207ca0 <memcmp+0x110>
    {
      if (*s1 != *s2)
  207c4c:	e0bfff17 	ldw	r2,-4(fp)
  207c50:	10c00003 	ldbu	r3,0(r2)
  207c54:	e0bffe17 	ldw	r2,-8(fp)
  207c58:	10800003 	ldbu	r2,0(r2)
  207c5c:	18c03fcc 	andi	r3,r3,255
  207c60:	10803fcc 	andi	r2,r2,255
  207c64:	18800826 	beq	r3,r2,207c88 <memcmp+0xf8>
	return *s1 - *s2;
  207c68:	e0bfff17 	ldw	r2,-4(fp)
  207c6c:	10800003 	ldbu	r2,0(r2)
  207c70:	10c03fcc 	andi	r3,r2,255
  207c74:	e0bffe17 	ldw	r2,-8(fp)
  207c78:	10800003 	ldbu	r2,0(r2)
  207c7c:	10803fcc 	andi	r2,r2,255
  207c80:	1885c83a 	sub	r2,r3,r2
  207c84:	00000b06 	br	207cb4 <memcmp+0x124>
      s1++;
  207c88:	e0bfff17 	ldw	r2,-4(fp)
  207c8c:	10800044 	addi	r2,r2,1
  207c90:	e0bfff15 	stw	r2,-4(fp)
      s2++;
  207c94:	e0bffe17 	ldw	r2,-8(fp)
  207c98:	10800044 	addi	r2,r2,1
  207c9c:	e0bffe15 	stw	r2,-8(fp)
  while (n--)
  207ca0:	e0bff917 	ldw	r2,-28(fp)
  207ca4:	10ffffc4 	addi	r3,r2,-1
  207ca8:	e0fff915 	stw	r3,-28(fp)
  207cac:	103fe71e 	bne	r2,zero,207c4c <memcmp+0xbc>
    }

  return 0;
  207cb0:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
  207cb4:	e037883a 	mov	sp,fp
  207cb8:	df000017 	ldw	fp,0(sp)
  207cbc:	dec00104 	addi	sp,sp,4
  207cc0:	f800283a 	ret

00207cc4 <__register_exitproc>:
int
__register_exitproc (int type,
	void (*fn) (void),
	void *arg,
	void *d)
{
  207cc4:	defff904 	addi	sp,sp,-28
  207cc8:	df000615 	stw	fp,24(sp)
  207ccc:	dc000515 	stw	r16,20(sp)
  207cd0:	df000604 	addi	fp,sp,24
  207cd4:	e13ffd15 	stw	r4,-12(fp)
  207cd8:	e17ffc15 	stw	r5,-16(fp)
  207cdc:	e1bffb15 	stw	r6,-20(fp)
  207ce0:	e1fffa15 	stw	r7,-24(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

  p = __atexit;
  207ce4:	d4262017 	ldw	r16,-26496(gp)
  if (p == NULL)
  207ce8:	8000031e 	bne	r16,zero,207cf8 <__register_exitproc+0x34>
    {
      __atexit = p = &__atexit0;
  207cec:	04000874 	movhi	r16,33
  207cf0:	842c4a04 	addi	r16,r16,-20184
  207cf4:	d4262015 	stw	r16,-26496(gp)
      extern struct _on_exit_args * const __on_exit_args _ATTRIBUTE ((weak));
      if (&__on_exit_args != NULL)
	p->_on_exit_args_ptr = __on_exit_args;
#endif	/* def _REENT_SMALL */
    }
  if (p->_ind >= _ATEXIT_SIZE)
  207cf8:	80800117 	ldw	r2,4(r16)
  207cfc:	10800810 	cmplti	r2,r2,32
  207d00:	1000021e 	bne	r2,zero,207d0c <__register_exitproc+0x48>
    {
#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
#ifndef __SINGLE_THREAD__
      __lock_release_recursive(__atexit_recursive_mutex);
#endif
      return -1;
  207d04:	00bfffc4 	movi	r2,-1
  207d08:	00002d06 	br	207dc0 <__register_exitproc+0xfc>
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
  207d0c:	e0bffd17 	ldw	r2,-12(fp)
  207d10:	10002226 	beq	r2,zero,207d9c <__register_exitproc+0xd8>
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
#endif
	}
#else
      args = &p->_on_exit_args;
  207d14:	80802204 	addi	r2,r16,136
  207d18:	e0bffe15 	stw	r2,-8(fp)
#endif
      args->_fnargs[p->_ind] = arg;
  207d1c:	80800117 	ldw	r2,4(r16)
  207d20:	e0fffe17 	ldw	r3,-8(fp)
  207d24:	100490ba 	slli	r2,r2,2
  207d28:	1885883a 	add	r2,r3,r2
  207d2c:	e0fffb17 	ldw	r3,-20(fp)
  207d30:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
  207d34:	e0bffe17 	ldw	r2,-8(fp)
  207d38:	10804017 	ldw	r2,256(r2)
  207d3c:	80c00117 	ldw	r3,4(r16)
  207d40:	01000044 	movi	r4,1
  207d44:	20c6983a 	sll	r3,r4,r3
  207d48:	10c6b03a 	or	r3,r2,r3
  207d4c:	e0bffe17 	ldw	r2,-8(fp)
  207d50:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
  207d54:	80800117 	ldw	r2,4(r16)
  207d58:	e0fffe17 	ldw	r3,-8(fp)
  207d5c:	10800804 	addi	r2,r2,32
  207d60:	100490ba 	slli	r2,r2,2
  207d64:	1885883a 	add	r2,r3,r2
  207d68:	e0fffa17 	ldw	r3,-24(fp)
  207d6c:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
  207d70:	e0bffd17 	ldw	r2,-12(fp)
  207d74:	10800098 	cmpnei	r2,r2,2
  207d78:	1000081e 	bne	r2,zero,207d9c <__register_exitproc+0xd8>
	args->_is_cxa |= (1 << p->_ind);
  207d7c:	e0bffe17 	ldw	r2,-8(fp)
  207d80:	10804117 	ldw	r2,260(r2)
  207d84:	80c00117 	ldw	r3,4(r16)
  207d88:	01000044 	movi	r4,1
  207d8c:	20c6983a 	sll	r3,r4,r3
  207d90:	10c6b03a 	or	r3,r2,r3
  207d94:	e0bffe17 	ldw	r2,-8(fp)
  207d98:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
  207d9c:	80800117 	ldw	r2,4(r16)
  207da0:	10c00044 	addi	r3,r2,1
  207da4:	80c00115 	stw	r3,4(r16)
  207da8:	10800084 	addi	r2,r2,2
  207dac:	100490ba 	slli	r2,r2,2
  207db0:	8085883a 	add	r2,r16,r2
  207db4:	e0fffc17 	ldw	r3,-16(fp)
  207db8:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif
  return 0;
  207dbc:	0005883a 	mov	r2,zero
}
  207dc0:	e6ffff04 	addi	sp,fp,-4
  207dc4:	df000117 	ldw	fp,4(sp)
  207dc8:	dc000017 	ldw	r16,0(sp)
  207dcc:	dec00204 	addi	sp,sp,8
  207dd0:	f800283a 	ret
